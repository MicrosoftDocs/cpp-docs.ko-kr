---
title: ARM64 예외 처리
description: ARM64에서 Windows가 사용하는 예외 처리 규칙 및 데이터에 대해 설명합니다.
ms.date: 11/19/2018
ms.openlocfilehash: abc77aa683e73a2740c71ffbd7ddead07f91ff7d
ms.sourcegitcommit: 5bb421fdf61d290cac93a03e16a6a80959accf6d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/26/2020
ms.locfileid: "83854829"
---
# <a name="arm64-exception-handling"></a>ARM64 예외 처리

Windows on ARM64는 하드웨어에서 생성하는 비동기식 예외 및 소프트웨어에서 생성하는 동기식 예외에 대해 동일한 구조적 예외 처리 메커니즘을 사용합니다. 언어별 예외 처리기가 언어 도우미 함수를 사용하여 Windows의 구조적 예외 처리를 기반으로 작성됩니다. 이 문서에서는 Windows on ARM64의 예외 처리, Microsoft ARM 어셈블러와 MSVC 컴파일러로 생성되는 코드에서 사용하는 언어 도우미에 대해 설명합니다.

## <a name="goals-and-motivation"></a>목표 및 동기

예외 해제 데이터 규칙 및 이 설명의 목적은 다음과 같습니다.

1. 모든 경우에 코드를 검색하지 않고 해제할 수 있는 충분한 설명을 제공합니다.

   - 코드를 분석하려면 코드를 호출해야 합니다. 이렇게 하면 유용한 일부 상황(추적, 샘플링, 디버깅)에서 해제되지 않습니다.

   - 코드를 분석하는 것은 복잡합니다. 따라서 컴파일러는 해제기에서 디코딩할 수 있는 명령만 생성하도록 주의해야 합니다.

   - 해제 코드 사용을 통해 해제를 완전히 설명할 수 없다면 일부 경우에는 명령 디코딩으로 대체해야 합니다. 이렇게 하면 전반적인 복잡성이 증가하므로 피하는 것이 이상적입니다.

1. 중간 프롤로그 및 중간 에필로그에서 해제를 지원합니다.

   - 해제는 Windows에서 예외 처리보다 더 많이 사용됩니다. 프롤로그 또는 에필로그 코드 시퀀스의 중간에 있는 경우에도 코드가 정확하게 해제될 수 있습니다.

1. 최소한의 공간을 차지합니다.

   - 해제 코드는 이진 크기를 크게 늘리도록 집계되어서는 안 됩니다.

   - 해제 코드는 메모리에서 잠길 수 있으므로 작은 메모리 공간은 로드된 각 이진에 대해 최소한의 오버헤드를 보장합니다.

## <a name="assumptions"></a>Assumptions

예외 처리 설명에 다음의 가정이 적용됩니다.

1. 프롤로그와 에필로그는 서로 미러링되는 경향이 있습니다. 일반적인 특성을 활용하여 해제를 설명하는 데 필요한 메타 데이터의 크기를 크게 줄일 수 있습니다. 함수 본문 내에서는 프롤로그 작업을 실행 취소했는지 아니면 에필로그 작업을 정방향으로 수행했는지에 중요하지 않습니다. 두 작업에서 모두 같은 결과가 생성됩니다.

1. 함수는 전체적으로 비교적 크기가 작은 경우가 많습니다. 공간에 대한 몇 가지 최적화는 이 팩트에 의존하여 가장 효율적인 데이터 압축을 구현합니다.

1. 에필로그에는 조건부 코드가 없습니다.

1. 전용 프레임 포인터 레지스터: SP가 프롤로그의 다른 레지스터(x29)에 저장된 경우 해당 레지스터는 함수 전체에 그대로 유지됩니다. 이는 원래 SP가 언제든지 복구될 수 있음을 의미합니다.

1. SP를 다른 레지스터에 저장하는 경우가 아니면 모든 스택 포인터 조작은 반드시 프롤로그 및 에필로그 내에서만 수행해야 합니다.

1. 스택 프레임 레이아웃은 다음 섹션에 설명된 대로 구성됩니다.

## <a name="arm64-stack-frame-layout"></a>ARM64 스택 프레임 레이아웃

![스택 프레임 레이아웃](media/arm64-exception-handling-stack-frame.png "스택 프레임 레이아웃")

프레임 연결 함수의 경우 최적화 고려 사항에 따라 fp 및 lr 쌍을 로컬 변수 영역의 임의 위치에 저장할 수 있습니다. 목표는 프레임 포인터(x29) 또는 스택 포인터(sp)를 기반으로 하는 단일 명령으로 도달할 수 있는 지역 수를 최대화하는 것입니다. 그러나 `alloca` 함수의 경우 연결되어야 하고 x29는 스택의 맨 아래를 가리켜야 합니다. 레지스터 쌍 주소 지정 모드를 향상하기 위해 비휘발성 레지스터 저장 영역은 로컬 영역 스택의 맨 위에 배치됩니다. 가장 효율적인 여러 프롤로그 시퀀스를 보여 주는 예제는 다음과 같습니다. 명확성 및 보다 나은 캐시 위치를 위해 모든 정식 프롤로그에서 호출 수신자 저장 레지스터의 순서는 “증가”순입니다. 아래 `#framesz`는 전체 스택의 크기(alloca 영역 제외)를 나타냅니다. `#localsz` 및 `#outsz`는 로컬 영역 크기(\<x29, lr > 쌍의 저장 영역 포함) 및 나가는 매개 변수 크기를 각각 나타냅니다.

1. 연결됨, #localsz \<= 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        stp    x29,lr,[sp,#-localsz]!   // save <x29,lr> at bottom of local area
        mov    x29,sp                   // x29 points to bottom of local
        sub    sp,sp,#outsz             // (optional for #outsz != 0)
    ```

1. 연결됨, #localsz > 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        sub    sp,sp,#(localsz+outsz)   // allocate remaining frame
        stp    x29,lr,[sp,#outsz]       // save <x29,lr> at bottom of local area
        add    x29,sp,#outsz            // setup x29 points to bottom of local area
    ```

1. 연결되지 않은 리프 함수(lr 저장되지 않음)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]
        str    x23,[sp,#32]
        stp    d8,d9,[sp,#40]           // save FP regs (optional)
        stp    d10,d11,[sp,#56]
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   모든 로컬은 SP를 기준으로 액세스됩니다. \<x29, lr > 이전 프레임을 가리킵니다. 프레임 크기 \<= 512의 경우 “sub sp, ...”는 regs가 저장된 영역이 스택의 맨 아래로 이동하는 경우에 최적화할 수 있습니다. 단점은 위의 다른 레이아웃과 일치하지 않으며 저장된 regs는 쌍-regs 및 사전 및 사후 인덱싱된 오프셋 주소 지정 모드의 일부를 차지합니다.

1. 연결되지 않음, 리프가 아닌 함수(lr은 Int 저장 영역에 저장됨)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        stp    x23,lr,[sp,#32]          // save last Int reg and lr
        stp    d8,d9,[sp,#48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#64]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   또는 짝수 저장 Int 레지스터를 사용하여

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        str    lr,[sp,#32]              // save lr
        stp    d8,d9,[sp,#40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#56]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   x19만 저장됨:

    ```asm
        sub    sp,sp,#16                // reg save area allocation*
        stp    x19,lr,[sp]              // save x19, lr
        sub    sp,sp,#(framesz-16)      // allocate the remaining local area
    ```

   \* 사전 인덱싱된 reg-lr stp를 해제 코드로 표현할 수 없으므로 reg 저장 영역 할당은 stp로 중첩되지 않습니다.

   모든 로컬은 SP를 기준으로 액세스됩니다. \<x29> 이전 프레임을 가리킵니다.

1. 연결됨, #framesz \<= 512, #outsz = 0

    ```asm
        stp    x29,lr,[sp,#-framesz]!       // pre-indexed, save <x29,lr>
        mov    x29,sp                       // x29 points to bottom of stack
        stp    x19,x20,[sp,#(framesz-32)]   // save INT pair
        stp    d8,d9,[sp,#(framesz-16)]     // save FP pair
    ```

   위의 첫 번째 프롤로그 예제와 비교할 때, 여기에서 이점은 하나의 스택 할당 명령 후에 모든 레지스터 저장 명령을 실행할 준비가 되었다는 것입니다. 즉, 명령 수준 병렬 처리를 막는 sp에 대한 반 종속성(anti-dependence)이 없습니다.

1. 연결됨, 프레임 크기 > 512(alloca 없는 함수의 경우 선택 사항)

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        sub    sp,sp,#(framesz-80)          // allocate the remaining local area
    ```

   최적화를 위해 x29는 로컬 영역에서 임의의 위치에 배치하여 “reg-pair” 및 사전/사후 인덱스 주소 지정 모드에 대한 향상된 범위를 제공할 수 있습니다. 프레임 포인터 아래에 있는 로컬은 SP를 기준으로 액세스할 수 있습니다.

1. 연결됨, 프레임 크기 > 4K, alloca() 포함 또는 미포함,

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        mov    x15,#(framesz/16)
        bl     __chkstk
        sub    sp,sp,x15,lsl#4              // allocate remaining frame
                                            // end of prolog
        ...
        sub    sp,sp,#alloca                // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,x29                       // sp points to top of local area
        ldp    d10,d11,[sp,#64]
        ...
        ldp    x29,lr,[sp],#80              // post-indexed, reload <x29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>ARM64 예외 처리 정보

### <a name="pdata-records"></a>.pdata 레코드

.pdata 레코드는 PE 형식 이진의 모든 스택 조작 함수를 설명하는 고정 길이 항목의 정렬된 배열입니다. “스택 조작”이란 용어는 중요합니다. 로컬 스토리지가 필요하지 않은 리프 함수이며, 비휘발성 레지스터를 저장/복원할 필요가 없고, .pdata 레코드가 필요하지 않습니다. 레코드는 공간을 절약하기 위해 명시적으로 생략해야 합니다. 관련 함수 중 하나에서 해제하면 호출자로 이동하기 위해 LR에서 직접 반환 주소를 가져올 수 있습니다.

ARM64에 대한 각 .pdata 레코드의 길이는 8바이트입니다. 일반적인 각 레코드 형식에서는 처음 단어에 함수 시작의 32비트 RVA가 배치되고, 가변 길이 .xdata 블록에 대한 포인터 또는 정식 함수 해제 시퀀스를 설명하는 압축된 단어를 포함하는 두 번째 단어가 그 뒤에 붙습니다.

![.pdata 레코드 레이아웃](media/arm64-exception-handling-pdata-record.png ".pdata 레코드 레이아웃")

필드는 다음과 같습니다.

- **함수 시작 RVA**는 함수 시작 부분의 32비트 RVA입니다.

- **플래그**는 두 번째 .pdata 단어의 나머지 30비트를 해석하는 방법을 나타내는 2비트 필드입니다. **플래그**가 0이면 나머지 비트는 **예외 정보 RVA**가 됩니다(최하위 2비트는 암시적으로 0이 됨). **플래그**가 0이 아니면 나머지 비트는 **압축된 해제 데이터** 구조체가 됩니다.

- **예외 정보 RVA**는 .xdata 섹션에 저장되는 가변 길이 예외 정보 구조체의 주소입니다. 이 데이터는 4비트 단위로 정렬되어야 합니다.

- **압축된 해제 데이터**는 함수에서 해제하는 데 필요한 작업의 압축된 설명이며 정규형을 취합니다. 이 경우에는 .xdata 레코드가 필요하지 않습니다.

### <a name="xdata-records"></a>.xdata 레코드

압축된 해제 형식만으로는 함수 해제를 설명하는 데 부족한 경우에는 가변 길이 .xdata 레코드를 만들어야 합니다. 이 레코드의 주소는 .pdata 레코드의 두 번째 단어에 저장됩니다. .xdata의 형식은 압축된 가변 길이 단어 집합입니다.

![.xdata 레코드 레이아웃](media/arm64-exception-handling-xdata-record.png ".xdata 레코드 레이아웃")

이 데이터는 네 개의 섹션으로 구분됩니다.

1. 구조체의 전체 크기를 설명하고 주요 함수 데이터를 제공하는 단어 1~2개로 구성된 헤더입니다. 두 번째 단어는 **에필로그 개수**와 **코드 단어** 필드가 모두 0으로 설정된 경우에만 존재합니다. 헤더에는 다음과 같은 비트 필드가 있습니다.

   a. **함수 길이**는 18비트 필드입니다. 함수의 전체 길이(바이트 단위)를 4로 나눈 결과를 나타냅니다. 함수가 1M보다 크면 여러 .pdata 및 .xdata 레코드를 사용하여 함수를 설명해야 합니다. 자세한 내용은 [큰 함수](#large-functions) 섹션을 참조하세요.

   b. **Vers**는 2비트 필드입니다. 나머지 .xdata의 버전을 설명합니다. 현재 버전 0만 정의되었으므로 1-3은 허용되지 않습니다.

   c. **X**는 1비트 필드입니다. 예외 데이터가 있는지(1) 없는지(0)를 나타냅니다.

   d. **E**는 1비트 필드입니다. 단일 에필로그가 나중에 추가 범위 단어를 요구(0)하는 대신 헤더에 압축(1)됨을 설명하는 정보를 나타냅니다.

   e. **에필로그 개수**는 **E** 비트의 상태에 따라 두 가지 의미가 될 수 있는 5비트 필드입니다.

      1. **E**가 0이면 섹션 2에 설명된 총 에필로그 범위의 수를 지정합니다. 함수에 31개가 넘는 범위가 있는 경우 **코드 단어** 필드를 0으로 설정하여 확장 단어가 필요함을 나타내야 합니다.

      2. **E**가 1이면 이 필드는 유일한 에필로그를 설명하는 첫 번째 해제 코드의 인덱스를 지정합니다.

   f. **코드 단어**는 섹션 3의 모든 해제 코드를 포함하는 데 필요한 32비트 단어의 수를 지정하는 5비트 필드입니다. 해제 코드 124바이트 이상에 대해 단어가 31개 이상 필요한 경우에는 이 필드를 모두 0으로 설정하여 확장 단어가 필요함을 나타내야 합니다.

   g. **확장된 에필로그 개수** 및 **확장 코드 단어**는 각각 16비트 및 8비트 필드입니다. 매우 많은 수의 에필로그 또는 매우 많은 수의 해제 코드 단어를 인코딩하기 위한 추가 공간을 제공합니다. 관련 필드를 포함하는 확장 단어는 **에필로그 개수** 및 **코드 단어** 필드가 모두 0인 경우에만 존재합니다.

1. **에필로그 개수**가 0이 아닌 경우 한 단어로 압축된 에필로그 범위에 대한 정보 목록이 헤더 및 옵션인 확장 헤더 뒤에 나옵니다. 이는 시작 오프셋이 늘어나는 순서로 저장됩니다. 각 범위에는 다음 비트가 포함됩니다.

   a. **에필로그 시작 오프셋**은 함수 시작 위치를 기준으로 하는 에필로그 오프셋(바이트 단위)을 4로 나눈 결과를 가지는 18비트 필드입니다.

   b. **Res**는 이후 확장을 위해 예약되는 4비트 필드입니다. 해당 값은 0이어야 합니다.

   c. **에필로그 시작 인덱스**는 10비트 필드입니다(**확장된 코드 단어**보다 2비트 많음). 에필로그를 설명하는 첫 번째 해제 코드의 바이트 인덱스를 나타냅니다.

1. 에필로그 범위 목록 다음에는 해제 코드를 포함하는 바이트 배열이 오며, 이는 이후 섹션에서 자세히 설명합니다. 이 배열은 가장 가까운 전체 단어 경계 끝에 채워집니다. 해제 코드는 이 배열에 기록됩니다. 함수 본문에 가장 가까운 것에서 시작하여 함수의 가장자리로 이동합니다. 각 해제 코드에 대한 바이트는 big-endian 순서로 저장되어 작업 및 나머지 코드의 길이를 식별하는 가장 중요한 바이트부터 시작하여 직접 페치할 수 있습니다.

1. 마지막으로 해제 코드 바이트 이후에 헤더의 **X** 비트가 1로 설정된 경우는 예외 처리기 정보가 나옵니다. 예외 처리기 자체의 주소를 제공하는 단일 **예외 처리기 RVA**로 구성됩니다. 예외 처리기에서 요구하는 가변 길이 데이터 바로 뒤에 옵니다.

.xdata 레코드는 처음 8바이트를 가져와 레코드의 전체 길이에서 그다음 가변 크기 예외 데이터의 길이를 뺀 길이를 계산할 수 있도록 설계됩니다. 다음 코드 조각은 레코드 크기를 계산합니다.

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 27) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x0f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    Size += 4 * EpilogScopes;
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;        // exception handler RVA
    }
    return Size;
}
```

프롤로그와 각 에필로그에 해제 코드로의 자체 인덱스가 있지만 테이블은 프롤로그와 에필로그에서 공유됩니다. 모두 동일한 코드를 공유하는 것은 완전히 가능하며 전혀 이상하지 않습니다. (예를 들어 [예제](#examples) 섹션에서 예제 2를 참조하세요.) 이럴 때 특히 컴파일러 작성기를 최적화해야 합니다. 지정할 수 있는 최대 인덱스는 255이므로 특정 함수에 대한 총 해제 코드 수가 제한되기 때문입니다.

### <a name="unwind-codes"></a>해제 코드

해제 코드 배열은 작업을 실행 취소해야 하는 동일한 순서로 저장된 프롤로그의 결과를 실행 취소하는 방법을 정확히 설명하는 시퀀스 풀입니다. 해제 코드는 바이트 문자열로 인코딩된 작은 명령 집합으로 생각할 수 있습니다. 실행이 완료되면 호출하는 함수에 대한 반환 주소는 lr 레지스터에 있습니다. 그리고 모든 비휘발성 레지스터는 함수가 호출될 때 해당 값으로 복원됩니다.

예외가 함수 본문 내에서만 발생하며 프롤로그 또는 에필로그 내에서는 발생하지 않음이 보장된다면 단일한 시퀀스 하나만 있으면 됩니다. 그러나 Windows 해제 모델에서는 코드가 부분적으로 실행된 프롤로그 또는 에필로그 내에서 해제할 수 있어야 합니다. 이 요구 사항을 충족하기 위해 해제 코드가 정교하게 설계하여 프롤로그와 에필로그의 각 관련 opcode로 명확하게 1:1 매핑되도록 했습니다. 이 설계에는 다음과 같은 여러 가지 의미가 있습니다.

1. 해제 코드 수를 계산하여 프롤로그 및 에필로그의 길이를 컴퓨팅할 수 있습니다.

1. 에필로그 범위가 시작된 후의 명령 수를 계산하면 해당하는 해제 코드 수를 건너뛸 수 있습니다. 그런 다음 나머지 시퀀스를 실행하여 에필로그에서 수행하는 부분적으로 실행된 해제를 완료할 수 있습니다.

1. 프롤로그의 끝 이전에 명령 수를 계산하면 해당하는 해제 코드 수를 건너뛸 수 있습니다. 그런 다음 나머지 시퀀스를 실행하여 실행이 완료된 프롤로그 부분만 실행 취소할 수 있습니다.

해제 코드는 아래 표에 따라 인코딩됩니다. 모든 해제 코드는 큰 스택을 할당하는 것을 제외하면 싱글/더블 바이트입니다. 총 21개의 해제 코드가 있습니다. 각 해제 코드는 프롤로그/에필로그에서 정확히 하나의 명령만 매핑하여 부분적으로 실행된 프롤로그 및 에필로그를 해제할 수 있습니다.

|해제 코드|비트 및 해석|
|-|-|
|`alloc_s`|000xxxxx: \< 512(2^5 * 16) 크기의 작은 스택 할당|
|`save_r19r20_x`|    001zzzzz: `[sp-#Z*8]!`에 \<x19, x20 >쌍 저장, 미리 인덱싱된 오프셋 > = -248 |
|`save_fplr`|        01zzzzzz: `[sp+#Z*8]`에 \<x29,lr> 쌍 저장, 오프셋 \<= 504. |
|`save_fplr_x`|        10zzzzzz: `[sp-(#Z+1)*8]!`에 \<x29, lr > 쌍 저장, 미리 인덱싱된 오프셋 >= -512 |
|`alloc_m`|        11000xxx'xxxxxxxx: \< 16k(2^11 * 16)크기의 대량 스택 할당 |
|`save_regp`|        110010xx'xxzzzzzz: `[sp+#Z*8]`에 x(19+#X) 쌍 저장, 오프셋 \<= 504 |
|`save_regp_x`|        110011xx'xxzzzzzz: `[sp-(#Z+1)*8]!`에 쌍 x(19+#X) 저장, 인덱싱된 오프셋 >= -512 |
|`save_reg`|        110100xx'xxzzzzzz: `[sp+#Z*8]`에 reg x(19+#X) 저장, 오프셋 \<= 504 |
|`save_reg_x`|        1101010x'xxxzzzzz: `[sp-(#Z+1)*8]!`에 reg x(19+#X) 저장, 미리 인덱싱된 오프셋 >= -256 |
|`save_lrpair`|         1101011x'xxzzzzzz: `[sp+#Z*8]`에 쌍 \<x(19+2*#X),lr> 저장, 오프셋 \<= 504 |
|`save_fregp`|        1101100x'xxzzzzzz: `[sp+#Z*8]`에 쌍 d(8+#X) 저장, 오프셋\<= 504 |
|`save_fregp_x`|        1101101x'xxzzzzzz: `[sp-(#Z+1)*8]!`에 쌍 d(8+#X) 저장, 미리 인덱싱된 오프셋 >= -512 |
|`save_freg`|        1101110x'xxzzzzzz: `[sp+#Z*8]`에 reg d(8+#X) 저장, 오프셋 \<= 504 |
|`save_freg_x`|        11011110'xxxzzzzz: `[sp-(#Z+1)*8]!`에 reg d(8+#X) 저장, 미리 인덱싱된 오프셋 >= -256 |
|`alloc_l`|         11100000'xxxxxxxx'xxxxxxxx'xxxxxxxx: \< 256M(2^24 *16)크기의 대량 스택 할당 |
|`set_fp`|        11100001: `mov x29,sp` 포함 x29 설정 |
|`add_fp`|        11100010'xxxxxxxx: `add x29,sp,#x*8` 포함 x29 설정 |
|`nop`|            11100011: 해제 작업 필요하지 않음 |
|`end`|            11100100: 해제 코드의 끝 에필로그에서 ret를 의미 |
|`end_c`|        11100101: 현재 연결된 범위에서 해제 코드의 끝 |
|`save_next`|        11100110: 다음 비휘발성 Int 또는 FP 레지스터 쌍 저장 |
| |            11100111: 예약됨 |
| |              11101xxx: asm 루틴에 대해서만 생성된 아래 사용자 지정 사례에 대해 예약됨 |
| |              11101000: MSFT_OP_TRAP_FRAME에 대한 사용자 지정 스택 |
| |              11101001: MSFT_OP_MACHINE_FRAME에 대한 사용자 지정 스택 |
| |              11101010: MSFT_OP_CONTEXT에 대한 사용자 지정 스택 |
| |              11101100: MSFT_OP_CLEAR_UNWOUND_TO_CALL에 대한 사용자 지정 스택 |
| |              1111xxxx: 예약됨 |

여러 바이트를 포함하는 큰 값의 명령에서는 가장 중요한 비트가 먼저 저장됩니다. 이 디자인을 사용하면 코드의 첫 번째 바이트만 조회하여 해제 코드의 총 크기(바이트)를 찾을 수 있습니다. 각 해제 코드는 프롤로그 또는 에필로그의 명령에 정확히 매핑되므로 프롤로그 또는 에필로그의 크기를 계산할 수 있습니다. 시퀀스 시작 부분부터 종료 부분까지 해제 코드 워크를 진행한 다음 조회 테이블 또는 비슷한 디바이스를 사용하여 해당 opcode의 길이를 확인합니다.

사후 인덱싱된 오프셋 주소 지정은 프롤로그에서 허용되지 않습니다. 모든 오프셋 범위(#Z)는 `save_r19r20_x`를 제외하고 STP/STR 주소 지정 인코딩과 일치하며, 이 경우 248은 모든 저장 영역(Int 레지스터 10개 + FP 레지스터 8개 + 입력 레지스터 8개)에 대해 충분합니다.

`save_next`는 Int 또는 FP 휘발성 레지스터 쌍에 대한 저장, `save_regp`, `save_regp_x`, `save_fregp`, `save_fregp_x`, `save_r19r20_x` 또는 다른 `save_next` 다음에 나와야 합니다. 다음 레지스터 쌍을 “증가” 순서대로 다음 16바이트 슬롯에 저장합니다. `save_next`는 마지막 Int 레지스터 쌍을 나타내는 `save-next` 뒤에 오는 첫 번째 FP 레지스터 쌍을 참조합니다.

일반 반환 및 점프 명령의 크기는 동일하기 때문에 마무리 호출 시나리오에는 분리된 `end` 해제 코드를 사용할 필요가 없습니다.

`end_c`는 최적화를 위해 인접하지 않은 함수 조각을 처리하도록 설계되었습니다. 현재 범위에 있는 해제 코드의 끝을 표시하는 `end_c` 다음에는 실제 `end` 종료된 해제 코드의 다른 시리즈를 사용해야 합니다. `end_c` 및 `end` 사이의 해제 코드는 부모 지역(“가상” 프롤로그)의 프롤로그 작업을 나타냅니다.  자세한 내용과 예제는 아래 섹션에 설명되어 있습니다.

### <a name="packed-unwind-data"></a>압축된 해제 데이터

프롤로그 및 에필로그가 아래에서 설명하는 정규형을 따르는 함수의 경우에는 압축된 해제 데이터를 사용할 수 있습니다. 그러면 .xdata 레코드를 전혀 사용할 필요가 없으므로 해제 데이터를 제공하는 비용이 크게 감소합니다. 정식 프롤로그 및 에필로그는 간단한 함수의 일반적인 요구 사항을 충족하도록 설계되었습니다. 예외 처리기가 필요하지 않으며, 설정 및 해체 작업을 표준 순서로 수행합니다.

압축 해제 데이터가 포함된 .pdata 레코드의 형식은 다음과 같습니다.

![압축된 해제 데이터가 포함된 .pdata 레코드](media/arm64-exception-handling-packed-unwind-data.png "압축된 해제 데이터가 포함된 .pdata 레코드")

필드는 다음과 같습니다.

- **함수 시작 RVA**는 함수 시작 부분의 32비트 RVA입니다.
- **플래그**는 위에서 설명한 대로 2비트 필드이며 다음과 같은 의미가 있습니다.
  - 00 = 사용하지 않은 압축된 해제 데이터, 나머지 비트는 .xdata 레코드를 가리킴
  - 01 = 범위 시작과 끝에서 단일 프롤로그 및 에필로그에 사용되는 압축 해제 데이터
  - 10 = 프롤로그 및 에필로그 없이 코드에 사용되는 압축된 해제 데이터이며, 구분된 함수 세그먼트를 설명하는 데 유용함
  - 11 = 예약됨
- **함수 길이**는 전체 함수의 길이(바이트 단위)를 4로 나눈 결과를 제공하는 11비트 필드입니다. 함수가 8k보다 크면 전체 .xdata 레코드를 대신 사용해야 합니다.
- **프레임 크기**는 이 함수에 대해 할당된 스택 바이트 수를 16으로 나눈 값을 나타내는 9비트 필드입니다. (8k-16)바이트보다 큰 스택을 할당하는 함수는 전체 .xdata 레코드를 사용해야 합니다. 여기에는 지역 변수 영역, 나가는 매개 변수 영역, 호출 수신자 저장 Int 및 FP 영역, 홈 매개 변수 영역이 포함되지만 동적 할당 영역은 제외됩니다.
- **CR**은 함수가 프레임 체인을 설정하는 추가 명령을 포함하고 링크를 반환하는지 나타내는 2비트 플래그입니다.
  - 00 = 연결되지 않은 함수, \<x29,lr> 쌍은 스택에 저장되지 않습니다.
  - 01 = 연결되지 않은 함수, \<lr>은 스택에 저장됩니다.
  - 10 = 예약됨
  - 11 = 연결된 함수, 저장/로드 쌍 명령은 프롤로그/에필로그 \<x29,lr>에 사용됩니다.
- **H**는 함수가 정수 매개 변수 레지스터(x0-x7)를 함수 시작 부분에 저장하여 호밍할지를 나타내는 1비트 플래그입니다. (값이 0이면 레지스터를 호밍하지 않고 1이면 레지스터를 호밍합니다.)
- **RegI**은 정식 스택 위치에 저장된 비휘발성 INT 레지스터(x19-x28)의 수를 나타내는 4비트 필드입니다.
- **RegF**는 정식 스택 위치에 저장된 비휘발성 FP 레지스터(d8-d15)의 수를 나타내는 3비트 필드입니다. (RegF=0: 저장된 FP 레지스터 없음, RegF>0: RegF+1 FP 레지스터가 저장됨). 하나의 FP 레지스터만 저장하는 함수에는 압축 해제 데이터를 사용할 수 없습니다.

위의 섹션에서 범주 1, 2(나가는 매개 변수 영역 없음), 3 및 4에 속하는 정식 프롤로그는 압축 해제 형식으로 나타낼 수 있습니다.  정식 함수에 대한 에필로그는 **H**가 효과가 없고, `set_fp` 명령이 생략되며, 단계의 순서와 각 단계의 명령이 에필로그에서 반전되는 것을 제외하면 비슷한 형태를 따릅니다. 압축된 .xdata에 대한 알고리즘은 다음 표에 자세히 설명된 단계를 따릅니다.

0단계: 각 영역의 크기를 미리 계산합니다.

1단계: Int 호출 수신자 저장 레지스터를 저장합니다.

2단계: 이 단계는 초기 섹션의 형식 4에만 적용됩니다. lr은 Int 영역 끝에 저장됩니다.

3단계: FP 호출 수신자 저장 레지스터를 저장합니다.

4단계: 홈 매개 변수 영역에 입력 인수를 저장합니다.

5단계: 로컬 영역, \<x29,lr> 쌍 및 나가는 매개 변수 영역을 포함하여 남은 스택을 할당합니다. 5a는 정식 형식 1에 해당합니다. 5b 및 5c는 정식 형식 2에 대한 것입니다. 5d와 5e는 형식 3과 형식 4 모두에 대한 것입니다.

단계 #|플래그 값|명령 #|Opcode|해제 코드
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **RegI** <= 10|RegI / 2 + **RegI** % 2|`stp x19,x20,[sp,#savsz]!`<br/>`stp x21,x22,[sp,#16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**==01*|1|`str lr,[sp,#(intsz-8)]`\*|`save_reg`
3|0 < **RegF** <=7|(RegF + 1) / 2 +<br/>(RegF + 1) % 2)|`stp d8,d9,[sp,#intsz]`\*\*<br/>`stp d10,d11,[sp,#(intsz+16)]`<br/>`...`<br/>`str d(8+RegF),[sp,#(intsz+fpsz-8)]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** == 1|4|`stp x0,x1,[sp,#(intsz+fpsz)]`<br/>`stp x2,x3,[sp,#(intsz+fpsz+16)]`<br/>`stp x4,x5,[sp,#(intsz+fpsz+32)]`<br/>`stp x6,x7,[sp,#(intsz+fpsz+48)]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5a|**CR** == 11 && #locsz<br/> <= 512|2|`stp x29,lr,[sp,#-locsz]!`<br/>`mov x29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5b|**CR** == 11 &&<br/>512 < #locsz <= 4080|3|`sub sp,sp,#locsz`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5c|**CR** == 11 && #locsz > 4080|4|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5d|(**CR** == 00 \|\| **CR**==01) &&<br/>#locsz <= 4080|1|`sub sp,sp,#locsz`|`alloc_s`/`alloc_m`
5e|(**CR** == 00 \|\| **CR**==01) &&<br/>#locsz > 4080|2|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* **CR** == 01 및 **RegI**이 홀수인 경우 2단계 및 1단계의 마지막 save_rep은 하나의 save_regp에 병합됩니다.

\*\* **RegI** == **CR** == 0, 그리고 **RegF**! = 0인 경우 부동 소수점의 첫 번째 stp는 사전 감소를 수행합니다.

\*\*\* 에필로그에 `mov x29,sp`에 해당하는 명령이 없습니다. 함수에서 x29의 sp를 복원해야 하는 경우 압축된 해제 데이터를 사용할 수 없습니다.

### <a name="unwinding-partial-prologs-and-epilogs"></a>부분 프롤로그 및 에필로그 해제

가장 일반적인 해제 상황은 프롤로그 및 모든 에필로그 범위를 벗어난 함수 본문에서 예외 또는 호출이 발생하는 경우입니다. 이 경우 해제는 간단합니다. 해제기는 단순히 인덱스 0부터 시작하는 해제 배열의 코드 실행을 시작하고 opcode가 검색될 때까지 계속합니다.

프롤로그 또는 에필로그를 실행하는 동안 예외 또는 인터럽트가 발생하는 경우 올바르게 해제하기가 더 어렵습니다. 관련 상황에서는 스택 프레임이 일부만 생성됩니다. 문제는 올바르게 실행을 취소하기 위해 정확히 어떤 작업이 수행되었는지 판단하는 것입니다.

예를 들어 다음 프롤로그 및 에필로그 시퀀스를 사용합니다.

```asm
0000:    stp    x29,lr,[sp,#-256]!          // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,#224]             // save_fregp 0, 224
0008:    stp    x19,x20,[sp,#240]           // save_regp 0, 240
000c:    mov    x29,sp                      // set_fp
         ...
0100:    mov    sp,x29                      // set_fp
0104:    ldp    x19,x20,[sp,#240]           // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    x29,lr,[sp],#256            // save_fplr_x  256 (post-indexed load)
0110:    ret    lr                          // end
```

각 opcode 옆에는 이 작업을 설명하는 적절한 해제 코드가 있습니다. 프롤로그에 대한 일련의 해제 코드가 에필로그에 대한 해제 코드의 정확한 미러 이미지임을 알 수 있습니다(에필로그의 최종 명령은 계산에 포함되지 않음). 이는 일반적인 상황이며 프롤로그에 대한 해제 코드는 프롤로그의 실행 순서의 역순으로 저장된다고 항상 가정하는 이유입니다.

따라서 프롤로그 및 에필로그 모두에 대해 공통의 해제 코드 집합이 남게 됩니다.

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

에필로그의 경우는 일반적인 순서로 되어 있기 때문에 간단합니다. 에필로그 내의 오프셋 0에서 시작하여(함수의 offset 0x100에서 시작) 정리가 아직 수행되지 않았기 때문에 전체 해제 시퀀스 실행을 예상할 수 있습니다. 하나의 명령이 있는 경우(에필로그의 오프셋 2에서) 첫 번째 해제 코드를 건너뛰고 성공적으로 해제할 수 있습니다. 관련 상황을 일반화하고 opcode와 해제 코드 간의 1:1 매핑을 가정할 수 있습니다. 그런 다음 에필로그에서 명령 *n*의 해제를 시작하려면 첫 번째 *n* 해제 코드를 건너뛰고 거기서부터 실행을 시작해야 합니다.

역방향인 것을 제외하면 프롤로그에 대해서도 유사한 논리가 작동합니다. 프롤로그에서 오프셋 0부터 해제를 시작하는 경우 아무것도 실행하지 않으려고 합니다. 하나의 명령인 오프셋 2부터 해제하는 경우 끝부터 해제 시퀀스 하나의 해제 코드를 실행하려고 합니다. (코드는 역순으로 저장됨을 기억하세요.) 여기에서도 일반화를 할 수 있습니다. 프롤로그의 명령 n에서 해제를 시작할 경우 코드 목록 끝에서 n번째 해제 코드에서 해제 실행이 시작되어야 합니다.

프롤로그 및 에필로그 코드가 늘 정확하게 일치하는 것은 아닙니다. 그래서 해제 코드 배열은 여러 코드 시퀀스를 포함해야 할 수 있습니다. 코드 처리 시작 위치의 오프셋을 결정하려면 다음 논리를 사용합니다.

1. 함수 본문 내에서 해제하는 경우 인덱스 0에서 해제 코드 실행을 시작하고 “end” opcode에 도달할 때까지 계속합니다.

1. 에필로그 내에서 해제하는 경우 에필로그 범위에서 제공되는 에필로그별 시작 인덱스를 시작점으로 사용합니다. 에필로그 시작 위치에서 대상 PC까지의 거리(바이트 수)를 계산합니다. 그런 다음 해제 코드에서 정방향으로 진행하고 이미 실행된 모든 명령의 수만큼 해제 코드를 건너뜁니다. 그런 다음 해당 지점에서 시작을 실행합니다.

1. 프롤로그 내에서 해제하는 경우 인덱스 0을 시작점으로 사용합니다. 시퀀스에서 프롤로그 코드의 길이를 계산하고, 프롤로그 종료 위치에서 대상 PC까지의 거리(바이트 수)를 계산합니다. 그런 다음 해제 코드에서 정방향으로 진행하고, 아직 실행되지 않은 명령의 수만큼 해제 코드를 건너뜁니다. 그런 다음 해당 지점에서 시작을 실행합니다.

관련 규칙은 프롤로그의 해제 코드는 항상 배열의 첫 번째 코드여야 한다는 의미입니다. 그리고 본문 내에서 일반적인 해제 사례를 해제하는 데 사용되는 코드이기도 합니다. 에필로그별 코드 시퀀스는 바로 뒤에 와야 합니다.

### <a name="function-fragments"></a>함수 조각

코드 최적화의 목적 및 기타 이유로 인해 함수를 분리된 조각(영역이라고도 함)으로 분할하는 것이 더 적합할 수 있습니다. 분할된 결과로 생긴 각 함수 조각에는 고유한 별도의 .pdata 레코드(및 추가 .xdata 레코드)가 필요할 수 있습니다.

자체 프롤로그를 포함하는 분리된 각 보조 조각에 대해 해당 프롤로그에서 스택 조정이 수행되지 않아야 합니다. 보조 지역에 필요한 모든 스택 공간은 부모 지역(또는 호스트 영역)에 의해 미리 할당되어야 합니다. 그러면 모든 스택 포인터 조작이 함수의 원래 프롤로그에 엄격하게 유지됩니다.

함수 조각의 일반적인 사례에서는 해당 컴파일러가 포함된 “코드 분리”가 호스트 함수 밖으로 코드 영역을 옮길 수 있습니다. 코드 분리로 인해 발생하는 세 가지 일반적이지 않은 사례가 있습니다.

#### <a name="example"></a>예제

- (지역 1: 시작)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (지역 1: 끝)

- (지역 3: 시작)

    ```asm
        ...
    ```

- (지역 3: 끝)

- (지역 2: 시작)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (지역 2: 끝)

1. 프롤로그만(지역 1: 모든 에필로그는 분리된 지역에 있음):

   프롤로그만 설명해야 합니다. 압축 .pdata 형식으로 표현될 수 없습니다. 전체 .xdata 사례에서는 에필로그 Count = 0을 설정하여 나타낼 수 있습니다. 위의 예제에서 지역 1을 참조하세요.

   해제 코드: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. 에필로그만(지역 2: 프롤로그는 호스트 영역에 있음.)

   이 지역으로 이동하는 시간 제어 때문에 모든 프롤로그 코드가 실행된 것으로 가정합니다. 부분 해제는 일반 함수와 동일한 방식으로 에필로그에서 발생할 수 있습니다. 이 유형의 지역은 압축된 .pdata로 나타낼 수 없습니다. 전체 .xdata 레코드에서 `end_c` 및 `end` 해제 코드 쌍으로 대괄호로 묶은 “가상” 프롤로그를 사용하여 인코딩할 수 있습니다.  선행 `end_c`는 프롤로그의 크기가 0임을 나타냅니다. 단일 에필로그 지점의 에필로그 시작 인덱스는 `set_fp`를 가리킵니다.

   영역 2에 대한 해제 코드: `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. 프롤로그 또는 에필로그 없음(지역 3: 프롤로그 및 모든 에필로그는 다른 조각에 있음.):

   압축 .pdata 형식은 플래그 = 10 설정을 통해 적용할 수 있습니다. 전체 .xdata 레코드로는 에필로그 개수 = 1입니다. 해제 코드는 위의 지역 2에 대한 코드와 동일하지만 에필로그 시작 인덱스는 `end_c`도 가리킵니다. 부분 해제는 이 코드 영역에서 발생하지 않습니다.

함수 조각의 또 다른 복잡한 사례는 “축소 래핑”입니다. 컴파일러가 함수 항목 프롤로그의 외부에 있게 될 때까지 일부 호출 수신자 자정 레지스터의 저장을 연기하도록 선택할 수 있습니다.

- (지역 1: 시작)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (지역 2: 시작)

    ```asm
        stp     x21,x22,[sp,#224]       // save_regp 2, 224
        ...
        ldp     x21,x22,[sp,#224]       // save_regp 2, 224
    ```

- (지역 2: 끝)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (지역 1: 끝)

지역 1의 프롤로그에서 스택 공간은 미리 할당됩니다. 해당 호스트 함수 밖으로 이동하더라도 지역 2는 동일한 해제 코드를 사용할 수 있습니다.

지역 1: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, 에필로그 시작 인덱스를 포함한 `end`는 평소대로 `set_fp`를 가리킵니다.

지역 2: `save_regp 2, 224`, `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`. 에필로그 시작 인덱스는 첫 번째 해제 코드 `save_regp 2, 224`를 가리킵니다.

### <a name="large-functions"></a>큰 함수

조각을 사용하면 .xdata 헤더의 비트 필드에 의해 적용되는 1M 제한보다 큰 함수를 설명할 수 있습니다. 이처럼 매우 큰 함수를 설명하려면 1M보다 작은 조각으로 분할해야 합니다. 각 조각은 에필로그를 여러 부분으로 분할하지 않도록 조정해야 합니다.

함수의 첫 조각에만 프롤로그가 포함되며 나머지 모든 조각은 프롤로그가 없는 것으로 표시됩니다. 나타난 에필로그 수에 따라 각 조각은 에필로그를 포함하지 않을 수도 있고 포함할 수도 있습니다. 조각의 각 에필로그 범위는 함수 시작 위치가 아닌 조각 시작 위치를 기준으로 시작 오프셋을 지정합니다.

조각에 프롤로그와 에필로그가 없어도 함수 본문 내에서 해제할 방법을 설명하는 자체 .pdata가 필요하며 .xdata도 필요할 수 있습니다.

## <a name="examples"></a>예

### <a name="example-1-frame-chained-compact-form"></a>예제 1: 프레임 연결됨, 압축 형식

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>예제 2: 프레임 연결됨, 미러 프롤로그 및 에필로그가 포함된 전체 형식

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

에필로그 시작 인덱스 [0]은 프롤로그 해제 코드의 동일한 시퀀스를 가리킵니다.

### <a name="example-3-variadic-unchained-function"></a>예제 3: Variadic 비 연결 함수

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

에필로그 시작 인덱스 [4]는 프롤로그 해제 코드의 중간을 가리킵니다(해제 배열을 부분적으로 재사용).

## <a name="see-also"></a>참조

[ARM64 ABI 규칙 개요](arm64-windows-abi-conventions.md)<br/>
[ARM 예외 처리](arm-exception-handling.md)
