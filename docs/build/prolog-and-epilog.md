---
title: 프롤로그 및 에필로그 | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 9c2a1a9b1891af1c5616e78932cf4a530a300786
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/17/2018
ms.locfileid: "45718876"
---
# <a name="prolog-and-epilog"></a>프롤로그 및 에필로그

스택 공간을 할당 하는 모든 함수를 호출 함수, 비휘발성 레지스터를 저장 또는 예외 처리를 사용 하 여 다른 주소 제한 된 각 함수의 테이블 항목과 연결 된 해제 데이터에서 설명 하는 프롤로그 있어야 합니다 (참조 [(X64)를 처리 하는 예외](../build/exception-handling-x64.md)). 프롤로그 홈 주소에는 레지스터, 필요한 경우 비휘발성 레지스터를 스택에 푸시합니다 인수를 저장, 고정된 부분의 스택의 지역 및 임시 개체를 할당 및 필요에 따라 프레임 포인터를 설정 합니다. 연결 된 해제 데이터 프롤로그의 동작을 설명 하 고 prolog 코드의 효과 취소 하는 데 필요한 정보를 제공 해야 합니다.

스택에서 고정된 할당에 둘 이상의 페이지인 경우 (즉, 4096 바이트 보다 큰)에 스택 할당 둘 이상의 가상 메모리 페이지가 표시 될 수 있으며, 따라서 실제로 할당 하기 전에 할당을 확인 해야 합니다. 특별 한 루틴 프롤로그에서 호출할 수 있고 인수 레지스터 중 하나에 제거 하지 않습니다는이 목적을 위해 제공 됩니다.

비휘발성 레지스터를 저장 하기 위한 기본 메서드를 고정된 스택 할당 하기 전에 스택으로 이동 하는 것입니다. 저장 된 등록 영역 (나타내기 레지스터가 이동으로 빠른 속도 대 한 유지할지 고정된 스택 할당 수행한 비휘발성 레지스터를 저장 하기 전에 필요한 주소 수는 32 비트 치환 가능성이 가장 큰 경우 예측 가능한 미래 푸시 간에 암시적된 종속성도 불구 하 고). 비휘발성 레지스터 순서에 관계 없이 저장할 수 있습니다. 그러나 프롤로그에서 비휘발성 레지스터의 첫 번째 사용 저장 해야 합니다.

일반적인 프롤로그 코드는 다음과 같습니다.

```
mov       [RSP + 8], RCX
push   R15
push   R14
push   R13
sub      RSP, fixed-allocation-size
lea      R13, 128[RSP]
...
```

이 프롤로그 홈 위치에서 인수 RCX 레지스터를 저장, 저장 비휘발성 등록 R13-r 15 고정된 부분의 스택 프레임을 할당 하 고 고정된 할당 영역에 128 바이트를 가리키는 프레임 포인터를 설정 합니다. 오프셋을 사용 하면 고정된 할당 영역 1 바이트 오프셋을 사용 하 여 해결을 더 합니다.

고정된 할당 크기 보다 크거나 같은 메모리의 한 페이지로 이면 RSP 수정 하기 전에 도우미 함수를 호출 되어야 합니다. 이 도우미 __chkstk은 스택의 제대로 확장 되도록 스택 할당 하려는 범위를 검색 하는 일을 담당 합니다. 이 경우 앞의 프롤로그 예제 대신 다음과 같습니다.

```
mov       [RSP + 8], RCX
push   R15
push   R14
push   R13
mov      RAX,  fixed-allocation-size
call   __chkstk
sub      RSP, RAX
lea      R13, 128[RSP]
...
```

__Chkstk 도우미 R10, R11 및 조건 코드 레지스터를 수정 하지 않습니다. 특히 RAX 변경 되지 않은 상태로 반환 하 고 모든 비휘발성 레지스터와 수정 되지 않은 인수 전달 레지스터를 유지 합니다.

에필로그 코드는 모든 함수 종료 위치에 있습니다. 일반적으로 하나만 프롤로그 인 반면 많은 에필로그 있을 수 있습니다. 에필로그 코드 필요에 따라 고정된 할당 크기로 스택 트림, 고정된 스택 할당의 할당을 취소, 비휘발성 레지스터 스택에서 해당 저장된 값을 팝 하 여 복원 및 반환 합니다.

에필로그 코드에서 예외 및 인터럽트를 통해 안정적으로 해제 하려면 엄격한 해제 코드에 대 한 규칙 집합을 따라야 합니다. 이 줄어듭니다 추가 데이터가 없습니다. 각 에필로그를 설명 하기 위해 필요 하므로 필요한 데이터를 해제 합니다. 대신 해제 코드는 에필로그 에필로그를 식별 하는 코드 스트림을 통해 앞으로 검색 하 여 실행 될 것임을 확인할 수 있습니다.

프레임 포인터가 사용 되는 경우 함수를 다음 에필로그 먼저 할당을 취소 해야 고정된 부분의 스택의 비휘발성 레지스터를 팝 및 컨트롤이 호출 함수로 반환 됩니다. 예를 들어 개체에 적용된

```
add      RSP, fixed-allocation-size
pop      R13
pop      R14
pop      R15
ret
```

프레임 포인터를 함수에서 사용 하는 경우 스택 에필로그의을 실행 하기 전에 고정된 할당으로 트리밍 해야 합니다. 이것이 기술적의 일부가 아닌 에필로그입니다. 예를 들어, 이전에 사용 하는 프롤로그를 실행 취소 하려면 다음 에필로그를 사용할 수 있습니다.

```
lea      RSP, -128[R13]
; epilogue proper starts here
add      RSP, fixed-allocation-size
pop      R13
pop      R14
pop      R15
ret
```

실제로 프레임 포인터를 사용 하면 없습니다 좋은 이유는 다음 에필로그를 대신 사용할 수는 두 단계로 RSP를 조정 하려면:

```
lea      RSP, fixed-allocation-size - 128[R13]
pop      R13
pop      R14
pop      R15
ret
```

이들은 에필로그에 올바른 폼입니다. 구성 되어야 합니다는 `add RSP,constant` 또는 `lea RSP,constant[FPReg]`뒤에 일련의 0 개 이상의 8 비트 레지스터를 팝 하 고 반환 또는 jmp, 합니다. (Jmp 문의 하위 집합만 에필로그에 허용 되는입니다. 이들은 jmps ModRM 메모리 참조를 사용 하 여 클래스의 단독으로 여기서 ModRM mod 필드 값 00입니다. 01 또는 10 ModRM mod 필드 값을 사용 하 여 에필로그에 jmps 사용은 금지 됩니다. 참조 테이블 A-15 AMD 64 x86 아키텍처 프로그래머 설명서 볼륨 3에서: 범용 및 시스템 지침에 허용 가능한 ModRM 참조에 대 한 자세한 정보.). 다른 코드가 없어야 나타날 수 있습니다. 특히, 아무 것도 반환 값을 로드 하는 등 에필로그 내에서 예약할 수 있습니다.

에서 프레임 포인터를 사용 하지 않으면 하는 경우 에필로그를 사용 해야 `add RSP,constant` 고정된 부분의 스택 할당을 취소 합니다. 사용할 수 없습니다 `lea RSP,constant[RSP]` 대신 합니다. 이 제한이 없으므로 해제 코드는 에필로그를 검색할 때 인식 하는 더 적은 패턴에 있습니다.

다음 규칙 해제 코드를 에필로그는 현재 실행 되 고 있음을 확인 하 고 실행 호출 함수의 컨텍스트를 다시 만들 수 있도록 에필로그의 나머지 부분을 시뮬레이션할 수 있습니다.

## <a name="see-also"></a>참고 항목

[x64 소프트웨어 규칙](../build/x64-software-conventions.md)