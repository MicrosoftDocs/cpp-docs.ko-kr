---
title: 프롤로그 및 에필로그 | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 2939293fe5fbdfd07cb12470790de5b064489d7f
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/03/2018
ms.locfileid: "32372011"
---
# <a name="prolog-and-epilog"></a>프롤로그 및 에필로그
스택 공간이 할당 되는 모든 함수, 호출 함수 다른 비휘발성 레지스터를 저장 하거나 예외 처리를 사용 하 여 해당 주소 한계 각 함수의 테이블 항목에 연결 된 해제 데이터에서 설명 하는 프롤로그 있어야 합니다 ( 참조[예외 처리 (x64)](../build/exception-handling-x64.md)). 프롤로그 집 주소에는 레지스터, 필요한 경우 비휘발성 레지스터를 스택에 푸시합니다. 인수를 저장, 지역 및, 임시 개체에 대 한 스택 고정된 부분을 할당 및 필요에 따라 프레임 포인터를 설정 합니다. 연결 된 해제 데이터 프롤로그의 동작을 설명 하 고 프롤로그 코드의 효과 취소 하는 데 필요한 정보를 제공 해야 합니다.  
  
 스택에서 고정된 할당에 둘 이상의 페이지인 경우 (즉, 4, 096 바이트 보다 큰), 것이 스택 할당 둘 이상의 가상 메모리 페이지 표시 될 수 있으며, 따라서 실제로 할당 되기 전에 할당을 확인 해야 합니다. 특별 한 루틴 프롤로그에서 호출할 수 이며 인수 레지스터 중 하나에 제거 하지 않습니다는이 목적을 위해 제공 됩니다.  
  
 비휘발성 레지스터를 저장 하기 위한 고정된 스택 할당 하기 전에 스택으로 이동 하는 것이 좋습니다. 저장 된 등록 (나타내기 레지스터가 빠릅니다로 이동 하 고 영역 해야을 유지할 가능성이 가장 큰 32 비트 치환 주소로 필요한 경우가 고정된 스택 할당은 비휘발성 레지스터를 저장 하기 전에 수행 된 경우 예측 가능한 미래 푸시 간의 암시적된 종속성에 관계 없이). 순서에 관계 없이 비휘발성 레지스터를 저장할 수 있습니다. 그러나 프롤로그에서 비휘발성 레지스터의 첫 번째 사용은 저장 되어야 합니다.  
  
 일반적인 프롤로그에 대 한 코드는 다음과 같습니다.  
  
```  
mov       [RSP + 8], RCX  
push   R15  
push   R14  
push   R13  
sub      RSP, fixed-allocation-size  
lea      R13, 128[RSP]  
...  
```  
  
 이 프롤로그 홈 해당 위치 RCX 인수 레지스터 저장, 저장 비휘발성 등록 R13 R15 스택 프레임의 고정된 부분을 할당 하 고 고정된 할당 영역으로 128 바이트를 가리키는 프레임 포인터를 설정 합니다. 오프셋을 사용 하 여 추가 고정된 할당 영역을 1 바이트 오프셋으로 처리할 수 있습니다.  
  
 고정된 할당 크기의 메모리 페이지 보다 크거나 이면 RSP 수정 하기 전에 도우미 함수를 호출 되어야 합니다. __Chkstk이이 도우미는 스택 할당 하려는 범위를 스택의 제대로 확장을 검색 합니다. 이 경우 이전 프롤로그 예제 대신 합니다.  
  
```  
mov       [RSP + 8], RCX  
push   R15  
push   R14  
push   R13  
mov      RAX,  fixed-allocation-size  
call   __chkstk  
sub      RSP, RAX  
lea      R13, 128[RSP]  
...  
```  
  
 __Chkstk 도우미 r 10, R11 및 조건 코드 레지스터를 수정 하지 않습니다. 특히, RAX 변경 하지 않고 반환 되며 모든 비휘발성 레지스터와 인수 전달 레지스터 수정 되지 않은 상태로 둡니다.  
  
 에필로그 코드는 함수에 모든 종료에 있습니다. 일반적으로 하나의 프롤로그 하는 반면 많은 에필로그 있을 수 있습니다. 에필로그 코드 스택 고정된 할당 크기를 줄일 때 (필요한 경우), 고정된 스택 할당의 할당을 취소, 비휘발성 레지스터의 저장 된 값은 스택에서 팝 하 여 복원 하 고 반환 합니다.  
  
 에필로그 코드에서 예외 및 인터럽트를 통해 안정적으로 해제를 엄격한 집합 해제 코드에 대 한 규칙을 따라야 합니다. 그러면 감소의 각 에필로그를 설명 하기 위해 추가 데이터가 필요 하므로 해제 데이터입니다. 대신, 해제 코드는 에필로그에서는 에필로그를 식별 하는 코드 스트림을 통해 앞으로 검색 하 여 실행 되 고 있음을 확인할 수 있습니다.  
  
 없는 프레임 포인터를 사용 하는 경우 함수를 다음 에필로그 먼저 할당을 취소 해야는 스택의 고정된 부분 비휘발성 레지스터를 팝 및 제어 호출 하는 함수에 반환 됩니다. 예를 들어 개체에 적용된  
  
```  
add      RSP, fixed-allocation-size  
pop      R13  
pop      R14  
pop      R15  
ret  
```  
  
 프레임 포인터가 함수에 사용 되는 스택 에필로그를 실행 하기 전에 고정된 할당으로 트리밍 해야 합니다. 기술적으로의 일부가 아닌 에필로그입니다. 예를 들어 이전에 사용한 프롤로그를 실행 취소 하려면 다음 에필로그를 사용할 수 있습니다.  
  
```  
lea      RSP, -128[R13]  
; epilogue proper starts here  
add      RSP, fixed-allocation-size  
pop      R13  
pop      R14  
pop      R15  
ret  
```  
  
 실제로 프레임 포인터를 사용 하면 있습니다를 두 단계로 RSP 조정 다음 에필로그를 대신 사용 합니다.  
  
```  
lea      RSP, fixed-allocation-size - 128[R13]  
pop      R13  
pop      R14  
pop      R15  
ret  
```  
  
 이들은 에필로그에 대 한 올바른 폼입니다. 구성 되어야 합니다는 `add RSP,constant` 또는 `lea RSP,constant[FPReg]`일련의 8 바이트 레지스터를 0 개 이상의 팝 하 고 반환 또는 jmp 이어집니다. (Jmp 문의 하위 집합만 에필로그에 허용 되는 있습니다. 이들은 ModRM 메모리 참조와 jmps 클래스의 기호 위치 ModRM mod 필드 값 00입니다. ModRM mod 필드 값 01 또는 10 인 에필로그에 jmps의 사용은 금지 됩니다. 참조 테이블 A-15 AMD x86-64 아키텍처 프로그래머용 설명서 볼륨 3에서: 일반 용도 허용 가능한 ModRM 참조에 대 한 자세한 정보에 대 한 시스템 지침.). 다른 코드가 나타날 수 있습니다. 특히, 반환 값을 로드 하는 등 에필로그 내에서 아무를 예약할 수 있습니다.  
  
 프레임 포인터를 사용 하지 않는 경우 에필로그를 사용 해야 `add RSP,constant` 고정된 부분의 스택 할당을 취소할 수 있습니다. 사용할 수 없습니다 `lea RSP,constant[RSP]` 대신 합니다. 이 제한 되므로 해제 코드는 에필로그를 검색할 때 인식 하는 데 더 적은 패턴 존재 합니다.  
  
 이러한 규칙에 따라 에필로그 현재 실행 되 고 있음을 확인 하 고 호출 함수의 컨텍스트를 다시 만들 수 있도록 에필로그의 나머지 부분에서는의 실행을 시뮬레이션 하는 해제 코드를 수 있습니다.  
  
## <a name="see-also"></a>참고 항목  
 [x64 소프트웨어 규칙](../build/x64-software-conventions.md)