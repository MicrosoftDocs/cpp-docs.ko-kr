---
title: x64 프롤로그 및 에필로그
ms.date: 12/17/2018
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: d0b7444af6e434a09f6af5f5b1c144b46c79ad56
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328440"
---
# <a name="x64-prolog-and-epilog"></a>x64 프롤로그 및 에필로그

스택 공간을 할당하거나, 다른 함수를 호출하거나, 비휘발성 레지스터를 저장하거나, 예외 처리를 사용하는 모든 함수에는 해당 함수 테이블 항목과 연결된 해제 데이터에 주소 제한이 설명되어 있는 프롤로그가 있어야 합니다. 자세한 내용은 [x64 예외 처리를](../build/exception-handling-x64.md)참조하십시오. 프롤로그는 필요한 경우 집 주소에 인수 레지스터를 저장하고, 스택에서 비휘발성 레지스터를 푸시하고, 로컬 및 임시 위치에 스택의 고정된 부분을 할당하고, 선택적으로 프레임 포인터를 설정합니다. 연결된 해제 데이터는 프롤로그의 동작을 설명해야 하며 프롤로그 코드의 효과를 실행 취소하는 데 필요한 정보를 제공해야 합니다.

스택의 고정 할당이 두 페이지(즉, 4096바이트보다 큰)인 경우 스택 할당이 두 개 이상의 가상 메모리 페이지에 걸쳐 있을 수 있으므로 할당을 할당하기 전에 확인해야 합니다. 프롤로그에서 호출할 수 있고 인수 레지스터를 삭제하지 않는 특수 루틴이 이 목적을 위해 제공됩니다.

비휘발성 레지스터를 저장하는 데 선호되는 방법은 고정 스택 할당 전에 스택으로 이동하는 것입니다. 비휘발성 레지스터가 저장되기 전에 고정 스택 할당이 수행되는 경우 저장된 레지스터 영역을 처리하려면 32비트 변위가 필요할 수 있습니다. (소문에 따르면, 레지스터의 푸시는 이동만큼 빠르며 푸시 사이의 내재된 종속성에도 불구하고 당분간 은밀하게 유지되어야 합니다.) 비휘발성 레지스터는 임의의 순서로 저장할 수 있습니다. 그러나 프롤로그에서 비휘발성 레지스터를 처음 사용하는 것은 저장해야 합니다.

## <a name="prolog-code"></a>프롤로그 코드

일반적인 프롤로그에 대한 코드는 다음과 같은 것일 수 있습니다.

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, fixed-allocation-size
    lea    R13, 128[RSP]
    ...
```

이 프롤로그는 인수 레지스터 RCX를 홈 위치에 저장하고, 비휘발성 레지스터 R13-R15를 저장하고, 스택 프레임의 고정 된 부분을 할당하고, 고정 할당 영역에 128 바이트를 가리키는 프레임 포인터를 설정합니다. 오프셋을 사용하면 1바이트 오프셋으로 더 많은 고정 할당 영역을 해결할 수 있습니다.

고정 할당 크기가 메모리의 한 페이지보다 크거나 같으면 RSP를 수정하기 전에 도우미 함수를 호출해야 합니다. 이 도우미는 `__chkstk`할당할 스택 범위를 프로브하여 스택이 제대로 확장되었는지 확인합니다. 이 경우 이전 프롤로그 예제는 다음과 같은 것입니다.

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    mov    RAX,  fixed-allocation-size
    call   __chkstk
    sub    RSP, RAX
    lea    R13, 128[RSP]
    ...
```

도우미는 `__chkstk` R10, R11 및 조건 코드 이외의 레지스터를 수정하지 않습니다. 특히 RAX를 변경하지 않고 반환하고 모든 비휘발성 레지스터및 인수 전달 레지스터를 수정하지 않은 상태로 둡니다.

## <a name="epilog-code"></a>에필로그 코드

에필로그 코드는 함수의 각 엑시트에 존재합니다. 일반적으로 프롤로그가 하나뿐인 반면, 많은 에필로그가 있을 수 있습니다. 에필로그 코드는 스택을 고정 할당 크기(필요한 경우)로 트리밍하고, 고정 스택 할당을 할당하고, 스택에서 저장된 값을 터뜨려 비휘발성 레지스터를 복원하고 반환합니다.

에필로그 코드는 예외 및 인터럽트를 통해 안정적으로 해제할 수 있도록 해제 코드에 대한 엄격한 규칙 집합을 따라야 합니다. 이러한 규칙은 각 에필로그를 설명하는 데 추가 데이터가 필요하지 않으므로 필요한 해제 데이터의 양을 줄입니다. 대신 해제 코드는 코드 스트림을 통해 앞으로 스캔하여 에필로그를 식별하여 에필로그가 실행되는지 확인할 수 있습니다.

함수에 프레임 포인터가 사용되지 않으면 에필로그가 먼저 스택의 고정된 부분을 할당 할당 지정해야 하며 비휘발성 레지스터가 튀어 나와 컨트롤이 호출 함수로 반환됩니다. 예를 들면 다음과 같습니다.

```MASM
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

프레임 포인터가 함수에 사용되는 경우 스택은 에필로그 실행 전에 고정 할당으로 트리밍되어야 합니다. 이 작업은 기술적으로 에필로그의 일부가 아닙니다. 예를 들어, 다음 에필로그를 사용하여 이전에 사용한 프롤로그를 취소할 수 있습니다.

```MASM
    lea      RSP, -128[R13]
    ; epilogue proper starts here
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

실제로 프레임 포인터를 사용할 때 두 단계로 RSP를 조정할 이유가 없으므로 다음 에필로그가 대신 사용됩니다.

```MASM
    lea      RSP, fixed-allocation-size - 128[R13]
    pop      R13
    pop      R14
    pop      R15
    ret
```

이러한 양식은 에필로그에 대한 유일한 법적 것입니다. `add RSP,constant` 또는 `lea RSP,constant[FPReg]`또는 , 다음에 0 또는 그 이상의 8바이트 레지스터 팝 과 `return` 또는 `jmp`a의 시리즈로 구성되어야 합니다. (에필로그에서 `jmp` 명령문의 하위 집합만 허용됩니다. 하위 집합은 ModRM 모드 `jmp` 필드 값이 00인 ModRM 메모리 참조가 있는 명령문의 클래스입니다. ModRM `jmp` 모드 필드 값 01 또는 10이 있는 에필로그에서 문을 사용하는 것은 금지됩니다. 허용되는 ModRM 참조에 대한 자세한 내용은 AMD x86-64 아키텍처 프로그래머의 수동 볼륨 3: 범용 및 시스템 지침표A-15를 참조하십시오. 다른 코드는 표시할 수 없습니다. 특히 반환 값 로드를 포함하여 에필로그 내에서 예약할 수 있는 것은 없습니다.

프레임 포인터를 사용하지 않는 경우 에필로그는 스택의 고정된 부분을 할당 하는 데 사용 `add RSP,constant` 해야 합니다. 대신 사용하지 `lea RSP,constant[RSP]` 않을 수 있습니다. 이 제한은 해제 코드가 에필로그를 검색할 때 인식할 수 있는 패턴이 적도록 합니다.

이러한 규칙에 따라 해제 코드에서 에필로그가 현재 실행 되고 있는지 확인하고 호출 함수의 컨텍스트를 다시 만들 수 있도록 에필로그의 나머지 실행을 시뮬레이션할 수 있습니다.

## <a name="see-also"></a>참고 항목

[x64 소프트웨어 규칙](x64-software-conventions.md)
