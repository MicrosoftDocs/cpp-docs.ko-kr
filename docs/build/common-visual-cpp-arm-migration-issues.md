---
title: 일반적인 Visual C++ ARM 마이그레이션 문제
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 518b8872b301a8fcfc0f154cb3d5d0299efb0975
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303221"
---
# <a name="common-visual-c-arm-migration-issues"></a>일반적인 Visual C++ ARM 마이그레이션 문제

Microsoft C++ 컴파일러 (MSVC)를 사용 하는 경우 동일한 C++ 소스 코드에서 x86 또는 x64 아키텍처에서 수행 하는 것 보다 ARM 아키텍처에 대해 다른 결과를 생성할 수 있습니다.

## <a name="sources-of-migration-issues"></a>마이그레이션 문제의 원인

X86 또는 x64 아키텍처에서 ARM 아키텍처로 코드를 마이그레이션하는 경우 발생할 수 있는 많은 문제는 undefined, 구현 정의 또는 지정 되지 않은 동작을 호출할 수 있는 소스 코드 구문과 관련이 있습니다.

*정의* 되지 않은 동작은 표준에서 C++ 정의 하지 않는 동작입니다. 예를 들어, 부동 소수점 값을 부호 없는 정수로 변환 하거나, 음수 이거나 해당 형식의 비트 수를 초과 하는 위치 수로 값을 이동 하는 등의 작업으로 인해 발생 합니다.

*구현에 정의 된 동작은* 표준에서 C++ 컴파일러 공급 업체가 정의 하 고 문서화 하는 데 필요한 동작입니다. 프로그램에서 구현에 정의 된 동작을 안전 하 게 사용할 수 있지만이를 이식 하지 못할 수도 있습니다. 구현 정의 동작의 예로는 기본 제공 데이터 형식의 크기와 해당 맞춤 요구 사항이 있습니다. 구현 정의 동작의 영향을 받을 수 있는 작업의 예로는 가변 인수 목록에 액세스할 수 있습니다.

*지정 되지 않은 동작은* C++ 표준이 의도적으로 불명확 하 게 유지 하는 동작입니다. 이 동작은 비 결정적인 것으로 간주 되지만 지정 되지 않은 동작의 특정 호출은 컴파일러 구현에 의해 결정 됩니다. 그러나 컴파일러 공급 업체에서 결과를 predetermine 하 고 비교 가능한 호출 간에 일관 된 동작을 보장 하는 것은 아니지만 설명서에 대 한 요구 사항은 없습니다. 지정 되지 않은 동작의 예는 함수 호출에 대 한 인수를 포함 하는 하위 식이 계산 되는 순서입니다.

다른 마이그레이션 문제는 ARM과 x86 간의 하드웨어 차이 또는 C++ 표준과 상호 작용 하는 x64 아키텍처에 따라 달라질 수 있습니다. 예를 들어, x86 및 x64 아키텍처의 강력한 메모리 모델은 이전에 특정 종류의 스레드 간 통신을 용이 하 게 하는 데 사용 되는 일부 추가 속성을 `volatile`정규화 된 변수에 제공 합니다. 그러나 ARM 아키텍처의 weak memory 모델은이 사용을 지원 하지 않으며 표준에 C++ 도 필요 하지 않습니다.

> [!IMPORTANT]
>  X86 및 x 64에서 제한 된 형태의 스레드 간 통신을 구현 하는 데 사용할 수 있는 일부 속성을 `volatile` 수 있지만 이러한 추가 속성은 일반적으로 스레드 간 통신을 구현 하기에 충분 하지 않습니다. 표준 C++ 에서는 적절 한 동기화 기본 형식을 대신 사용 하 여 이러한 통신을 구현 하는 것이 좋습니다.

여러 플랫폼에서 이러한 종류의 동작을 다르게 표현할 수 있으므로 플랫폼 간에 소프트웨어를 이식 하는 것은 특정 플랫폼의 동작에 따라 달라 지는 경우 어려울 수 있으며 버그가 발생할 수 있습니다. 이러한 종류의 동작을 관찰할 수 있으며 안정적으로 표시 될 수 있지만, 이러한 동작에 의존 하는 것은 최소한 이식할 수 없고, 정의 되지 않거나 지정 되지 않은 동작의 경우에도 오류가 발생 합니다. 이 문서에 명시 된 동작은에 의존해 서는 안 되며, 이후 컴파일러 또는 CPU 구현에서 변경 될 수 있습니다.

## <a name="example-migration-issues"></a>마이그레이션 문제 예

이 문서의 나머지 부분에서는 이러한 C++ 언어 요소의 다른 동작이 다른 플랫폼에서 다른 결과를 생성 하는 방법에 대해 설명 합니다.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>부동 소수점에서 부호 없는 정수로 변환

ARM 아키텍처에서 부동 소수점 값이 정수에서 표현할 수 있는 범위 밖에 있는 경우 부동 소수점 값을 32 비트 정수로 변환 하는 것이 정수에서 표현할 수 있는 가장 가까운 값으로 saturates. X86 및 x64 아키텍처에서 변환은 정수가 부호 없는 경우에 대해 래핑됩니다. 정수가 서명 된 경우에는-2147483648로 설정 됩니다. 이러한 아키텍처는 부동 소수점 값을 더 작은 정수 형식으로 변환 하는 것을 직접 지원 하지 않습니다. 대신 32 비트로 변환이 수행 되며 결과가 더 작은 크기로 잘립니다.

ARM 아키텍처의 경우 채도와 잘림 조합은 부호 없는 형식으로의 변환이 32 비트 정수 saturates 경우 더 작은 부호 없는 형식으로 올바르게 saturates, 보다 큰 값에 대해서는 잘린 결과가 생성 됨을 의미 합니다. 더 작은 형식은 나타낼 수 있지만 너무 작아 전체 32 비트 정수를 포화 상태로 만들 수 있습니다. 변환도 32 비트 부호 있는 정수에 대해 올바르게 saturates, 포화 된 정수의 잘림에 대 한 결과는-1에서 양수 값이 고, 음수 값은 0입니다. 부호 있는 작은 정수로 변환 하면 예기치 않은 결과를 초래 하는 잘린 결과가 생성 됩니다.

X86 및 x64 아키텍처의 경우, 부호 없는 정수 변환과 오버플로 시 부호 있는 정수 변환에 대 한 명확 하 게 구분 되는 래핑 동작의 조합은 잘림와 함께 너무 깁니다.

이러한 플랫폼은 NaN (숫자가 아님)의 변환을 정수 형식으로 처리 하는 방법에 따라서도 다릅니다. ARM에서 NaN은 0x00000000으로 변환 됩니다. x86 및 x 64에서는 0x80000000로 변환 됩니다.

부동 소수점 변환은 값이 변환 되는 정수 형식의 범위 내에 있는 경우에만 사용할 수 있습니다.

### <a name="shift-operator---behavior"></a>시프트 연산자 (\<\< > >) 동작

ARM 아키텍처에서 값을 왼쪽 이나 오른쪽 255으로 이동 하 여 패턴을 반복 하기 시작할 수 있습니다. X86 및 x64 아키텍처에서는 패턴의 소스가 64 비트 변수가 아니면 32의 모든 배수로 패턴이 반복 됩니다. 이 경우 패턴은 x 64에서 64의 모든 배수로 반복 되며, x 86에서 256의 모든 배수로 소프트웨어 구현이 사용 됩니다. 예를 들어 값이 1 인 32 비트 변수를 32 위치로 왼쪽으로 이동한 경우 ARM의 경우 결과는 0이 고, x 86의 경우 결과는 1이 고, x 64 이면 결과는 1입니다. 그러나 값의 소스가 64 비트 변수인 경우 세 플랫폼 모두에 대 한 결과는 4294967296이 고 값은 x 64에서 64 위치를 이동할 때까지 "래핑" 하지 않으며 ARM 및 x 64에서 256 위치를 반환 합니다.

원본 형식의 비트 수를 초과 하는 시프트 연산의 결과는 정의 되어 있지 않기 때문에 컴파일러는 모든 상황에서 일관 된 동작을 가질 필요가 없습니다. 예를 들어, 컴파일 타임에 시프트의 두 피연산자를 모두 알 수 있는 경우 컴파일러는 내부 루틴을 사용 하 여 시프트 결과를 미리 계산 하 고 결과를 교대 작업 대신 대체 하 여 프로그램을 최적화할 수 있습니다. 시프트 금액이 너무 크거나 음수 이면 내부 루틴의 결과가 CPU에 의해 실행 된 것과 동일한 시프트 식의 결과와 다를 수 있습니다.

### <a name="variable-arguments-varargs-behavior"></a>가변 인수 (varargs) 동작

ARM 아키텍처에서 스택에 전달 되는 변수 인수 목록에 있는 매개 변수는 맞춤이 적용 됩니다. 예를 들어 64 비트 매개 변수는 64 비트 경계에 정렬 됩니다. X86 및 x 64에서 스택에 전달 되는 인수에는 맞춤 및 팩이 적용 되지 않습니다. 이러한 차이로 인해 `printf`와 같은 variadic 함수가 x86 또는 x64 아키텍처에서 일부 값의 하위 집합에 대해 작동 하는 경우에도 변수 인수 목록의 예상 레이아웃이 정확히 일치 하지 않는 경우 ARM에서 안쪽 여백으로 사용 된 메모리 주소를 읽을 수 있습니다. 다음 예제를 고려해 보세요.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

이 경우 인수의 맞춤을 고려 하도록 올바른 형식 지정을 사용 하 여 버그를 수정할 수 있습니다. 이 코드는 올바릅니다.

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>인수 평가 순서

ARM, x86 및 x64 프로세서는 서로 다르기 때문에 컴파일러 구현에 대 한 다른 요구 사항과 최적화를 위한 다른 기회를 제공할 수 있습니다. 이로 인해 호출 규칙 및 최적화 설정과 같은 다른 요소와 함께 컴파일러는 다른 아키텍처에서 또는 다른 요인이 변경 될 때 함수 인수를 다른 순서로 평가할 수 있습니다. 이로 인해 특정 평가 순서에 의존 하는 앱의 동작이 예기치 않게 변경 될 수 있습니다.

이러한 종류의 오류는 함수에 대 한 인수가 동일한 호출에서 함수에 대 한 다른 인수에 영향을 주는 부작용이 있는 경우에 발생할 수 있습니다. 일반적으로 이러한 종류의 종속성은 쉽게 방지할 수 있지만, 파악 하기 어려운 종속성 이나 연산자 오버 로드에 의해 가려질 수 있습니다. 이 코드 예제를 살펴보겠습니다.

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

이는 잘 정의 된 것으로 나타나지만 `->` 및 `*` 오버 로드 된 연산자 인 경우이 코드는 다음과 유사한 항목으로 변환 됩니다.

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

`operator->(memory_handle)`와 `operator*(p)`사이에 종속성이 있는 경우에는 코드에서 원본 코드가 가능한 종속성이 없는 것 처럼 보일 수 있지만 특정 계산 순서를 사용 하는 것이 좋습니다.

### <a name="volatile-keyword-default-behavior"></a>volatile 키워드 기본 동작

MSVC 컴파일러는 컴파일러 스위치를 사용 하 여 지정할 수 있는 `volatile` 저장소 한정자의 두 가지 해석을 지원 합니다. [/Volatile: ms](reference/volatile-volatile-keyword-interpretation.md) 스위치는 이러한 아키텍처에 대 한 강력한 메모리 모델로 인해 x86 및 x 64에 대 한 일반적인 경우 처럼 강력한 순서를 보장 하는 Microsoft 확장 된 volatile 의미 체계를 선택 합니다. [/Volatile: iso](reference/volatile-volatile-keyword-interpretation.md) 스위치는 강력한 정렬을 보장 C++ 하지 않는 엄격한 표준 휘발성 의미 체계를 선택 합니다.

Arm 아키텍처에서 기본값은 **/volatile: iso** 로, arm 프로세서에는 약하게 정렬 된 메모리 모델이 있고 arm 소프트웨어에는 **/volatile: ms** 의 확장 된 의미 체계에 의존 하는 레거시가 없으므로 일반적으로 사용 되는 소프트웨어와의 인터페이스를 사용할 필요가 없기 때문입니다. 그러나 확장 된 의미 체계를 사용 하기 위해 ARM 프로그램을 컴파일하는 경우에도 계속 해 서 편리 하거나 필요한 경우도 있습니다. 예를 들어 ISO C++ 의미 체계를 사용 하기 위해 프로그램을 이식 하는 데 비용이 많이 들 수 있거나 드라이버 소프트웨어가 기존 의미 체계를 준수 하 여 제대로 작동 해야 할 수 있습니다. 이 경우 **/volatile: ms** 스위치를 사용할 수 있습니다. 그러나 ARM 대상에 기존의 volatile 의미 체계를 다시 만들기 위해 컴파일러는 `volatile` 변수의 각 읽기 또는 쓰기에 대 한 메모리 장벽을 삽입 하 여 강력한 순서를 적용 해야 합니다. 이렇게 하면 성능에 부정적인 영향을 미칠 수 있습니다.

X86 및 x64 아키텍처에서, MSVC를 사용 하 여 이러한 아키텍처에 대해 이미 생성 된 대부분의 소프트웨어는 **/volatile: ms** 입니다. X86 및 x64 프로그램을 컴파일할 때 **/volatile: iso** 스위치를 지정 하 여 기존의 휘발성 의미 체계에 불필요 한 의존을 방지 하 고 이식성을 높일 수 있습니다.

## <a name="see-also"></a>참고 항목

[ARM 프로세서에 대한 Visual C++ 구성](configuring-programs-for-arm-processors-visual-cpp.md)
