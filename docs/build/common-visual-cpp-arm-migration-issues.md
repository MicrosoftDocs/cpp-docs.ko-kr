---
title: 일반적인 Visual C++ ARM 마이그레이션 문제
ms.date: 11/04/2016
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: a39e1d5e26a62cafa093067bb42f33178a1af6af
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/14/2019
ms.locfileid: "57816258"
---
# <a name="common-visual-c-arm-migration-issues"></a>일반적인 Visual C++ ARM 마이그레이션 문제

Microsoft Visual c + + (MSVC)를 사용 하는 경우 x86 또는 x64 아키텍처에서 사용 하지 않고 동일한 c + + 소스 코드를 ARM 아키텍처에 다른 결과 생성할 수 있습니다.

## <a name="sources-of-migration-issues"></a>마이그레이션 문제의 소스

ARM 아키텍처에는 x86 또는 x64 아키텍처에서 코드를 마이그레이션하는 경우 발생할 수 있는 다양 한 문제는 정의 되지 않은, 구현 시 정의 또는 지정 되지 않은 동작을 호출할 수 있는 소스 코드 구문을 관련이 있습니다.

*정의 되지 않은 동작이* c + + 표준을 정의 하지 않는 동작은 및 적절 한 결과가 있는 작업으로 인: 예를 들어, 부동 소수점 값을 부호 없는 정수로 변환 또는 값의 위치 번호로 이동 음수 또는 승격 된 해당 형식에는 비트 수를 초과 합니다.

*구현 정의 동작* 동작은 c + + 표준 컴파일러 공급 업체 정의 및 문서화 해야 합니다. 프로그램을 수행 하므로 아닐 이식 가능한 경우에에 안전 하 게 구현 시 정의 된 동작에 사용할 수 있습니다. 구현 정의 동작의 예로 기본 제공 데이터 형식 및 맞춤 요구 사항의 크기입니다. 구현 시 정의 된 동작에 의해 영향을 받을 수 있는 작업의 예로 가변 인수 목록에 액세스 합니다.

*동작을 지정 하지 않으면* 동작은 c + + 표준 의도적으로 명확 하지 않은 상태로 유지 합니다. 동작은 비 결정적인 것으로 간주 됩니다, 하지만 지정 되지 않은 동작의 특정 호출 컴파일러 구현에 의해 결정 됩니다. 그러나 결과 미리 결정할 비교할 수 있는 호출 간에 일관 된 동작을 보장 하는 컴파일러 공급 업체에 대 한 요구 사항은 없습니다 및 설명서에 대 한 요구 사항은 없습니다. 알 수 없는 동작의 예는 함수 호출에 인수를 포함 하는 하위 식에서 계산 되는 순서.

ARM와 다르게 표준 c + +를 사용 하 여 상호 작용 하는 x86 또는 x64 아키텍처 간의 하드웨어 차이 다른 마이그레이션 문제 때문일 수 있습니다. 예를 들어, x86 및 x64 아키텍처의 강력한 메모리 내 모델에서는 `volatile`-특정 종류의 지난에서 스레드 간 통신을 용이 하 게 사용 된 몇 가지 추가 속성 변수를 정규화 합니다. 하지만 ARM 아키텍처의 취약 한 메모리 내 모델을이 사용을 지원 하지 않습니다 또는 c + + 표준 필요가 것입니다.

> [!IMPORTANT]
>  하지만 `volatile` x86 및 x64에서 이러한 추가 속성에서 제한 된 형태의 스레드 간 통신을 구현 하는 데 사용할 수 있는 일부 속성은 구현 하기에 충분 하지 향상 스레드 간 통신에 일반적입니다. C + + 표준은 적절 한 동기화 기본형을 대신 사용 하 여 이러한 통신 구현 되어야 하는 것이 좋습니다.

다양 한 플랫폼 이러한 유형의 동작을 다르게 express 수 있으므로 소프트웨어 플랫폼 간에 이식 어렵고 버그 발생 하기 쉬운 경우 특정 플랫폼의 동작에 따라 다릅니다. 이러한 유형의 동작에 많은 관찰할 수 있습니다 하 고 안정적인 나타날 수 있습니다, 있지만 신뢰 하기 이상 이식 가능 하지 않습니다, 그리고 및 정의 되지 않았거나 지정 되지 않은 동작의 경우에도 오류입니다. 이 문서에서 언급 되는 동작에도, 해서는 안 됩니다 및 컴파일러 또는 CPU 구현 나중에 변경할 수 없습니다.

## <a name="example-migration-issues"></a>예제 마이그레이션 문제

이 문서의 나머지 부분에서는 이러한 c + + 언어 요소의 다른 동작을 서로 다른 플랫폼에서 다른 결과 산출 하는 방법을 설명 합니다.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>부호 없는 정수를 부동 소수점 변환

ARM 아키텍처에는 32 비트 정수를 부동 소수점 값을 변환 정수 부동 소수점 값을 정수를 나타낼 수 있는 범위를 벗어난 경우를 나타낼 수 있는 가장 가까운 값으로 포화 합니다. X86 및 x64 아키텍처에서 변환 정수에 서명이 되어 있지 않거나 경우 정수는-2147483648로 돌아 옵니다. 부동 소수점 값의 더 작은 정수 형식; 변환을 직접 지원 하지 않습니다 이러한 아키텍처 대신 32 비트는 변환이 수행 됩니다 하 고 더 작은 크기로 결과가 잘립니다.

ARM 아키텍처용 채도 및 잘림 조합을 의미는 부호 없는 형식으로 변환 올바르게 포화 되지 더 작은 부호 없는 형식 32 비트 정수를 포화 되지 않지만 잘린된 보다 큰 값은 결과 생성 하는 경우는 더 작은 형식 전체 32 비트 정수를 사용 하 하지만 너무 작아 나타낼 수 있습니다. 32 비트 부호 있는 정수에 대 한 변환 올바르게도 포화 되지 하지만 포화, 부호 있는 정수의 잘림 긍정적 포화 값에 대 한-1과 0 부정적인 포화 값에 대해 발생 합니다. 예측할 수 없는 잘린된 결과 생성 하는 더 작은 부호 있는 정수로 변환 합니다.

X86 및 x64 아키텍처에 대 한 부호 없는 정수로 변환에 대 한 순환 동작와 함께 잘림, 오버플로 대 한 부호 있는 정수로 변환에 대 한 명시적 평가 조합 확인 대부분의 이동에 대 한 결과 예측할 수 없는 너무 큽니다.

이러한 플랫폼은 또한 NaN (Not a Number)의 정수 형식으로 변환 하는 방법에 다릅니다. ARM, NaN 0x00000000;에 변환 x86 및 x64 0x80000000 변환합니다.

부동 소수점 변환 수만 의존해 서 값에 변환 될 정수 형식의 범위 내에서를 알고 있는 경우.

### <a name="shift-operator---behavior"></a>시프트 연산자 (\< \< >>) 동작

ARM 아키텍처에 값으로 이동할 수 왼쪽 또는 오른쪽 최대 255 비트 패턴 반복을 시작 하기 전에 합니다. X86 및 x64 아키텍처에서 패턴 반복 됩니다 32의 모든 배수가 패턴의 소스는 64 비트 변수; 아닌 경우 이 경우 x64 및 x86으로 소프트웨어 구현을 사용 되는 위치에서 256의 배수로에서 64의 모든 배수가에서 반복 되는 패턴입니다. 예를 들어 32 위치로 왼쪽 이동 1의 값이 있는 32 비트 변수의 ARM에서 결과 0, 결과 1, x86 및 x64 결과 또한 1입니다. 그러나 값의 소스는 64 비트 변수, 세 플랫폼 모두에서 결과 4294967296, 및 값을 하지 않습니다 "래핑" x64 또는 ARM에서 256 위치 및 x86에서 64 위치에서 이동한 될 때까지 합니다.

소스 형식의 비트 수를 초과 하는 시프트 연산의 결과가 정의 되지 않습니다, 때문에 컴파일러가 모든 상황에서 일관성 있게 동작 하도록 않아도 됩니다. 예를 들어 교대조의 두 피연산자 모두 컴파일 타임에 알고 있는 경우 컴파일러는 내부 루틴을 사용 하 여 작업의 결과 미리 계산 하 고 다음 시프트 연산 대신 결과 대체 하 여 프로그램을 최적화할 수 있습니다. 시프트 횟수가 너무 크거나 음수 이면 내부 루틴의 결과 CPU에서 실행 될 때 같은 시프트 식의 결과 보다 달라질 수 있습니다.

### <a name="variable-arguments-varargs-behavior"></a>변수 인수 (varargs) 동작

ARM 아키텍처에 스택에 전달 되는 가변 인수 목록에서 매개 변수 맞춤 될 수 있습니다. 예를 들어, 64 비트 매개 변수는 64 비트 경계에 맞춰집니다. X86 및 x64 인수는 스택에 전달 되는 적용 되지 맞춤 및 팩 긴밀 하 게 합니다. 이 차이 같이 variadic 함수 하면 `printf` 메모리 주소를 ARM에 대 한 안쪽 여백 가변 인수 목록의 예상 되는 레이아웃을 정확 하 게 일치 하지 않는 경우 x86 일부 값의 하위 집합에 대 한 작업 수에 읽을 수 또는 x64 아키텍처입니다. 다음 예제를 고려해 보세요.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

이 경우 인수의 맞춤 것으로 간주 되도록 올바른 형식 지정이 사용 하 여 버그를 해결할 수 있습니다. 이 코드는 잘못 되었습니다.

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>인수 평가 순서

때문에 x86 및 x64, ARM 프로세서는 매우 다르기 때문에, 다른 요구 사항이 컴파일러 구현 및 최적화에 대 한 다양 한 기회를 제공할 수 있는 합니다. 이 인해 호출 규칙 및 최적화 설정 등의 다른 요소와 함께 컴파일러를 평가할 수 있습니다 다른 순서에 따라 다른 아키텍처 또는 기타 요인 변경 될 때 함수 인수입니다. 이 예기치 않게 변경 하려면 특정 계산 순서에 의존 하는 앱의 동작이 발생할 수 있습니다.

인수는 함수를 다른 함수에 인수를 같은 호출에 영향을 주는 의도 하지 않은 경우 이러한 오류가 발생할 수 있습니다. 일반적으로 이런이 종류의 종속성을 방지 하기 이지만 종속성을 파악 하기 어려운 하거나 연산자 오버 로드 하 여에 경우에 따라 가려질 수 있습니다. 이 코드 예제를 살펴보세요.

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

이 나타납니다 잘 정의 된 경우 `->` 및 `*` 오버 로드 된 연산자에 있으면이 유사한이 코드는 변환:

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

간에 종속성이 있는 경우 `operator->(memory_handle)` 및 `operator*(p)`코드는 특정 계산 순서에 의존 하, 원래 코드를 다음과 같은 경우에 가능한는 종속성이 없습니다.

### <a name="volatile-keyword-default-behavior"></a>volatile 키워드 기본 동작

MSVC 컴파일러 지원의 두 가지 서로 다른 해석 된 `volatile` 컴파일러 스위치를 사용 하 여 지정할 수 있는 저장소 한정자입니다. 합니다 [찾는데](reference/volatile-volatile-keyword-interpretation.md) 스위치 해당 아키텍처에는 강력한 메모리 모델 때문에 x86 및 x64에 대 한 일반적인 경우 된 대로 강력한 순서를 보장 하는 휘발성 의미 체계를 확장 하는 Microsoft를 선택 합니다. 합니다 [/volatile:iso](reference/volatile-volatile-keyword-interpretation.md) 스위치 강력한 순서를 보장 하지 않습니다는 c + +에 엄격한 표준 volatile 의미를 선택 합니다.

ARM 아키텍처에는 기본값인 **/volatile:iso** 때문에 ARM 프로세서 약하게 메모리 모델을 정렬 하 고 ARM 소프트웨어의 확장 된 의미 체계에 의존 하지 레거시 없기 때문 **찾는데**  없는 일반적으로 수행 하는 소프트웨어와의 인터페이스입니다. 그러나 때로는 불편 또는 확장된 의미 체계를 사용 하는 ARM 프로그램을 컴파일하려면도 필수입니다. 예를 들어, ISO c + + 의미 체계를 사용 하는 프로그램을 이식 하 지나치게 높은 비용이 들 수 있습니다 또는 드라이버 소프트웨어 제대로 작동 하려면 기존의 의미 체계를 준수 해야 할 수 있습니다. 이러한 경우에 사용할 수 있습니다 합니다 **찾는데** 전환; 그러나 ARM 대상에 기존 volatile 의미 체계를 다시 만듭니다 컴파일러 삽입 해야 각 읽기 또는 쓰기의 메모리 장벽을 `volatile` 적용할 변수 강력한 순서 성능이 저하 될 수는 있습니다.

X86 및 x64 아키텍처에서 기본값은 **찾는데** 대부분의 MSVC를 사용 하 여 이러한 아키텍처에 대해 이미 만들어진에 소프트웨어에 사용 하기 때문입니다. X86 및 x64 프로그램을 컴파일할 때 지정할 수 있습니다 합니다 **/volatile:iso** 스위치 기존의 volatile 의미 체계에 대 한 불필요 한 의존도 방지 하는 데 이식성을 승격 합니다.

## <a name="see-also"></a>참고자료

[ARM 프로세서에 대한 Visual C++ 구성](configuring-programs-for-arm-processors-visual-cpp.md)
