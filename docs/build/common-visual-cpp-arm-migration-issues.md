---
title: 일반적인 Visual C++ ARM 마이그레이션 문제
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 2c29b4ffa5344b309622314970ce52c47a0ebd05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328804"
---
# <a name="common-visual-c-arm-migration-issues"></a>일반적인 Visual C++ ARM 마이그레이션 문제

MsVC(Microsoft C++ 컴파일러)를 사용하는 경우 동일한 C++ 소스 코드가 arm 아키텍처에서 x86 또는 x64 아키텍처와 다른 결과를 생성할 수 있습니다.

## <a name="sources-of-migration-issues"></a>마이그레이션 문제의 원인

x86 또는 x64 아키텍처에서 ARM 아키텍처로 코드를 마이그레이션할 때 발생할 수 있는 많은 문제는 정의되지 않은, 구현 정의 또는 지정되지 않은 동작을 호출할 수 있는 소스 코드 구문과 관련이 있습니다.

*정의되지 않은 동작은* C++ 표준이 정의하지 않는 동작이며, 부동 소수점 값을 부호 없는 정수로 변환하거나 승격된 형식의 비트 수를 초과하는 여러 위치로 값을 이동하는 등의 합리적인 결과가 없는 작업으로 인해 발생합니다.

*구현 정의 동작은* C++ 표준에서 컴파일러 공급업체가 정의하고 문서화해야 하는 동작입니다. 프로그램은 이식가능하지 않더라도 구현 정의 동작에 안전하게 의존할 수 있습니다. 구현 정의 동작의 예로는 기본 제공 데이터 형식의 크기와 정렬 요구 사항이 있습니다. 구현 정의 동작의 영향을 받을 수 있는 작업의 예는 변수 인수 목록에 액세스하는 것입니다.

*지정되지 않은 동작은* C++ 표준이 의도적으로 결정적이지 않은 동작입니다. 동작은 결정적이지 않은 것으로 간주되지만 지정되지 않은 동작의 특정 호출은 컴파일러 구현에 의해 결정됩니다. 그러나 컴파일러 공급업체가 결과를 미리 결정하거나 유사한 호출 간에 일관된 동작을 보장할 필요는 없으며 설명서에 대한 요구 사항은 없습니다. 지정되지 않은 동작의 예로는 함수 호출에 대한 인수를 포함하는 하위 식이 평가되는 순서가 있습니다.

다른 마이그레이션 문제는 C++ 표준과 다르게 상호 작용하는 ARM 및 x86 또는 x64 아키텍처 간의 하드웨어 차이로 인해 발생할 수 있습니다. 예를 들어 x86 및 x64 아키텍처의 강력한 `volatile`메모리 모델은 -qualified 변수에 과거에 특정 종류의 스레드 간 통신을 용이하게 하는 데 사용된 몇 가지 추가 속성을 제공합니다. 그러나 ARM 아키텍처의 약한 메모리 모델은 이 사용을 지원하지 않으며 C++ 표준에 필요하지 않습니다.

> [!IMPORTANT]
> x86 및 x64에서 제한된 형태의 스레드 간 통신을 구현하는 데 사용할 수 있는 일부 속성을 얻지만 `volatile` 이러한 추가 속성은 일반적으로 스레드 간 통신을 구현하기에 충분하지 않습니다. C++ 표준은 적절한 동기화 프리미티브를 대신 사용하여 이러한 통신을 구현하는 것이 좋습니다.

플랫폼마다 이러한 종류의 동작이 다르게 표현될 수 있으므로 특정 플랫폼의 동작에 따라 플랫폼 간에 소프트웨어를 이식하는 것이 어렵고 버그가 발생하기 쉽습니다. 이러한 종류의 동작중 상당수가 관찰될 수 있고 안정적으로 나타날 수 있지만, 이에 의존하는 것은 적어도 이식성이 없으며 정의되지 않았거나 지정되지 않은 동작의 경우도 오류입니다. 이 문서에서 인용된 동작도 의존해서는 안 되며 향후 컴파일러 또는 CPU 구현에서 변경될 수 있습니다.

## <a name="example-migration-issues"></a>마이그레이션 문제 예제

이 문서의 나머지 부분에서는 이러한 C++ 언어 요소의 다양한 동작이 서로 다른 플랫폼에서 서로 다른 결과를 생성하는 방법을 설명합니다.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>부동점을 부호없는 정수로 변환

ARM 아키텍처에서 부동 점 값을 32비트 정수로 변환하면 부동 점 값이 정수가 나타낼 수 있는 범위를 벗어난 경우 정수가 나타낼 수 있는 가장 가까운 값으로 포화됩니다. x86 및 x64 아키텍처에서 정수의 서명이 없는 경우 변환이 래핑하거나 정수에 서명된 경우 -2147483648로 설정됩니다. 이러한 아키텍처 중 어느 것도 부동 소수점 값을 더 작은 정수 유형으로 변환하는 것을 직접 지원하지 않습니다. 대신 변환이 32비트로 수행되고 결과가 더 작은 크기로 잘립니다.

ARM 아키텍처의 경우 채도 및 잘림의 조합은 부호없는 형식으로 변환하면 32비트 정수를 포화시킬 때 부호 없는 형식이 더 작아지지만 작은 형식보다 큰 값에 대해 잘린 결과가 생성되지만 전체 32비트 정수를 채포화하기에는 너무 작다는 것을 의미합니다. 또한 32비트 서명된 정수에 대해변환은 올바르게 포화되지만, 포화, 서명된 정수의 잘림은 양수 포화 값의 경우 -1, 음수 포화 값의 경우 0이 됩니다. 더 작은 서명된 정수로 변환하면 예측할 수 없는 잘린 결과가 생성됩니다.

x86 및 x64 아키텍처의 경우 서명되지 않은 정수 변환에 대한 랩어라운드 동작과 오버플로에서 서명된 정수 변환에 대한 명시적 평가의 조합과 잘림과 함께 너무 큰 경우 대부분의 교대조에 대한 결과를 예측할 수 없게 만듭니다.

이러한 플랫폼은 NaN(번호가 아님)을 정수 유형으로 변환하는 방법도 다릅니다. ARM에서 NaN은 0x00000000으로 변환합니다. x86 및 x64에서는 0x8000000으로 변환됩니다.

부동 지점 변환은 값이 변환되는 정수 유형의 범위 내에 있다는 것을 알고 있는 경우에만 사용할 수 있습니다.

### <a name="shift-operator---behavior"></a>시프트\< \< 연산자( >>) 동작

ARM 아키텍처에서 패턴이 반복되기 전에 값을 왼쪽 또는 오른쪽으로 255비트까지 이동할 수 있습니다. x86 및 x64 아키텍처에서 패턴의 소스가 64비트 변수가 아니면 32의 모든 배수에서 패턴이 반복됩니다. 이 경우 패턴은 x64에서 64의 모든 배수에서 반복되고 소프트웨어 구현이 사용되는 x86에서는 256의 모든 배수에서 반복됩니다. 예를 들어 값이 1이 32개 위치로 왼쪽으로 이동된 32비트 변수의 경우 ARM에서 결과는 0이고 x86에서는 결과가 1이고 x64에서는 결과도 1입니다. 그러나 값의 소스가 64비트 변수인 경우 세 플랫폼 모두의 결과는 4294967296이며, 값이 x64에서 64개 위치 또는 ARM 및 x86의 256개 위치로 이동할 때까지 "둘러싸기"되지 않습니다.

원본 형식의 비트 수를 초과하는 shift 작업의 결과가 정의되지 않으므로 컴파일러가 모든 상황에서 일관된 동작을 가질 필요는 없습니다. 예를 들어, 시프트의 두 피연산자가 컴파일 타임에 알려진 경우 컴파일러는 내부 루틴을 사용하여 시프트 결과를 미리 계산한 다음 시프트 작업 대신 결과를 대체하여 프로그램을 최적화할 수 있습니다. 시프트 양이 너무 크거나 음수인 경우 내부 루틴의 결과는 CPU에서 실행한 것과 동일한 시프트 식의 결과와 다를 수 있습니다.

### <a name="variable-arguments-varargs-behavior"></a>변수 인수(varargs) 동작

ARM 아키텍처에서 스택에 전달되는 변수 인수 목록의 매개 변수는 정렬될 수 있습니다. 예를 들어 64비트 매개변수는 64비트 경계에 정렬됩니다. x86 및 x64에서는 스택에 전달되는 인수는 정렬 및 압축의 적용을 받지 않습니다. 이러한 차이로 인해 x86 `printf` 또는 x64 아키텍처의 일부 값의 하위 집합에 대해 작동할 수 있더라도 변수 인수 목록의 예상 레이아웃이 정확히 일치하지 않는 경우 ARM에서 패딩으로 의도된 메모리 주소를 읽는 것과 같은 variadic 함수가 발생할 수 있습니다. 다음 예를 살펴보세요.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

이 경우 인수의 정렬을 고려하도록 올바른 형식 사양을 사용하여 버그를 수정할 수 있습니다. 이 코드는 정확합니다.

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>인수 평가 순서

ARM, x86 및 x64 프로세서는 매우 다르기 때문에 컴파일러 구현에 대한 다양한 요구 사항과 최적화를 위한 다양한 기회를 제시할 수 있습니다. 따라서 호출 규칙 및 최적화 설정과 같은 다른 요소와 함께 컴파일러는 다른 아키텍처에서 또는 다른 요소가 변경될 때 함수 인수를 다른 순서로 평가할 수 있습니다. 이로 인해 특정 평가 순서에 의존하는 앱의 동작이 예기치 않게 변경될 수 있습니다.

함수에 대한 인수에 동일한 호출의 함수에 다른 인수에 영향을 주는 부작용이 있을 때 이러한 종류의 오류가 발생할 수 있습니다. 일반적으로 이러한 종류의 종속성은 쉽게 피할 수 있지만 식별하기 어려운 종속성이나 연산자 오버로드로 인해 가려질 수 있습니다. 이 코드 예제를 고려하십시오.

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

이것은 잘 정의된 것처럼 `->` 보이지만 `*` 과부하된 연산자인 경우 이 코드는 다음과 유사한 것으로 변환됩니다.

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

그리고 사이에 `operator->(memory_handle)` 종속성이 있는 경우 `operator*(p)`, 원래 코드가 가능한 종속성이 없는 것처럼 보이지만 코드는 특정 평가 순서에 의존할 수 있습니다.

### <a name="volatile-keyword-default-behavior"></a>휘발성 키워드 기본 동작

MSVC 컴파일러는 컴파일러 스위치를 `volatile` 사용하여 지정할 수 있는 저장소 한정자에 대한 두 가지 해석을 지원합니다. [/volatile:ms](reference/volatile-volatile-keyword-interpretation.md) 스위치는 이러한 아키텍처에 대한 강력한 메모리 모델 때문에 x86 및 x64의 전통적인 경우와 마찬가지로 강력한 순서를 보장하는 Microsoft 확장 휘발성 의미 체계를 선택합니다. [/volatile:iso](reference/volatile-volatile-keyword-interpretation.md) 스위치는 강력한 순서를 보장하지 않는 엄격한 C++ 표준 휘발성 의미 체계를 선택합니다.

ARM 아키텍처에서 기본값은 **/volatile:iso** 때문에 ARM 프로세서는 약하게 정렬된 메모리 모델을 가지고 있으며 ARM 소프트웨어는 **/volatile:ms의** 확장 된 의미체계에 의존하는 레거시가 없기 때문에 일반적으로 소프트웨어와 인터페이스 할 필요가 없습니다. 그러나 확장 된 의미 체계를 사용 하 여 ARM 프로그램을 컴파일 하는 데 필요한 때로는 여전히 편리 합니다. 예를 들어 ISO C++ 의미 체계를 사용하기 위해 프로그램을 포팅하는 데 비용이 너무 많이 들거나 드라이버 소프트웨어가 올바르게 작동하기 위해 기존 의미 체계를 준수해야 할 수 있습니다. 이러한 경우 **/volatile:ms** 스위치를 사용할 수 있습니다. 그러나 ARM 대상에서 기존의 휘발성 의미 체계를 다시 만들려면 컴파일러는 성능에 부정적인 영향을 미칠 `volatile` 수 있는 강력한 순서를 적용하기 위해 변수를 읽거나 쓰는 각 읽기 또는 쓰기 주위에 메모리 장벽을 삽입해야 합니다.

x86 및 x64 아키텍처에서 기본값은 **/volatile:ms이므로** MSVC를 사용하여 이러한 아키텍처에 대해 이미 만들어진 대부분의 소프트웨어가 이 아키텍처에 의존하기 때문입니다. x86 및 x64 프로그램을 컴파일할 때 **/volatile:iso** 스위치를 지정하여 기존의 휘발성 의미 체계에 대한 불필요한 의존을 방지하고 이식성을 촉진할 수 있습니다.

## <a name="see-also"></a>참고 항목

[ARM 프로세서에 대한 Visual C++ 구성](configuring-programs-for-arm-processors-visual-cpp.md)
