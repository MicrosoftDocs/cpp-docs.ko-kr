---
title: "일반적인 Visual c + + ARM 마이그레이션 문제 | Microsoft Docs"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: bcc34d472fb6db02eb902001ad5aac77dea5baf0
ms.sourcegitcommit: 30ab99c775d99371ed22d1a46598e542012ed8c6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/03/2018
---
# <a name="common-visual-c-arm-migration-issues"></a>일반적인 Visual C++ ARM 마이그레이션 문제

Microsoft Visual c + + (MSVC)를 사용할 때 동일한 c + + 소스 코드 x86 또는 x64 아키텍처에서 사용 하지 않고 ARM 아키텍처에서 서로 다른 결과 생성할 수 있습니다.

## <a name="sources-of-migration-issues"></a>마이그레이션 문제에 대 한 소스

ARM 아키텍처에는 x86 또는 x64 아키텍처에서 코드를 마이그레이션할 때 발생할 수 있는 많은 문제는 정의 되지 않은, 구현 정의 된 또는 지정 되지 않은 동작을 호출할 수 있는 소스 코드 구문 관련이 있습니다.

*정의 되지 않은 동작이* 은 c + + 표준 정의 하지 않는 동작 하 고 적절 한 없는 결과 포함 하는 작업으로 인: 예를 들어 부동 소수점 값을 부호 없는 정수로 변환 또는 값의 위치 번호로 이동 음수 또는 승격된 된 형식과 비트 수를 초과 합니다.

*구현 정의 동작* 동작은 c + + 표준 컴파일러 공급 업체 정의 하 고 문서에 필요 합니다. 이렇게 하면 지금 하지 못할 이식 가능한 경우에 프로그램 구현에서 정의 된 동작에 의존할 안전 하 게 있습니다. 구현 정의 동작의 예로 기본 제공 데이터 형식 및 맞춤 요구 사항의 크기입니다. 구현 정의 동작에 영향을 받을 수 있는 작업의 예에는 가변 인수 목록에 액세스 하는 합니다.

*동작을 지정 하지 않으면* 은 c + + 표준 명확 하지 않은 의도적으로 해제 하는 동작입니다. 동작은 비 결정적인 것으로 간주 됩니다, 있지만 지정 되지 않은 동작이의 특정 호출 컴파일러 구현에 의해 결정 됩니다. 그러나 결과 미리 지정할 또는 비교 가능한 호출 사이의 일관 된 동작을 보장 컴파일러 공급 업체에 대 한 요구 사항은 없습니다 및 설명서에 대 한 요구 사항은 없습니다. 지정 되지 않은 동작의 예는 함수 호출에 대 한 인수를 포함 하는 하위 식에서 평가 되는 순서입니다.

다른 마이그레이션 문제 ARM와 다르게 표준 c + + 상호 작용 하는 x86 또는 x64 아키텍처 간의 하드웨어 차이 원인이 될 수 있습니다. 예를 들어, x86 및 x64 아키텍처의 강력한 메모리 내 모델 제공 `volatile`-특정 종류의 과거에서 스레드 간 통신을 용이 하 게 사용 된 몇 가지 추가 속성 변수를 한정 합니다. 하지만 ARM 아키텍처의 약한 메모리 내 모델은 사용자이를 지원 하지 않습니다 하거나 c + + 표준 필요지 않습니다.

> [!IMPORTANT]
>  하지만 `volatile` x86 및 x64, 이러한 추가 속성에 제한 된 형태의 스레드 간 통신을 구현 하는 데 사용할 수 있는 일부 속성을 구현 하지 않는 향상 스레드 간 통신 일반적입니다. C + + 표준은 적절 한 동기화 기본 형식을 대신 사용 하 여 이러한 통신 구현 해야 하는 것이 좋습니다.

수 있기 때문에 다양 한 플랫폼 이러한 종류의 동작을 다르게 express 수, 소프트웨어 플랫폼 간에 이식 어렵고 버그 발생 하기 쉬운 경우 특정 플랫폼의 동작에 따라 달라 집니다. 다양 한 동작의 이러한 종류를 확인할 수 있으며 안정적인 표시 될 수 있습니다, 쉬운지 이상 이식 불가능, 고 동작이 정의 되지 않았거나 지정 되지 않은 경우에도 오류가 발생 합니다. 이 문서에서 언급 하는 동작에도, 신뢰할 수 없습니다 및 컴파일러 또는 CPU 구현 나중에 변경할 수 없습니다.

## <a name="example-migration-issues"></a>예제 마이그레이션 문제

이 문서의 나머지 부분에서는 이러한 c + + 언어 요소의 다른 동작을 서로 다른 플랫폼에서 다른 결과 산출 하는 방법을 설명 합니다.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>부호 없는 정수를 부동 소수점 변환

ARM 아키텍처에서 32 비트 정수를 부동 소수점 값을 변환 하는 정수를 나타낼 수 있는 범위 밖에 있는 부동 소수점 값이 정수를 나타낼 수 있는 가장 가까운 값으로 포화 합니다. X86 및 x64 아키텍처는 정수, 부호 없는 형식 인지 또는 정수 서명 하는 경우-2147483648로 설정 되어 있으면 변환 주위 래핑합니다. 이러한 아키텍처 중 더 작은 정수 형식; 부동 소수점 값으로 변환을 직접 지원 대신, 32 비트로 수행 된 변환은 하 고 결과를 작은 크기로 잘립니다.

ARM 아키텍처에 대 한 채도 잘림 조합은 부호 없는 형식으로 변환 올바르게 포화 되지 더 작은 부호 없는 형식 보다 큰 값에 대 한 잘림된 결과 생성 하지만 32 비트 정수 포화 의미는 더 작은 형식 완전 32 비트 정수 포화 너무 작게 나타낼 수 있습니다. 변환 32 비트 부호 있는 정수에 대해 올바르게도 포화 하지만 정확 하 게 포화 값에 대 한-1과 부정적인 포화 값에는 0으로 인해 잘림 채도가, 부호 있는 정수입니다. 예측 가능 하지 않은 잘린된 결과 생성 하는 더 작은 부호 있는 정수로 변환 합니다.

X86 및 x64 아키텍처에 대 한 부호 없는 정수로 변환에 대 한 순환 동작와 함께 잘림, 오버플로에 부호 있는 정수로 변환에 대 한 명시적 평가 조합 확인 대부분 교대조에 대 한 결과 예측할 수 없는 너무 큽니다.

이러한 플랫폼 NaN (Not a Number)의 정수 형식으로 변환 하는 방법에 다릅니다. ARM, NaN을 0x00000000; 변환 x86 및 x64에서 0x80000000 변환합니다.

부동 소수점 변환 값으로 변환 되는 정수 형식의 범위 이내 인지 알고 있는 경우에 사용할 수만 있습니다.

### <a name="shift-operator---behavior"></a>시프트 연산자 (\< \< >>) 동작

ARM 아키텍처에서 값으로 이동할 수 왼쪽 또는 오른쪽 최대 255 비트 패턴 반복을 시작 하기 전에. X86 및 x64 아키텍처에서 패턴을 반복할지 32의 배수로에서 패턴의 소스는 64 비트 변수; 아닌 경우 이 경우 모든 다중 x64 및 x86,으로 소프트웨어 구현을 사용 되는 256의 배수로 64에서 반복 되는 패턴입니다. 예를 들어 32 위치로 왼쪽 이동 1의 값을 가진 32 비트 변수에 대 한 ARM의 결과 0, 결과 1, x86 및 x64 결과 또한 1입니다. 그러나 값의 소스는 64 비트 변수 이면 세 플랫폼 모두에 대 한 결과 4294967296, 및 값 하지 않습니다 "래핑" 256 위치 ARM 및 x86 또는 x64, 64 위치에서 이동한 될 때까지 합니다.

소스 형식에 있는 비트 수를 초과 하는 시프트 연산의 결과가 정의 되지 않습니다, 때문에 컴파일러가 모든 상황에서 일관 된 동작을 포함 하도록 않아도 됩니다. 예를 들어 근무조의 두 피연산자를 컴파일 타임에 알고 있는 경우 컴파일러는 내부 루틴을 사용 하 여 작업의 결과 미리 계산 하 고 다음 결과 대신 시프트 연산으로 대체 하 여 프로그램을 최적화할 수 있습니다. 시프트 횟수가 너무 큰 경우 또는 음수 이면 내부 루틴의 결과 CPU에서 실행할 때 동일한 shift 식의 결과 보다 다를 수 있습니다.

### <a name="variable-arguments-varargs-behavior"></a>가변 인수 (varargs) 동작

ARM 아키텍처에서 스택에 전달 되는 가변 인수 목록에서 매개 변수 맞춤 적용 됩니다. 예를 들어 64 비트 매개 변수는 64 비트 경계에 정렬 됩니다. X86 및 x64에서 인수는 스택에 전달 되는 적용 되지 않습니다 맞춤 및 팩 긴밀 하 게. 이러한 차이 같은 variadic 함수 하면 `printf` 메모리 주소를 ARM에 안쪽 여백으로 가변 인수 목록의 예상 되는 레이아웃 정확 하 게 일치 하지 않는 경우 x86 일부 값의 하위 집합에 대 한 못할 경우에 읽을 수 또는 x64 아키텍처. 다음 예제를 고려해 보십시오.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

올바른 형식 사양이 사용 됩니다 하 여 버그가 수 수정 하는 경우에 있도록 인수의 맞춤으로 간주 합니다. 이 코드는 올바릅니다.

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>인수 평가 순서

때문에 ARM, x86 및 x64 프로세서는 매우 다르기 때문에, 다른 요구 사항이 컴파일러의 구현 및 최적화에 대 한 다른 기회를 제공할 수 있습니다. 이 인해 호출 규칙 및 최적화 설정, 같은 다른 요소가 함께 컴파일러 평가할 수 있습니다 다른 아키텍처 또는 다른 요소는 변경 하는 경우에 다른 순서로 함수 인수입니다. 이 인해 예기치 않게 변경 하려면 특정 계산 순서에 의존 하는 앱의 동작이 있습니다.

인수는 함수를 다른 함수에 인수는 동일한 호출에서에 영향을 주는 의도 하지 않은 경우 이러한 오류가 발생할 수 있습니다. 일반적으로 이러한 종류의 종속성을 방지 하기 위해 쉽게 않으며 경우에 따라 가려질 수 종속성을 식별 하기 어려운 또는 연산자 오버 로드입니다. 이 코드 예제를 참조 하세요.

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

º ´ Â 잘 정의 된 경우에 `->` 및 `*` 이와 유사한이이 코드는 변환 오버 로드 된 연산자가 있습니다.

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

간에 종속성이 있는 경우 `operator->(memory_handle)` 및 `operator*(p)`, 코드가 특정 계산 순서에 의존 하, 원래 코드 처럼 보이는 경우에 가능한는 종속성이 없습니다.

### <a name="volatile-keyword-default-behavior"></a>volatile 키워드 기본 동작

MSVC 컴파일러 지원의 서로 다른 두 가지로 해석은 `volatile` 컴파일러 스위치를 사용 하 여 지정할 수 있는 저장소 한정자입니다. [/volatile:ms](../build/reference/volatile-volatile-keyword-interpretation.md) 스위치도 이러한 아키텍처에는 강력한 메모리 모델 때문에 x86 및 x64 기존의 경우 되어 강력한 순서를 보장 하는 volatile 의미 체계를 확장 하는 Microsoft를 선택 합니다. [/volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md) 스위치 선택 하는 고급 c + + 표준 휘발성 의미 체계를 강력한 순서를 보장 하지는 않습니다.

기본값은 ARM 아키텍처에서 **/volatile:iso** 때문에 ARM 프로세서는 약하게 메모리 내 모델을 정렬 하 고 ARM 소프트웨어의 확장 된 의미 체계에 의존 하지 레거시 없으므로 **/volatile:ms**  하며 없을 일반적으로 수행 하는 소프트웨어와 상호 작용 하 합니다. 그러나 인지 때로는 불편도 확장 된 의미 체계를 사용 하는 ARM 프로그램을 컴파일하는 데 필요 합니다. 예를 들어 ISO c + + 의미 체계를 사용 하 여 프로그램을 이식 하는 비용이 너무 높은 것 또는 드라이버 소프트웨어 제대로 작동 하려면 기존의 의미 체계를 준수 해야 할 수 있습니다. 이러한 경우에 사용할 수 있습니다는 **/volatile:ms** 스위치; 그러나 ARM 대상에 기존 휘발성 의미 체계를 다시 만들려면 컴파일러 삽입 해야 각 변수의 읽기 또는 쓰기 주위 메모리 장벽을 `volatile` 적용 하는 변수 강력한 순서는 성능에 부정적인 영향을 미칠 수 있습니다.

기본값은 x86 및 x64 아키텍처에서 **/volatile:ms** 사용 하기 때문에 이미 만들어져 있는 이러한 아키텍처에 대 한 MSVC를 사용 하 여 소프트웨어의 많은에 해당 합니다. X86 및 x64 프로그램을 컴파일할 때 지정할 수 있습니다는 **/volatile:iso** 기존의 휘발성 의미 체계에 대 한 불필요 한 의존도 방지 하 고 이식성을 승격 하는 스위치입니다.

## <a name="see-also"></a>참고 항목

[ARM 프로세서에 대한 Visual C++ 구성](../build/configuring-programs-for-arm-processors-visual-cpp.md)  
