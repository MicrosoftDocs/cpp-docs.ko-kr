---
title: ARM64 ABI 규칙 개요 | Microsoft Docs
ms.custom: ''
ms.date: 07/11/2018
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: cc115fbc77ac68c774b85bb86fd0cf9eac1fa51b
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/17/2018
ms.locfileid: "45716640"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 규칙 개요

기본 ABI에 대 한 Windows 컴파일하면 및 가장 많은 부분에 대 한 64 비트 모드 (ARMv8 또는 이후 아키텍처)에서 ARM 프로세서에서 실행 ARM의 표준 AArch64 EABI를 따릅니다. 이 문서에서는 몇 가지 주요 전제 조건 및 변경 EABI에서 설명 되어 있습니다. 32 비트 ABI에 대 한 정보를 참조 하세요 [개요의 ARM ABI 규칙](overview-of-arm-abi-conventions.md)합니다. 표준 ARM EABI에 대 한 자세한 내용은 참조 하세요. [이진 인터페이스 ABI (응용 프로그램) ARM 아키텍처용](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) (외부 링크).

## <a name="definitions"></a>정의

64 비트 지원의 도입으로 ARM가 몇 가지 용어를 정의 합니다.

- **AArch32** – 레거시 32 비트 명령 집합 아키텍처 (ISA) ARM을 Thumb 모드 실행을 포함 하 여 정의 합니다.
- **AArch64** – 새 64 비트 명령 집합 아키텍처 (ISA) ARM으로 정의 합니다.
- **ARMv7** – "7 생성" 사양의 AArch32에 대 한 지원을 포함 하는 ARM 하드웨어. ARM에 대 한 Windows의 첫 번째 버전에서 지원 되는 ARM 하드웨어의 버전입니다.
- **ARMv8** – "여덟 번째 세대" 사양의 AArch32 및 AArch64를 둘 다에 대 한 지원을 포함 하는 ARM 하드웨어.

이러한 정의 하는 것 외에도 Windows에서에서는 이러한 용어를 사용 합니다.

- **ARM** – 32 비트 ARM 아키텍처 (AArch32)를 가리킵니다. 이 WoA (ARM에서 Windows) 라고도 합니다.
- **ARM32** ARM에서와 동일-위의; 명확성을 위해이 문서에서 사용 합니다.
- **ARM64** – 64 비트 ARM 아키텍처 (AArch64)를 가리킵니다. WoA64 생각해가 있습니다.

마지막으로, 데이터 형식을 참조 하는 경우 정의 ARM에서 참조 됩니다.

- **짧은 벡터** –이 SIMD에 직접 나타낼 수 있는 데이터 형식, 즉 요소의 각 요소 1, 2, 4 또는 8 바이트 수 있는 해당 크기 (8 개 또는 16 바이트)에 따라 정렬 8 또는 16 바이트의 분량의 벡터
- **(유형이 같은 부동 소수점 집계) HFA** – 2 ~ 4 동일한 부동 소수점 구성원 (float 또는 double)를 사용 하 여 데이터 형식입니다
- **HVA (유형이 같은 짧은 벡터 집계)** –이 2 ~ 4 동일한 짧은 벡터 멤버를 사용 하 여 데이터 형식

## <a name="base-requirements"></a>기본 요구 사항

ARM64 버전 Windows에는 ARMv8에서 실행 되는 또는 이후 아키텍처 항상을 전제로 합니다. 모두 부동 소수점 및 NEON 지원 하드웨어에 있는 것으로 간주 됩니다.

있으 나 ARMv8 사양에 대 한 전체 지원 AArch32 응용 프로그램, 현재 계획이 없는 ARM64 버전 (즉, WOW64 계획이) Windows에서 기존 ARM32 응용 프로그램을 실행할 수 있도록 합니다. 나중에 다시 평가 될 이지만 현재 작업 가정 합니다.

ARMv8 사양 AArch32 및 AArch64를 둘 다에 대 한 새로운 선택적 암호화 및 CRC 도우미 opcode를 설명합니다. 이러한 지원은 현재 선택 사항 이지만 권장 합니다. 이러한 opcode를 활용 하려는 코드의 존재에 대 한 런타임 검사를 수행 해야 합니다.

## <a name="endianness"></a>endian

으로 ARM32는 ARM64 Windows에서 Windows의 버전 실행 little endian 모드에서. 엔디언 전환 하는 것은 AArch64에서 커널 모드를 지원 하지 않는 시키려면 적용 하기가 어렵습니다.

## <a name="alignment"></a>맞춤

ARM64에서 실행 중인 Windows 불일치 액세스를 투명 하 게 처리할 수 있도록 CPU 하드웨어를 수 있습니다. AArch32에서 개선 되었습니다,이 지원은 이제 에서도 작동 부동 소수점 액세스 한 모든 정수 액세스 (여러 단어로 이루어진 액세스 포함)에 대 한 합니다.

그러나 캐시 되지 않은 (장치) 메모리에 대 한 액세스도 항상 정렬 되어야 합니다. 즉, 코드를 요청할 수 있습니다 읽기/쓰기로 불일치 데이터 캐시 되지 않은 메모리에서 수행 해야 하는 경우 안전 하 게 작업 하 고 모든 액세스 정렬 되어 있는지 확인 합니다.

## <a name="integer-registers"></a>정수 레지스터

AArch64 아키텍처는 아래에 요약 32 정수 레지스터를 지원 합니다.

|레지스터|휘발성 여부|역할|
|-|-|-|
x0|휘발성|매개 변수/스크래치 레지스터 1 결과 등록
x1 x7|휘발성|매개 변수/스크래치 레지스터 2 ~ 8
x8 x15|휘발성|스크래치 레지스터
x16 x17|휘발성|프로시저 호출 내 스크래치 레지스터
x18|비휘발성|플랫폼 등록: 커널 모드에서 가리키는 KPCR 현재 프로세서; 사용자 모드에서 TEB를 가리킵니다.
x19 x28|비휘발성|스크래치 레지스터
x29/fp|비휘발성|프레임 포인터
x30/lr|비휘발성|링크 레지스터

각 등록 (x0-x30)를 통해 전체 64 비트 값으로 또는 32 비트 값 (w0-w30)를 통해 액세스할 수 있습니다. 32 비트 operations 0-확장 그 결과 64 비트입니다.

매개 변수 레지스터의 사용에 대 한 자세한 내용은 섹션을 전달 매개 변수를 참조 하세요.

참고 AArch32, 달리 PC 및 SP 하지 인덱싱된 레지스터를 액세스할 수 하는 방법에 따라서 제한 됩니다. 또한 없습니다 x31는 등록 (인코딩 특수 한 용도로 사용 됨).

프레임 포인터 (x29) 사용 ETW 및 기타 서비스를 사용한 빠른 스택 워크를 사용 하 여 호환성을 위해 필요 합니다. 이전 {x29, 30 x} 가리켜야 스택에 쌍입니다.

## <a name="floating-pointsimd-registers"></a>부동 소수점/SIMD 등록

아래에 요약 32 부동 소수점/SIMD 레지스터를 AArch64 아키텍처를 지원 합니다.

레지스터|휘발성 여부|역할
|-|-|-|
v0|휘발성|매개 변수/스크래치 레지스터 1 결과 등록
v1 v7|휘발성|매개 변수/스크래치 레지스터 2 ~ 8
v8 v15|비휘발성|스크래치 레지스터 (하위 64 비트는 비휘발성 참고)
v16 v31|휘발성|스크래치 레지스터

각 등록 (h0-h31)를 통해 16 비트 값으로 또는 (b0-b31)를 통해 8 비트 값으로 (s0-s31)를 통해 32 비트 값으로 d0-d 31 인), (통해 64 비트 값 (v0 v31 또는 q0 q31)를 통해 전체 128 비트 값으로 액세스할 수 있습니다. 128 비트 미만의 액세스 전체 128 비트 레지스터의 비트를 낮은 액세스 및 지정 하지 않으면 나머지 비트를 그대로 둡니다. (이 AArch32, 큰 레지스터가 위에 작은 레지스터 된 압축 하는 위치와 크게 다릅니다 note 합니다.)

데이터 레지스터 외에도 부동 소수점 제어 레지스터 (FPCR) 내 다양 한 비트에서 특정 요구 사항이 있음:

비트|의미|휘발성 여부|역할
|-|-|-|-|
26|AHP|비휘발성|대체 반정밀도 컨트롤
25|DN|비휘발성|기본 NaN 모드 컨트롤
24|FZ|비휘발성|0으로 플러시 모드 컨트롤
23-22|RMode|비휘발성|반올림 모드 컨트롤
15,12 8|IDE/ixe 등/etc|비휘발성|예외 트랩 사용 비트, 항상 0이어야 함

## <a name="system-registers"></a>시스템 등록

AArch32, 같은 AArch64 사양에는 세 가지 시스템 제어 방식의 "스레드 ID" 레지스터를 다음과 같이 사용/할당 되는 제공 합니다.

레지스터|역할
|-|-|
TPIDR_EL0|예약됨
TPIDRRO_EL0|현재 프로세서에 대 한 CPU 수를 포함합니다.
TPIDR_EL1|현재 프로세서에 대 한 KPCR 구조를 가리킵니다.

## <a name="floating-point-exceptions"></a>부동 소수점 예외

IEEE 부동 소수점 예외에 대 한 지원을 AArch64 시스템에서 선택 사항입니다. 하드웨어 부동 소수점 예외 없는 프로세서 변형에 대 한 Windows 커널 자동으로 예외를 catch 하 고 암시적으로 사용 하지 않도록 설정 하는 FPCR 레지스터입니다. 이 프로세서 변형 간에 동작이 정규화를 확인 하는 것 (이 고, 그렇지 코드 개발 플랫폼에서 지 원하는 플랫폼에서 실행 하는 경우 예기치 않은 예외를 수행 하는 자체 예외 지원이 알 수 없는).

## <a name="parameter-passing"></a>매개 변수 전달

Variadic이 아닌 함수에 대 한 Windows ABI는 매개 변수 전달에 대 한 ARM에서 지정한 규칙을 따릅니다. 이러한 규칙은 AArch64 아키텍처에 대 한 프로시저 호출 표준에서 직접 발췌:

### <a name="stage-a--initialization"></a>단계 A-초기화

이 단계는 인수의 처리 시작 되기 전에 정확히 한 번 수행 됩니다.

1. 다음 범용 등록 번호 (NGRN) 0으로 설정 됩니다.

2. 다음 SIMD 및 부동 소수점 등록 번호 (NSRN)를 0으로 설정 됩니다.

3. 다음 누적된 인수 주소 (NSAA)은 현재 스택 포인터 값 (SP)으로 설정 됩니다.

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>단계 B-사전 채우기 및 인수 확장명

목록의 각 인수에 대 한 다음 목록에서 첫 번째 일치 하는 규칙이 적용 됩니다. 수정 되지 않은 인수는 규칙 일치 합니다.

1. 인수 형식을 호출자와 호출 수신자에서 해당 크기를 정적으로 확인할 수 없으므로 복합 형식이 면 인수는 메모리에 복사 하 고 인수 복사본의 포인터로 대체 됩니다. (C/c + +에 해당 형식이 하지만 다른 언어 또는 언어 확장에 있는).

2. 인수 형식은 HFA 또는 HVA 경우 인수는 수정 되지 않은 합니다.

3. 인수 형식은 복합 형식 16 바이트 보다 큰 경우 인수 호출자가 할당 된 메모리에 복사 되 고 복사본에 대 한 포인터 인수는 교체 하는 것입니다.

4. 인수 형식은 복합 형식인 경우 다음 인수의 크기를 반올림 됩니다 8 바이트의 가장 가까운 배수로.

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>단계 C-레지스터와 스택에 인수 할당

목록의 각 인수에 대 한 다음 규칙 인수에 할당 될 때까지 차례로 적용 됩니다. 인수가 레지스터에 할당 될 때 레지스터에 사용 되지 않는 모든 비트 값을 지정 합니다. 인수는 스택 슬롯에 할당 되 면 사용 하지 않는 패딩 바이트 값을 지정 합니다.

1. 이면 인수는 절반-단일, 이중 또는 쿼드 정밀도 부동 소수점 또는 짧은 벡터 형식 및는 NSRN에 있으면 8 보다 작으면 인수 레지스터 v [NSRN]의 최하위 비트에 할당 됩니다. NSRN 1 씩 증가 합니다. 이제 인수가 할당 되었습니다.

2. HFA 또는 HVA 인수는 충분 한 할당 되지 않은 SIMD 및 부동 소수점 레지스터 (NSRN + 멤버 ≤ 8 수)을 하는 경우에 인수 SIMD 및 부동 소수점 등록 (HFA 또는 HVA 구성원 당 하나의 등록)에 할당 됩니다. NSRN 사용 된 레지스터 수 만큼 증가 합니다. 이제 인수가 할당 되었습니다.

3. HFA 또는 HVA 인수는 그런 다음는 NSRN 8로 설정 됩니다 고 인수의 크기 8 바이트의 가장 근사한 배수로 반올림 됩니다.

4. NSAA는 반올림 쿼드 정밀도 부동 소수점 또는 Short 벡터 입력 인수가 HFA는 HVA 인수 형식의 자연 맞춤 또는 8 중 더 큰 최대입니다.

5. 인수 절반 또는 단 정밀도 부동 소수점 형식인 경우 인수의 크기는 8 바이트로 설정 됩니다. 결과 인수 처럼 복사 된 64 비트 레지스터의 최하위 비트를 지정 하지 않은 값으로 채워진 나머지 비트입니다.

6. 인수는 HFA 인 경우는 HVA 절반-, 단일, 이중 또는 쿼드 정밀도 부동 소수점 또는 짧은 벡터 형식 차례로 인수는 조정 된 NSAA에서 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

7. 인수는 정수 계열 또는 포인터 형식인 경우 인수의 크기가 보다 작거나 8 바이트를 NGRN을 8 보다 작으면 이면 인수 [NGRN] x의 최하위 비트에 복사 됩니다. NGRN 1 씩 증가 합니다. 이제 인수가 할당 되었습니다.

8. 인수가 16 맞춤 하는 경우 다음을 NGRN 반올림 됩니다 다음 짝수 수 있습니다.

9. 인수는 정수 계열 형식, 인수 크기가 16과 같습니다 이며는 NGRN 7 미만 인수 x에 복사 됩니다 [NGRN] 및 [NGRN + 1] x입니다. x [NGRN]는 낮은 주소가 지정 된 double-단어가 포함 인수는 메모리 내 표현입니다. NGRN 2 씩 증가 합니다. 이제 인수가 할당 되었습니다.

10. 인수가 복합 형식이 및 인수 2 배 워드에서 크기가 8 NGRN 뺀 값 보다 큰 경우 연속 범용 레지스터로 인수가 복사 됩니다 [NGRN]에서 시작 합니다. (사용 되지 않는 부분이 레지스터의 내용을 지정 하지 않은 메모리에서 연속 된 레지스터 로드 LDR 지침의 적절 한 순서를 사용 하 여 이중 단어 정렬 주소의 레지스터에 로드 된 것 처럼 인수가 전달 됩니다. 이 표준). NGRN 사용 된 레지스터 수 만큼 증가 합니다. 이제 인수가 할당 되었습니다.

11. NGRN 8로 설정 됩니다.

12. NSAA 반올림은 8 또는 인수 형식의 자연 맞춤의 더 큰...

13. 인수가 복합 형식이 면 인수는 조정 된 NSAA에서 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

14. 인수의 크기가 8 바이트 보다 작은 경우 인수의 크기는 8 바이트로 설정 됩니다. 인수가 지정 되지 않은 값으로 채워진 나머지 비트 및 64 비트 레지스터의 최하위 비트를 복사 된 것 처럼 됩니다.

15. 인수는 조정 된 NSAA에서 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

### <a name="addendum-variadic-functions"></a>추 록: Variadic 함수

가변 개수의 인수를 사용 하는 함수 다르게 처리 됩니다 보다 위에 다음과 같습니다.

1. 모든 복합 처리할지 동일 하 게 됩니다. HFAs 자산 또는 Hva의 특별 한 작업이 수행 되지 않습니다.

2. SIMD 및 부동 소수점 레지스터 사용 되지 않습니다.

효과적으로이 매월 다음 규칙 C.12–C.15 여기서 스택의 첫 번째 64 바이트 x0 x7, 로드 되 고 나머지 스택 인수가 일반적으로 배치 됩니다 허수 스택에 인수 할당 합니다.

## <a name="return-values"></a>반환 값

정수 계열 값 x0 반환 됩니다. 부동 소수점 값 s0/d0/v0 적절 하 게 반환 됩니다.

반환 값 레지스터를 통해 전달 될 수 없습니다는, 호출자에 게 충분 한 크기 및 결과 저장 하는 맞춤의 메모리 블록을 보유 됩니다. 메모리 블록의 주소를 비 POD 형식에 대 한 x8 x0 (또는 $가 전달 되 면 x0 x1) 또는 POD 형식에 대 한 함수 추가 인수로 전달 수 됩니다. 호출 수신자 (에 비 POD,이 버퍼의 주소 대해서 x8, 저장 된 값을 유지 하기 위해 호출 수신자에 대 한 요구 사항 없이을 반환 합니다 x0 호출 수신자가) 서브루틴을 실행 하는 동안 언제 든 지 결과 메모리 블록을 수정할 수 있습니다.

## <a name="stack"></a>스택

적용 하 여 ARM ABI 다음 스택을 유지 되어야 16 바이트 모든 시간에 정렬 합니다. AArch64 오류 SP 관련 부하 또는 스토어를 이루어집니다 이며 SP 16 바이트가 아니라 때마다 정렬 스택 정렬을 생성 하는 하드웨어 기능을 포함 합니다. 항상 사용 하도록 설정 하는이 기능을 사용 하 여 Windows를 실행 합니다.

4k 이상의 가치가 스택의 할당 하는 함수는 순서 대로 연결 최종 페이지 이전의 각 페이지에 없는 코드를 보장 수 "leap 통해" Windows 스택을 확장을 사용 하는 가드 페이지를 확인 해야 합니다. 일반적으로 이렇게는 `__chkstk` x8 16로 나눈 값의 총 스택 할당을 전달 하는 사용자 지정 호출 규칙에는 도우미입니다.

## <a name="red-zone"></a>빨간색 영역

현재 스택 포인터 바로 아래는 16 바이트 영역은 분석에서 사용 하도록 예약 하 고 동적 시나리오를 패치 합니다. 이렇게 하면 신중 하 게 생성 된 코드를 삽입할 수에서 2 레지스터를 저장 하는 [sp, # 16] 일시적으로 임의의 목적으로 사용 합니다. Windows 커널은 사용자 및 커널 모드에서 예외 나 인터럽트가 수행 되 면 해당 16 바이트를 덮어쓰지 않습니다을 보장 합니다.

## <a name="kernel-stack"></a>커널 스택

Windows의 기본 커널 모드 스택은 6 개의 페이지 (24 k). 커널 모드에서 큰 스택 버퍼가 있는 함수에 특별히 주의 지불 합니다. Ill-timed 인터럽트 거의 헤드룸 함께 스택 비상 버그 확인을 만들 수 있습니다.

## <a name="stack-walking"></a>스택 워크

사용 하도록 설정 하는 프레임 포인터를 사용 하 여 Windows 내의 코드는 컴파일됩니다 ([/Oy-](../build/reference/oy-frame-pointer-omission.md)) 빠른 스택 워크를 사용 하도록 설정 합니다. 이 결론은 x29 (fp) 일반적 {fp, lr}는 체인의 다음 링크를 가리키는지 스택의 반환 주소에 이전 프레임에 대 한 포인터를 나타내는 쌍입니다. 향상 된 프로 파일링 및 추적을 허용 하기 위해 프레임 포인터도 사용 하도록 타사 코드를 사용 하는 것이 좋습니다.

## <a name="exception-unwinding"></a>예외 해제

예외 처리 하는 동안 해제는 해제 코드를 사용 하 여 지원 됩니다. 해제 코드는 함수 프롤로그의 결과 백업 하기 위한 준비 과정에서 실행 취소할 수 있도록 프롤로그에서 프롤로그 및 에필로그의 작업을 설명 하는 실행 파일의.xdata 섹션에 저장 하는 바이트 시퀀스를 호출자의 스택 프레임입니다. 해제 코드에 대 한 자세한 내용은 참조 하세요. [ARM64 예외 처리](arm64-exception-handling.md)합니다.

ARM EABI는 해제 코드는 예외 해제 모델을 지정 합니다. 그러나 사양을 제공 하는 대로 프롤로그 또는 에필로그 중간에 함수의 PC 인 경우를 처리 해야 하는 Windows의 해제에 충분 하지 않습니다.

동적으로 생성 되는 코드를 통해 동적 함수 테이블을 사용 하 여 설명 되어야 하는 `RtlAddFunctionTable` 및 관련 함수에 생성된 된 코드는 예외 처리에 참여할 수 있도록 합니다.

## <a name="cycle-counter"></a>사이클 카운터

모든 ARMv8 Cpu 주기를 지 원하는 데 필요한 카운터를 등록 합니다. 모든 예외 수준 (포함 하 여 사용자 모드)에서 읽을 수 있는 Windows를 구성 하는 64 비트 레지스터입니다. 특수 PMCCNTR_EL0 통해 액세스할 수 있습니다 MSR opcode를 사용 하 여 어셈블리 코드에를 등록 또는 `_ReadStatusReg` C/c + + 코드에서 내장 함수입니다.

여기에 사이클 카운터는 실제 사이클 카운터, 없습니다 벽 시계를 이므로 계산 빈도 프로세서 빈도 따라 달라 집니다. 사이클 카운터의 빈도 알고 있어야에 생각 하면 사용 하지 말아야 사이클 카운터입니다. 사용 해야 하는 벽 시계 시간을 측정 하려는 대신 `QueryPerformanceCounter`합니다.

## <a name="see-also"></a>참고자료

[일반적인 Visual C++ ARM 마이그레이션 문제](../build/common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 예외 처리](../build/arm64-exception-handling.md)
