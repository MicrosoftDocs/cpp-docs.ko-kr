---
title: ARM64 ABI 규칙 개요
ms.date: 03/27/2019
ms.openlocfilehash: 2695ba69c642b2100ec041d1f85debb4ad7041c8
ms.sourcegitcommit: 06fc71a46e3c4f6202a1c0bc604aa40611f50d36
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/27/2019
ms.locfileid: "58508860"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 규칙 개요

컴파일할 때 Windows에 대 한 기본 응용 프로그램 이진 인터페이스 (ABI) 및 가장 많은 부분에 대 한 64 비트 모드 (ARMv8 또는 이후 아키텍처)에서 ARM 프로세서에서 실행 ARM의 표준 AArch64 EABI를 따릅니다. 이 문서에서는 몇 가지 주요 전제 조건 및 변경 EABI에서 설명 되어 있습니다. 32 비트 ABI에 대 한 정보를 참조 하세요 [개요의 ARM ABI 규칙](overview-of-arm-abi-conventions.md)합니다. 표준 ARM EABI에 대 한 자세한 내용은 참조 하세요. [이진 인터페이스 ABI (응용 프로그램) ARM 아키텍처용](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) (외부 링크).

## <a name="definitions"></a>정의

64 비트 지원의 도입으로 ARM가 몇 가지 용어를 정의 합니다.

- **AArch32** – 레거시 32 비트 명령 집합 아키텍처 (ISA) ARM을 Thumb 모드 실행을 포함 하 여 정의 합니다.
- **AArch64** – 새 64 비트 명령 집합 아키텍처 (ISA) ARM으로 정의 합니다.
- **ARMv7** – "7 생성" 사양의 AArch32에 대 한 지원을 포함 하는 ARM 하드웨어. ARM 하드웨어의이 버전은 Windows ARM 지원에 대 한 첫 번째 버전입니다.
- **ARMv8** – "여덟 번째 세대" 사양의 AArch32 및 AArch64를 둘 다에 대 한 지원을 포함 하는 ARM 하드웨어.

Windows에는 이러한 용어는 사용합니다.

- **ARM** – 라고도 WoA (ARM에서 Windows) 32 비트 ARM 아키텍처 (AArch32)를 가리킵니다.
- **ARM32** ARM에서와 동일-위의; 명확성을 위해이 문서에서 사용 합니다.
- **ARM64** – 64 비트 ARM 아키텍처 (AArch64)를 가리킵니다. WoA64 생각해가 있습니다.

마지막으로, 데이터 형식을 참조 하는 경우 정의 ARM에서 참조 됩니다.

- **짧은 벡터** – SIMD를 요소의 8 바이트 또는 16 바이트 분량의 벡터에서 직접 표현할 수 있는 데이터 형식입니다. 8 바이트 또는 16 바이트, 각 요소 1, 2, 4 또는 8 바이트 수 있는 크기로 정렬 합니다.
- **(유형이 같은 부동 소수점 집계) HFA** – 2 ~ 4 동일한 부동 소수점 멤버를 사용 하 여 데이터 형식 또는 부동 두 배로 만듭니다.
- **HVA (유형이 같은 짧은 벡터 집계)** – 2 ~ 4 동일한 짧은 벡터 멤버를 사용 하 여 데이터 형식입니다.

## <a name="base-requirements"></a>기본 요구 사항

ARM64 버전 Windows에는 ARMv8에서 실행 되는 또는 이후 아키텍처 항상을 전제로 합니다. 모두 부동 소수점 및 NEON 지원 하드웨어에 있는 것으로 간주 됩니다.

ARMv8 사양 AArch32 응용 프로그램의 전체를 지원할 수 있습니다. 그러나 Windows ARM64 버전에서 기존 ARM32 응용 프로그램에 대 한 지원 계획 되지 않습니다. (즉, 계획이 없는 WOW64에 대 한)입니다. 이 지원은 나중에 다시 평가 따라 이지만 현재 작업 가정 합니다.

ARMv8 사양 AArch32 및 AArch64를 둘 다에 대 한 새로운 선택적 암호화 및 CRC 도우미 opcode를 설명합니다. 에 대 한 현재 선택 사항 이지만 권장 됩니다. 이러한 opcode를 활용 하려면 앱의 존재에 대해 런타임 검사를 먼저 확인 해야 합니다.

## <a name="endianness"></a>endian

으로 ARM32는 ARM64 Windows에서 Windows의 버전 실행 little endian 모드에서. 엔디언 전환 하는 것은 AArch64에서 커널 모드를 지원 하지 않는 시키려면 적용 하기가 어렵습니다.

## <a name="alignment"></a>맞춤

ARM64에서 실행 중인 Windows 불일치 액세스를 투명 하 게 처리할 수 있도록 CPU 하드웨어를 수 있습니다. AArch32에서 개선 되었습니다,이 지원은 이제 에서도 작동 부동 소수점 액세스 한 모든 정수 액세스 (여러 단어로 이루어진 액세스 포함)에 대 한 합니다.

그러나 캐시 되지 않은 (장치) 메모리에 대 한 액세스도 항상 정렬 되어야 합니다. 코드 없습니다 수 읽기 또는 캐시 되지 않은 메모리에서 정렬이 잘못 된 데이터를 쓰기, 경우에 모든 액세스에 맞게 있는지 확인 해야 합니다.

## <a name="integer-registers"></a>정수 레지스터

AArch64 아키텍처 32 정수 레지스터를 지원합니다.

| 레지스터 | 휘발성 여부 | 역할 |
| - | - | - |
| x0 | 휘발성 | 매개 변수/스크래치 레지스터 1 결과 등록 |
| x1-x7 | 휘발성 | 매개 변수/스크래치 레지스터 2 ~ 8 |
| x8-x15 | 휘발성 | 스크래치 레지스터 |
| x16-x17 | 휘발성 | 프로시저 호출 내 스크래치 레지스터 |
| x18 | 비휘발성 | 플랫폼 등록: 커널 모드에서 가리키는 KPCR 현재 프로세서; 사용자 모드에서 TEB를 가리킵니다. |
| x19-x28 | 비휘발성 | 스크래치 레지스터 |
| x29/fp | 비휘발성 | 프레임 포인터 |
| x30/lr | 비휘발성 | 링크 레지스터 |

각 등록 (x0-x30)를 통해 전체 64 비트 값으로 또는 32 비트 값 (w0-w30)를 통해 액세스할 수 있습니다. 32 비트 operations 0-확장 그 결과 64 비트입니다.

매개 변수 레지스터의 사용에 대 한 자세한 내용은 섹션을 전달 매개 변수를 참조 하세요.

AArch32, 달리 프로그램 카운터 (PC)와 스택 포인터 (SP)은 인덱싱된 레지스터 없습니다. 액세스할 수 방법을 제한 하 고 있습니다. 또한 없습니다 x31는 등록 합니다. 특수 목적을 위해 해당 인코딩이 사용 됩니다.

프레임 포인터 (x29)가 ETW 및 기타 서비스를 사용한 빠른 스택 워크 호환성이 필요 합니다. 이전 {x29, 30 x} 가리켜야 스택에 쌍입니다.

## <a name="floating-pointsimd-registers"></a>부동 소수점/SIMD 등록

아래에 요약 32 부동 소수점/SIMD 레지스터를 AArch64 아키텍처를 지원 합니다.

| 레지스터 | 휘발성 여부 | 역할 |
| - | - | - |
| v0 | 휘발성 | 매개 변수/스크래치 레지스터 1 결과 등록 |
| v1-v7 | 휘발성 | 매개 변수/스크래치 레지스터 2 ~ 8 |
| v8-v15 | 비휘발성 | 새로 등록 (하위 64 비트 비휘발성만) |
| v16-v31 | 휘발성 | 스크래치 레지스터 |

각 등록 (v0 v31 또는 q0 q31)를 통해 전체 128 비트 값으로 액세스할 수 있습니다. 액세스할 수 있습니다 (d0-d 31 인)를 통해 64 비트 값으로 (s0-s31)를 통해 32 비트 값으로는 16 비트 값 (h0-h31)를 통해 또는 (b0-b31)를 통해 8 비트 값으로. 128 비트 미만의 액세스는 전용 전체 128 비트 레지스터의 하위 비트 액세스입니다. 떠날 나머지 비트 그대로 달리 지정 하지 않으면. (AArch64는 AArch32, 큰 레지스터가 위에 작은 레지스터 된 압축 하는 위치와 다릅니다.)

부동 소수점 제어 레지스터 (FPCR)에 그 안에 다양 한 비트를 특정 요구 사항:

| 비트 | 의미 | 휘발성 여부 | 역할 |
| - | - | - | - |
| 26 | AHP | 비휘발성 | 대체 반 정밀도 컨트롤입니다. |
| 25 | DN | 비휘발성 | 기본 NaN 모드 컨트롤입니다. |
| 24 | FZ | 비휘발성 | 0으로 플러시 모드 컨트롤입니다. |
| 23-22 | RMode | 비휘발성 | 반올림 모드 컨트롤입니다. |
| 15,12-8 | IDE/IXE/etc | 비휘발성 | 예외 트랩 사용 비트, 항상 0 이어야 합니다. |

## <a name="system-registers"></a>시스템 등록

AArch32, 같은 AArch64 사양에서는 세 가지 시스템 제어 방식의 "스레드 ID" 레지스터를 제공합니다.

| 레지스터 | 역할 |
| - | - |
| TPIDR_EL0 | 예약됨. |
| TPIDRRO_EL0 | 현재 프로세서에 대 한 CPU 수를 포함합니다. |
| TPIDR_EL1 | 현재 프로세서에 대 한 KPCR 구조를 가리킵니다. |

## <a name="floating-point-exceptions"></a>부동 소수점 예외

IEEE 부동 소수점 예외에 대 한 지원을 AArch64 시스템에서 선택 사항입니다. 하드웨어 부동 소수점 예외 없는 프로세서 변형에 대 한 Windows 커널 자동으로 예외를 catch 하 고 암시적으로 사용 하지 않도록 설정 하는 FPCR 레지스터입니다. 이 트랩 프로세서 변형 간에 동작이 정규화를 확인합니다. 이 고, 그렇지 예외를 지원 하지 않는 플랫폼에서 개발 된 코드 지원 플랫폼에서 실행 하는 경우 예기치 않은 예외를 수행 하는 자체를 찾을 수 있습니다.

## <a name="parameter-passing"></a>매개 변수 전달

Variadic이 아닌 함수에 대 한 Windows ABI는 매개 변수 전달에 대 한 ARM에서 지정한 규칙을 따릅니다. 이러한 규칙은 AArch64 아키텍처에 대 한 프로시저 호출 표준에서 직접 발췌:

### <a name="stage-a--initialization"></a>단계 A-초기화

이 단계는 인수의 처리가 시작 되기 전에 정확히 한 번 수행 됩니다.

1. 다음 범용 등록 번호 (NGRN) 0으로 설정 됩니다.

1. 다음 SIMD 및 부동 소수점 등록 번호 (NSRN)를 0으로 설정 됩니다.

1. 다음 누적된 인수 주소 (NSAA)은 현재 스택 포인터 값 (SP)으로 설정 됩니다.

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>단계 B-사전 채우기 및 인수 확장명

목록의 각 인수에 대 한 다음 목록에서 첫 번째 일치 하는 규칙이 적용 됩니다. 규칙이 일치, 인수 하는 경우 다음 변경 되지 않습니다.

1. 인수 형식을 호출자와 호출 수신자에서 해당 크기를 정적으로 확인할 수 없으므로 복합 형식이 면 인수는 메모리에 복사 하 고 인수 복사본의 포인터로 대체 됩니다. (C/c + +에 해당 형식이 하지만 다른 언어 또는 언어 확장에 있는).

1. 인수 형식은 HFA 또는 HVA 경우 인수는 수정 되지 않은 합니다.

1. 인수 형식은 복합 형식 16 바이트 보다 큰 경우 인수는 호출자가 할당 된 메모리를 복사한 다음 하 고 인수 복사본의 포인터로 대체 됩니다.

1. 인수 형식은 복합 형식, 하는 경우 다음 인수의 크기를 반올림 됩니다 8 바이트의 가장 가까운 배수로.

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>단계 C-레지스터와 스택에 인수 할당

목록의 각 인수에 대 한 다음 규칙 인수에 할당 될 때까지 차례로 적용 됩니다. 인수는 레지스터에 할당 된 경우 모든 사용 되지 않는 비트 레지스터에 값을 지정 합니다. 인수는 스택 슬롯에 할당 되 면 사용 하지 않는 패딩 바이트 값을 지정 합니다.

1. 인수가 절반-, 단일, 이중-또는 쿼드 정밀도 부동 소수점 또는 짧은 벡터 형식 및는 NSRN 8 보다 작은 경우 인수 레지스터 v의 최하위 비트를 할당할\[NSRN]. NSRN 1 씩 증가 합니다. 이제 인수가 할당 되었습니다.

1. HFA 또는 HVA 인수는 충분 한 할당 되지 않은 SIMD 및 부동 소수점 레지스터 (NSRN + 멤버 ≤ 8 수)을 하는 경우에 인수 SIMD 및 부동 소수점 레지스터, HFA 또는 HVA 구성원 당 하나의 레지스터에 할당 됩니다. NSRN 사용 된 레지스터 수 만큼 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수는 HFA 또는 HVA 이면 NSRN를 8로 설정한 및 인수의 크기 8 바이트의 가장 근사한 배수로 반올림 됩니다.

1. HFA는 HVA 쿼드 정밀도 부동 소수점 또는 Short 벡터 형식 인수는 경우 NSAA 반올림은 8 또는 인수 형식의 자연 맞춤 중 더 큰 숫자입니다.

1. 인수 절반 또는 단 정밀도 부동 소수점 형식인 경우 인수의 크기는 8 바이트로 설정 됩니다. 결과 인수 처럼 복사 된 64 비트 레지스터의 최하위 비트를 채워지고 지정 되지 않은 값을 사용 하 여 나머지 비트.

1. 인수는 HFA 인 경우는 HVA 절반-, 단일, 이중 또는 쿼드 정밀도 부동 소수점 또는 짧은 벡터 형식 차례로 인수는 조정 된 NSAA에서 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

1. 인수가 정수 계열 또는 포인터 형식, 인수 크기가 8 바이트 보다 작거나 이며는 NGRN 8 보다 작으면에 인수 x에서 최하위 비트를에 복사 됩니다\[NGRN]. NGRN 1 씩 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수 16 맞춤 있으면 다음을 NGRN 반올림 됩니다 다음 짝수를 합니다.

1. 인수는 정수 계열 형식, 인수의 크기가 16, 같음 이며는 NGRN 7 미만 인수 x에 복사 됩니다\[NGRN] 및 x\[NGRN + 1]입니다. x\[NGRN]는 낮은 주소가 지정 된 double-단어가 포함 인수는 메모리 내 표현입니다. NGRN 2 씩 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수가 복합 형식이 및 2 배 워드 인수의 크기는 NGRN 뺀 값 8 개 이하의 경우 인수는 레지스터로 복사 연속 범용 x부터\[NGRN]. 메모리에서 연속 된 레지스터를 로드 하는 LDR 명령의 적절 한 순서를 사용 하 여 이중 단어 정렬 주소에서 레지스터에 로드 된 것 처럼 인수가 전달 됩니다. 이 표준에 따라 레지스터의 사용 되지 않는 모든 파트의 콘텐츠를 사용 하는 지정 되지 않았습니다. NGRN 사용 된 레지스터 수 만큼 증가 합니다. 이제 인수가 할당 되었습니다.

1. NGRN 8로 설정 됩니다.

1. NSAA 반올림은 8 또는 인수 형식의 자연 맞춤 중 더 큰 숫자입니다.

1. 인수가 복합 형식이 면 인수는 조정 된 NSAA에서 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

1. 인수의 크기가 8 바이트 보다 작은 경우 인수의 크기는 8 바이트로 설정 됩니다. 인수를 64 비트 레지스터의 최하위 비트를 복사 된 및 나머지 비트는 지정 되지 않은 값으로 채워 졌 던 것 처럼 됩니다.

1. 인수는 조정 된 NSAA에서 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

### <a name="addendum-variadic-functions"></a>추 록: Variadic 함수

가변 개수의 인수를 사용 하는 함수 다르게 처리 됩니다 보다 위에 다음과 같습니다.

1. 모든 복합 처리할지 동일 하 게 됩니다. HFAs 자산 또는 Hva의 특별 한 작업이 수행 되지 않습니다.

1. SIMD 및 부동 소수점 레지스터 사용 되지 않습니다.

효과적으로 다음 규칙 여기서 스택의 첫 번째 64 바이트 x0 x7, 로드 되 고 나머지 스택 인수가 일반적으로 배치 됩니다 허수 스택에 인수 할당 C.12–C.15 동일 않습니다.

## <a name="return-values"></a>반환 값

정수 계열 값 x0 반환 됩니다.

부동 소수점 값 s0/d0/v0 적절 하 게 반환 됩니다.

값으로 반환 된 형식의 특정 속성을 갖고 있는지 여부에 따라 다르게 처리 됩니다.

형식 지정 됩니다 "C" 반환 스타일 집계 경우 C + + 14 표준 정의입니다. 말하자면

- 사용자 제공 생성자 없음, 전용 또는 보호 된 비정적 데이터 멤버 없음, 기본 클래스가 없고, 및 가상 함수가 없고,
- trivial 복사 생성자를 갖고 및
- trivial 소멸자를 갖습니다.

다른 모든 형식 반환 "c + +" 스타일을 제공 됩니다.

### <a name="c-return-style"></a>C 반환 스타일

8 바이트 보다 작거나 x0에서 반환 되는 형식입니다.

16 바이트 보다 작거나 x0 및 하위 순서 8 바이트가 포함 된 x0 사용 하 여 x1, 반환 되는 형식입니다.

형식의 16 바이트 보다 큰 경우 호출자에 게 충분 한 크기 및 결과 저장 하는 맞춤의 메모리 블록을 예약 됩니다. 메모리 블록의 주소 x8 함수에 추가 인수로 전달할 됩니다. 호출 수신자는 서브루틴을 실행 하는 동안 언제 든 지 결과 메모리 블록을 수정할 수 있습니다. 호출 수신자 x8에 저장 된 값을 유지할 필요는 없습니다.

### <a name="c-return-style"></a>C + + 반환 스타일

호출자에 게 충분 한 크기 및 결과 저장 하는 맞춤의 메모리 블록을 예약 해야 합니다. $ X0에 전달 됩니다 하는 경우 메모리 블록의 주소를 x0, 또는 x1 함수에 추가 인수로 전달할 수 됩니다. 호출 수신자는 서브루틴을 실행 하는 동안 언제 든 지 결과 메모리 블록을 수정할 수 있습니다. 호출 수신자 x0에서 메모리 블록의 주소를 반환 합니다.

## <a name="stack"></a>스택

적용 하 여 ARM ABI 다음 스택을 유지 되어야 16 바이트 모든 시간에 정렬 합니다. AArch64 SP 16 바이트 정렬 아니며 SP 관련 부하 또는 스토어를 이루어집니다 때마다 스택 맞춤 오류를 생성 하는 하드웨어 기능을 포함 합니다. 항상 사용 하도록 설정 하는이 기능을 사용 하 여 Windows를 실행 합니다.

4k 이상의 가치가 스택 할당 하는 함수는 순서 대로 최종 페이지 이전의 각 페이지는 연결을 확인 해야 합니다. 이렇게 하면 코드가 없습니다 수 "leap 통해" Windows 스택을 확장을 사용 하는 가드 페이지입니다. 일반적으로 터치 하면 됩니다는 `__chkstk` x15 16로 나눈 값의 총 스택 할당을 전달 하는 사용자 지정 호출 규칙에는 도우미입니다.

## <a name="red-zone"></a>빨간색 영역

현재 스택 포인터 바로 아래는 16 바이트 영역은 분석에서 사용 하도록 예약 하 고 동적 시나리오를 패치 합니다. 이 영역에서 두 레지스터를 저장 하는 삽입할 신중 하 게 생성 된 코드를 허용 합니다. [sp, # 16] 일시적으로 임의의 목적으로 사용 합니다. Windows 커널은 사용자 및 커널 모드에서 예외 나 인터럽트가 수행 되 면 해당 16 바이트 덮어씀이 되지 않습니다 보장 합니다.

## <a name="kernel-stack"></a>커널 스택

Windows의 기본 커널 모드 스택은 6 개의 페이지 (24 k). 커널 모드에서 큰 스택 버퍼가 있는 함수에 특별히 주의 지불 합니다. Ill-timed 인터럽트 섬 함께 스택 비상 버그 검사를 만들 수 있습니다.

## <a name="stack-walking"></a>스택 워크

사용 하도록 설정 하는 프레임 포인터를 사용 하 여 Windows 내의 코드는 컴파일됩니다 ([/Oy-](reference/oy-frame-pointer-omission.md)) 빠른 스택 워크를 사용 하도록 설정 합니다. X29 (fp) {fp, lr}는 체인의 다음 링크를 가리키는 일반적으로 쌍을 나타내는 스택 및 반송 주소에 있는 이전 프레임에 대 한 포인터입니다. 향상 된 프로 파일링 및 추적 가능 하도록 프레임 포인터도 사용 하도록 설정 하려면 타사 코드를 사용 하는 것이 좋습니다.

## <a name="exception-unwinding"></a>예외 해제

예외 처리 하는 동안 해제는 해제 코드를 사용 하 여 지원 됩니다. 해제 코드는 실행 파일의.xdata 섹션에 저장 된 바이트의 시퀀스입니다. 호출자의 스택 프레임에 백업에 대 한 준비 과정에서 함수의 프롤로그의 결과 실행 취소할 수 있도록 프롤로그의 프롤로그 및 에필로그의 작동을 설명 합니다. 해제 코드에 대 한 자세한 내용은 참조 하세요. [ARM64 예외 처리](arm64-exception-handling.md)합니다.

또한 ARM EABI는 해제 코드를 사용 하는 예외 해제 모델을 지정 합니다. 그러나 사양 표시 되는 함수 프롤로그 또는 에필로그 중간 PC 인 경우를 처리 해야 하는 Windows의 해제에 충분 하지 않습니다.

동적으로 생성 되는 코드를 통해 동적 함수 테이블을 사용 하 여 설명 되어야 하는 `RtlAddFunctionTable` 및 관련 함수에 생성된 된 코드는 예외 처리에 참여할 수 있도록 합니다.

## <a name="cycle-counter"></a>사이클 카운터

모든 ARMv8 Cpu 사이클 카운터를 지원 해야 Windows 사용자 모드를 포함 하 여 모든 예외 수준에서 읽을 수를 구성 하는 64 비트 레지스터를 등록 합니다. 특수 PMCCNTR_EL0 통해 액세스할 수 있습니다 MSR opcode를 사용 하 여 어셈블리 코드에를 등록 또는 `_ReadStatusReg` C/c + + 코드에서 내장 함수입니다.

여기에 사이클 카운터 벽 클록이 아닌 실제 사이클 카운터를 경우 계산 빈도 프로세서 빈도 따라 달라 집니다. 사이클 카운터의 빈도 알고 있어야 하는 것이 생각을 하는 경우 사이클 카운터를 사용 하지 않아야 합니다. 사용 해야 하는 벽 시계 시간을 측정 하려는 대신 `QueryPerformanceCounter`합니다.

## <a name="see-also"></a>참고자료

[일반적인 Visual C++ ARM 마이그레이션 문제](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 예외 처리](arm64-exception-handling.md)
