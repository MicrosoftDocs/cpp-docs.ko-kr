---
title: ARM64 ABI 규칙 개요
ms.date: 03/27/2019
ms.openlocfilehash: 07d58bbd64795235ad63a7b26b6f18fcffdcd1d2
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303264"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 규칙 개요

64 비트 모드 (ARMv8 이상 아키텍처)로 ARM 프로세서에서 컴파일되고 실행 되는 Windows 용 ABI (기본 응용 프로그램 이진 인터페이스)는 ARM의 표준 AArch64 EABI를 따릅니다. 이 문서에서는 몇 가지 주요 가정과 EABI에 설명 된 항목의 변경 내용을 중점적으로 설명 합니다. 32 비트 ABI에 대 한 자세한 내용은 [ARM abi 규칙 개요](overview-of-arm-abi-conventions.md)를 참조 하세요. 표준 ARM EABI에 대 한 자세한 내용은 [ARM 아키텍처에 대 한 ABI (응용 프로그램 이진 인터페이스](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) ) (외부 링크)를 참조 하세요.

## <a name="definitions"></a>정의

ARM은 64 비트 지원을 도입 하 여 다음과 같은 여러 용어를 정의 했습니다.

- **AArch32** – ARM 모드 실행을 포함 하 여 ARM에서 정의한 레거시 32 비트 명령 집합 아키텍처 (ISA)입니다.
- **AArch64** – ARM에서 정의한 새 64 비트 명령 집합 아키텍처 (ISA)입니다.
- **ARMv7** – AArch32에 대 한 지원도 포함 하는 "7 세대" ARM 하드웨어의 사양입니다. 이 버전의 ARM 하드웨어는 ARM의 첫 번째 버전 Windows를 지원 합니다.
- **ARMv8** – AArch32 및 AArch64에 대 한 지원을 포함 하는 "8 세대" ARM 하드웨어의 사양입니다.

Windows는 다음과 같은 용어를 사용 하기도 합니다.

- **ARM** – AArch32 (32 비트 arm 아키텍처)를 나타냅니다 (Woa (WINDOWS on ARM) 라고도 함).
- **ARM32** – ARM과 동일 합니다. 명확성을 위해이 문서에서 사용 됩니다.
- **ARM64** – 64 비트 ARM 아키텍처 (AArch64)를 참조 합니다. WoA64와 같은 것은 아닙니다.

마지막으로 데이터 형식을 참조할 때 ARM의 다음 정의가 참조 됩니다.

- **Short vector** – 벡터에서 8 바이트 또는 16 바이트 분량의 요소로 직접 표현할 수 있는 데이터 형식입니다. 크기는 8 바이트 또는 16 바이트 크기에 맞춰져 있으며 각 요소는 1, 2, 4 또는 8 바이트가 될 수 있습니다.
- **HFA (동일한 부동 소수점 집계)** – 두 개에서 4 개의 동일한 부동 소수점 멤버 (float 또는 double)를 포함 하는 데이터 형식입니다.
- **Hva (같은 짧은 벡터 집계)** – 2-4 개의 동일한 short vector 멤버를 포함 하는 데이터 형식입니다.

## <a name="base-requirements"></a>기본 요구 사항

ARM64 버전의 Windows presupposes는 항상 ARMv8 이상 아키텍처에서 실행 되 고 있습니다. 부동 소수점 및 NEON 지원은 모두 하드웨어에 존재 하는 것으로 간주 됩니다.

ARMv8 사양은 AArch32 및 AArch64에 대 한 새로운 선택적인 crypto 및 CRC 도우미 opcode를 설명 합니다. 이에 대 한 지원은 현재 선택 사항 이지만 권장 됩니다. 이러한 opcode를 활용 하기 위해 앱은 먼저 런타임이 존재 하는지 확인 해야 합니다.

## <a name="endianness"></a>endian

Windows ARM32 버전의 경우와 마찬가지로 ARM64 Windows는 거의 endian 모드로 실행 됩니다. Endian를 전환 하는 것은 AArch64에서 커널 모드를 지원 하지 않기 때문에 적용 하기가 더 쉽습니다.

## <a name="alignment"></a>맞춤

ARM64에서 실행 되는 Windows를 사용 하면 CPU 하드웨어가 잘못 된 액세스를 투명 하 게 처리할 수 있습니다. AArch32의 향상 된 기능을 통해이 지원은 다중 단어 액세스를 비롯 한 모든 정수 액세스와 부동 소수점 액세스에도 적용 됩니다.

그러나 캐시 되지 않은 (장치) 메모리에 대 한 액세스는 여전히 항상 정렬 되어야 합니다. 코드에서 캐시 되지 않은 메모리의 불일치 데이터를 읽거나 쓸 수 있는 경우 모든 액세스를 맞춰야 합니다.

지역에 대 한 기본 레이아웃 맞춤:

| 크기(바이트) | 맞춤 (바이트) |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3, 4 | 4 |
| > 4 | 8 |

Globals 및 정적의 기본 레이아웃 맞춤:

| 크기(바이트) | 맞춤 (바이트) |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| >= 64 | 16 |

## <a name="integer-registers"></a>정수 레지스터

AArch64 아키텍처는 32 정수 레지스터를 지원 합니다.

| 레지스터 | 휘발성 여부 | Role |
| - | - | - |
| x0 | 일시적 | 매개 변수/스크래치 레지스터 1, 결과 등록 |
| x1-x7 | 일시적 | 매개 변수/스크래치 레지스터 2-8 |
| x8-x15 | 일시적 | 스크래치 레지스터 |
| x16-x17 | 일시적 | 프로시저 내-호출 스크래치 레지스터 |
| x18 | 비휘발성 | Platform register: 커널 모드에서 현재 프로세서의 KPCR을 가리킵니다. 사용자 모드에서 TEB를 가리킵니다. |
| x19-x28 | 비휘발성 | 스크래치 레지스터 |
| x29/fp | 비휘발성 | 프레임 포인터 |
| x30/lr | 비휘발성 | 레지스터 링크 |

각 레지스터는 전체 64 비트 값 (x0-x30을 통해) 또는 32 비트 값 (w0-w30를 통해)으로 액세스할 수 있습니다. 32 비트 작업 0-결과를 최대 64 비트로 확장 합니다.

매개 변수 레지스터 사용에 대 한 자세한 내용은 매개 변수 전달 섹션을 참조 하세요.

AArch32와 달리 프로그램 카운터 (PC)와 스택 포인터 (SP)는 인덱싱되지 않은 레지스터입니다. 이러한 사용자는 액세스할 수 있는 방법으로 제한 됩니다. X31 레지스터가 없다는 점에 유의 해야 합니다. 이러한 인코딩은 특수 한 용도로 사용 됩니다.

X29 (프레임 포인터)는 ETW 및 기타 서비스에서 사용 하는 빠른 스택 워크와의 호환성을 위해 필요 합니다. 스택의 이전 {x29, x30} 쌍을 가리켜야 합니다.

## <a name="floating-pointsimd-registers"></a>부동 소수점/SIMD 레지스터

AArch64 아키텍처는 아래에 요약 된 32 부동 소수점/SIMD 레지스터도 지원 합니다.

| 레지스터 | 휘발성 여부 | Role |
| - | - | - |
| v0 | 일시적 | 매개 변수/스크래치 레지스터 1, 결과 등록 |
| v1-v7 | 일시적 | 매개 변수/스크래치 레지스터 2-8 |
| v8-v15 | 비휘발성 | 스크래치 레지스터 (낮은 64 비트만 비휘발성) |
| v16-v31 | 일시적 | 스크래치 레지스터 |

각 레지스터는 전체 128 비트 값 (v0-v31 또는 q0-q31를 통해)으로 액세스할 수 있습니다. 64 비트 값 (d31을 통해), 32 비트 값 (s31), 16 비트 값 (h0-h31) 또는 8 비트 값 (b0-b31를 통해)으로 액세스할 수 있습니다. 128 비트 보다 작은 액세스는 전체 128 비트 레지스터의 하위 비트에만 액세스 합니다. 달리 지정 하지 않는 한 나머지 비트는 그대로 둡니다. AArch64는 더 작은 레지스터가 큰 레지스터 위에 압축 된 AArch32와 다릅니다.

FPCR (부동 소수점 제어 레지스터)에는 it 내의 다양 한 비트 필드에 대 한 특정 요구 사항이 있습니다.

| 비트 | 의미 | 휘발성 여부 | Role |
| - | - | - | - |
| 26 | AHP | 비휘발성 | 대체 반 정밀도 컨트롤입니다. |
| 25 | DN | 비휘발성 | 기본 NaN 모드 컨트롤입니다. |
| 24 | FZ | 비휘발성 | 0에서 플러시 모드로의 컨트롤입니다. |
| 23-22 | RMode | 비휘발성 | 반올림 모드 컨트롤입니다. |
| 15, 12-8 | IDE/IXE/etc | 비휘발성 | 예외 트랩 사용 비트는 항상 0 이어야 합니다. |

## <a name="system-registers"></a>시스템 레지스터

AArch32와 마찬가지로 AArch64 사양에서는 세 가지 시스템 제어 "스레드 ID" 레지스터를 제공 합니다.

| 레지스터 | Role |
| - | - |
| TPIDR_EL0 | 예약됨. |
| TPIDRRO_EL0 | 현재 프로세서의 CPU 번호를 포함 합니다. |
| TPIDR_EL1 | 현재 프로세서의 KPCR 구조를 가리킵니다. |

## <a name="floating-point-exceptions"></a>부동 소수점 예외

IEEE 부동 소수점 예외에 대 한 지원은 AArch64 시스템에서 선택 사항입니다. 하드웨어 부동 소수점 예외를 포함 하는 프로세서 변형의 경우 Windows 커널은 자동으로 예외를 catch 하 고 FPCR 레지스터에서 예외를 암시적으로 사용 하지 않도록 설정 합니다. 이 트랩은 프로세서 변형에서 표준화 된 동작을 보장 합니다. 그렇지 않으면, 예외를 지원 하지 않는 플랫폼에서 개발한 코드는 지원 되는 플랫폼에서 실행 될 때 예기치 않은 예외가 발생 하는 것을 알 수 있습니다.

## <a name="parameter-passing"></a>매개 변수 전달

Variadic 함수의 경우 Windows ABI는 매개 변수 전달에 ARM으로 지정 된 규칙을 따릅니다. 이러한 규칙은 AArch64 아키텍처에 대 한 프로시저 호출 표준에서 직접 발췌 한 것 됩니다.

### <a name="stage-a--initialization"></a>단계 A-초기화

이 단계는 인수 처리가 시작 되기 전에 정확히 한 번만 수행 됩니다.

1. 다음 일반 용도의 레지스터 번호 (NGRN)는 0으로 설정 됩니다.

1. 다음 SIMD와 부동 소수점 레지스터 번호 (NSRN)가 0으로 설정 되어 있습니다.

1. 다음 누적 인수 주소 (NSAA)는 현재 스택 포인터 값 (SP)으로 설정 됩니다.

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>B 단계 – 인수 미리 채우기 및 확장

목록의 각 인수에 대해 다음 목록의 첫 번째 일치 규칙이 적용 됩니다. 일치 하는 규칙이 없는 경우 인수는 수정 되지 않은 상태로 사용 됩니다.

1. 인수 형식이 호출자와 호출 수신자 둘 다에서 정적으로 결정 될 수 없는 복합 형식이 면 인수는 메모리에 복사 되 고 인수는 복사본에 대 한 포인터로 바뀝니다. C/C++ 에는 이러한 형식이 없지만 다른 언어나 언어 확장에 존재 합니다.

1. 인수 형식이 HFA 또는 HVA 인 경우 인수는 수정 되지 않은 상태로 사용 됩니다.

1. 인수 형식이 16 바이트 보다 큰 복합 형식이 면 인수는 호출자가 할당 한 메모리에 복사 되 고 인수는 복사본에 대 한 포인터로 바뀝니다.

1. 인수 형식이 복합 형식이 면 인수의 크기는 8 바이트의 가장 가까운 배수로 반올림 됩니다.

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>C 단계 – 레지스터 및 스택에 인수 할당

목록의 각 인수에 대해 다음 규칙은 인수가 할당 될 때까지 차례로 적용 됩니다. 인수가 레지스터에 할당 되 면 레지스터에서 사용 되지 않는 모든 비트가 지정 되지 않은 값을 갖습니다. 인수가 스택 슬롯에 할당 되 면 사용 되지 않는 패딩 바이트의 값이 지정 되지 않습니다.

1. 인수가 1/2, 1, 2 또는 4 정밀도 부동 소수점 또는 Short Vector 형식이 고 NSRN이 8 보다 작은 경우 인수는 레지스터 v\[NSRN]의 최하위 비트에 할당 됩니다. NSRN은 1 씩 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수가 HFA 또는 HVA이 고 할당 되지 않은 SIMD와 부동 소수점 레지스터가 있는 경우 (NSRN + 멤버 수가 8 개를 초과 하는 경우), 인수는 HFA 또는 HVA의 멤버 당 하나의 레지스터 인 SIMD 및 부동 소수점 레지스터에 할당 됩니다. NSRN은 사용 된 레지스터 수 만큼 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수가 HFA 또는 HVA 이면 NSRN이 8로 설정 되 고 인수의 크기가 가장 가까운 8 바이트의 배수로 반올림 됩니다.

1. 인수가 HFA, HVA, 쿼드 정밀도 부동 소수점 또는 Short Vector 형식인 경우 NSAA는 8의 큰 값 또는 인수 형식의 자연 맞춤으로 반올림 됩니다.

1. 인수가 1/2 또는 단 정밀도 부동 소수점 형식이 면 인수의 크기가 8 바이트로 설정 됩니다. 이는 인수가 64 비트 레지스터의 최하위 비트에 복사 되 고 나머지 비트가 지정 되지 않은 값으로 채워진 경우와 같습니다.

1. 인수가 HFA, HVA, 반, 1, 2 또는 쿼드 정밀도 부동 소수점 또는 Short 벡터 형식인 경우 인수는 조정 된 NSAA 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

1. 인수가 정수 계열 또는 포인터 형식이 면 인수의 크기가 8 바이트 보다 작거나 같고 NGRN이 8 보다 작은 경우에는 인수가 x\[NGRN]의 최하위 비트에 복사 됩니다. NGRN은 1 씩 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수에 맞춤이 16 인 경우 NGRN은 다음 짝수 수로 반올림 됩니다.

1. 인수가 정수 계열 형식이 면 인수의 크기는 16이 고 NGRN은 7 보다 작으므로 인수가 x\[NGRN] 및 x\[NGRN + 1]에 복사 됩니다. x\[NGRN]은 인수의 메모리 표현에 대 한 하위 주소가 지정 된 두 번째 단어를 포함 해야 합니다. NGRN은 2 씩 증가 합니다. 이제 인수가 할당 되었습니다.

1. 인수가 복합 형식이 고 인수의 두 단어로 된 크기가 8에서 n을 뺀 값 보다 큰 경우 인수는 x\[NGRN]에서 시작 하는 연속 된 범용 레지스터에 복사 됩니다. 인수는 이중 단어 맞춤 주소에서 레지스터로 로드 된 것으로 전달 되 고 메모리에서 연속 레지스터를 로드 하는 적절 한 LDR 명령 시퀀스를 사용 하 여 전달 됩니다. 이 표준에서는 레지스터의 사용 되지 않는 부분에 대 한 콘텐츠를 지정 하지 않습니다. NGRN은 사용 된 레지스터 수 만큼 증가 합니다. 이제 인수가 할당 되었습니다.

1. NGRN은 8로 설정 됩니다.

1. NSAA는 8의 큰 값 또는 인수 형식의 자연 맞춤으로 반올림 됩니다.

1. 인수가 복합 형식이 면 인수가 조정 된 NSAA 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

1. 인수의 크기가 8 바이트 보다 작은 경우에는 인수의 크기가 8 바이트로 설정 됩니다. 이는 인수가 64 비트 레지스터의 최하위 비트에 복사 되 고 나머지 비트가 지정 되지 않은 값으로 채워진 경우와 같습니다.

1. 인수가 조정 된 NSAA 메모리에 복사 됩니다. NSAA는 인수 크기만큼 증분됩니다. 이제 인수가 할당 되었습니다.

### <a name="addendum-variadic-functions"></a>추 록: Variadic 함수

가변적인 개수의 인수를 사용 하는 함수는 다음과 같이 위와 다르게 처리 됩니다.

1. 모든 합성은 동일 하 게 처리 됩니다. HFAs 또는 HVAs를 특별 하 게 처리 하지 않습니다.

1. SIMD와 부동 소수점 레지스터가 사용 되지 않습니다.

실제로 스택의 처음 64 바이트는 x0-120로 로드 되 고 나머지 스택 인수는 정상적으로 배치 되는 허수부 스택에 인수를 할당 하는 경우와 동일 합니다.

## <a name="return-values"></a>반환 값

정수 계열 값은 x0에서 반환 됩니다.

부동 소수점 값은 적절 하 게 s0, d0 또는 v0에서 반환 됩니다.

HFA 및 HVA 값은 적절 하 게 s0-s3, d0-d3 또는 v0로 반환 됩니다.

값으로 반환 되는 형식은 특정 속성이 있는지 여부에 따라 다르게 처리 됩니다. 이러한 속성을 모두 포함 하는 형식

- c + + 14 표준 정의를 기준으로 *집계* 됩니다. 즉, 사용자 제공 생성자, 전용 또는 보호 된 비정적 데이터 멤버가 없고, 기본 클래스가 없고, 가상 함수가 없습니다.
- 여기에는 trivial 복사 할당 연산자가 있습니다.
- 간단한 소멸자가 있습니다.

다음 반환 스타일을 사용 합니다.

- 8 바이트 보다 작거나 같은 형식이 x0에 반환 됩니다.
- 16 바이트 보다 작거나 같은 형식은 x0 및 x1에서 반환 되 고 x0은 하위 8 바이트를 포함 합니다.
- 16 바이트를 초과 하는 형식의 경우 호출자는 결과를 저장 하기에 충분 한 크기 및 맞춤의 메모리 블록을 예약 해야 합니다. 메모리 블록의 주소는 x8의 함수에 추가 인수로 전달 됩니다. 호출 수신자는 서브루틴을 실행 하는 동안 언제 든 지 결과 메모리 블록을 수정할 수 있습니다. 호출 수신자는 x8에 저장 된 값을 유지 하는 데 필요 하지 않습니다.

다른 모든 형식은 다음 규칙을 사용 합니다.

- 호출자는 결과를 저장 하기에 충분 한 크기 및 맞춤의 메모리 블록을 예약 해야 합니다. 메모리 블록의 주소는 x0의 함수에 추가 인수로 전달 되거나 $this가 x0에 전달 되는 경우 x1으로 전달 됩니다. 호출 수신자는 서브루틴을 실행 하는 동안 언제 든 지 결과 메모리 블록을 수정할 수 있습니다. 호출 수신자는 x0에서 메모리 블록의 주소를 반환 합니다.

## <a name="stack"></a>스택

ARM에 대 한 ABI를 따라 스택은 항상 16 바이트로 정렬 된 상태로 유지 되어야 합니다. AArch64에는 SP가 16 바이트로 정렬 되지 않고 SP 상대 로드 나 저장소를 완료할 때마다 스택 맞춤 오류를 생성 하는 하드웨어 기능이 포함 되어 있습니다. Windows는이 기능을 항상 사용 하도록 설정 하 여 실행 합니다.

4k 이상의 스택을 할당 하는 함수는 최종 페이지 이전의 각 페이지가 순서 대로 처리 되는지 확인 해야 합니다. 이 작업을 수행 하면 Windows에서 스택을 확장 하는 데 사용 하는 가드 페이지를 코드에서 "leap" 할 수 없습니다. 일반적으로 접촉은 x15에서 16으로 나눈 총 스택 할당을 전달 하는 사용자 지정 호출 규칙을 포함 하는 `__chkstk` 도우미에 의해 수행 됩니다.

## <a name="red-zone"></a>빨간색 영역

현재 스택 포인터 바로 아래에 있는 16 바이트 영역은 분석 및 동적 패치 시나리오에 사용 하도록 예약 되어 있습니다. 이 영역에서는 두 레지스터를 [sp, #-16]에 저장 하는 코드를 삽입 하는 신중한 생성을 허용 하 고, 임의의 용도에 일시적으로 사용 합니다. Windows 커널은 사용자 및 커널 모드 모두에서 예외 또는 인터럽트가 수행 될 경우 16 바이트를 덮어쓰지 않도록 보장 합니다.

## <a name="kernel-stack"></a>커널 스택

Windows의 기본 커널 모드 스택은 6 페이지 (24k)입니다. 커널 모드에서 대형 스택 버퍼를 사용 하는 함수에 특히 주의를 기울여야 합니다. 시간이 잘못 지정 된 인터럽트는 작은 공간으로 제공 될 수 있으며 스택 비상 버그 확인을 만들 수 있습니다.

## <a name="stack-walking"></a>스택 워크

빠른 스택 워크를 사용할 수 있도록 Windows 내의 코드는 프레임 포인터 사용 ([/Oy-](reference/oy-frame-pointer-omission.md))으로 컴파일됩니다. 일반적으로 x29 (fp)는 체인에서 이전 프레임에 대 한 포인터와 반환 주소를 나타내는 {fp, lr} 쌍의 다음 링크를 가리킵니다. 타사 코드는 향상 된 프로 파일링 및 추적을 허용 하기 위해 프레임 포인터를 사용 하도록 설정 하는 것이 좋습니다.

## <a name="exception-unwinding"></a>예외 해제

예외 처리 중 해제는 해제 코드를 사용 하 여 지원 됩니다. 해제 코드는 실행 파일의 .xdata 섹션에 저장 되는 바이트 시퀀스입니다. 이는 함수 프롤로그의 효과를 실행 취소 하 여 호출자의 스택 프레임에 대 한 백업 준비를 수행할 수 있도록 하는 추상 방식으로 프롤로그 및 에필로그의 작업을 설명 합니다. 해제 코드에 대 한 자세한 내용은 [ARM64 exception 처리](arm64-exception-handling.md)를 참조 하세요.

ARM EABI는 해제 코드를 사용 하는 예외 해제 모델도 지정 합니다. 그러나 표시 된 것 처럼 Windows에서 해제 하는 데 충분 하지 않습니다 .이 사양은 PC가 함수 프롤로그 또는 에필로그의 중간에 있는 경우를 처리 해야 합니다.

동적으로 생성 되는 코드는 생성 된 코드가 예외 처리에 참여할 수 있도록 `RtlAddFunctionTable` 및 관련 함수를 통해 동적 함수 테이블에 설명 되어야 합니다.

## <a name="cycle-counter"></a>Cycle 카운터

모든 ARMv8 Cpu는 Windows에서 사용자 모드를 비롯 한 모든 예외 수준에서 읽을 수 있도록 구성 하는 64 비트 레지스터 인 주기 카운터 레지스터를 지 원하는 데 필요 합니다. 이 파일은 특수 PMCCNTR_EL0 등록을 통해 액세스할 수 있으며, 어셈블리 코드에서 MSR opcode를 사용 하거나 C/C++ 코드의 `_ReadStatusReg` 내장 함수를 사용 하 여 액세스할 수 있습니다.

여기서 주기 카운터는 벽 클록이 아닌 진정한 주기 카운터입니다. 계산 빈도는 프로세서 빈도에 따라 달라 집니다. 주기 카운터의 빈도를 알고 있어야 하는 경우에는 cycle 카운터를 사용 하지 않아야 합니다. 대신 `QueryPerformanceCounter`를 사용 해야 하는 벽 시계 시간을 측정 하려고 합니다.

## <a name="see-also"></a>참고 항목

[일반적인 Visual C++ ARM 마이그레이션 문제](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 예외 처리](arm64-exception-handling.md)
