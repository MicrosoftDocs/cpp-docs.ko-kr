---
description: '자세한 정보: 프로필 기반 최적화'
title: 프로필 기반 최적화
ms.date: 04/23/2019
helpviewer_keywords:
- profile-guided optimizations
- optimization, profile-guided [C++]
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
ms.openlocfilehash: cd6a9627de72ef170e88493ef3e2147a0ccc2bc7
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/11/2020
ms.locfileid: "97187327"
---
# <a name="profile-guided-optimizations"></a>프로필 기반 최적화

최적화 프로그램이 .exe 또는 .dll 파일의 테스트 실행 데이터를 사용하는 PGO(프로필 기반 최적화)를 사용하면 전체 실행 파일을 최적화할 수 있습니다. 데이터는 프로덕션 환경에서 예상되는 프로그램의 성능을 나타냅니다.

프로필 기반 최적화는 x86 또는 x64 네이티브 대상에서만 사용할 수 있습니다. 프로필 기반 최적화는 공용 언어 런타임에서 실행되는 실행 파일에 사용할 수 없습니다. 네이티브 코드와 관리 코드가 혼합된 어셈블리를 생성( **/clr** 컴파일러 옵션 사용)하는 경우에도 네이티브 코드에서만 프로필 기반 최적화를 사용할 수 없습니다. IDE에서 관련 옵션 설정을 사용하여 프로젝트를 빌드하려고 하면 빌드 오류가 발생합니다.

> [!NOTE]
> 프로파일링 테스트 실행에서 수집되는 정보는 **/Ob**, **/Os** 또는 **/Ot** 를 지정하는 경우 적용되는 최적화를 재정의합니다. 자세한 내용은 [/Ob(인라인 함수 확장)](reference/ob-inline-function-expansion.md) 및 [/Os, /OT(크기 우선 코드, 속도 우선 코드)](reference/os-ot-favor-small-code-favor-fast-code.md)를 참조하세요.

## <a name="steps-to-optimize-your-app"></a>앱을 최적화하는 단계

프로필 기반 최적화를 사용하려면 다음 단계에 따라 앱을 최적화합니다.

- [/GL](reference/gl-whole-program-optimization.md)을 사용하여 하나 이상이 소스 코드 파일을 컴파일합니다.

   프로필 기반 최적화 테스트 실행 중 **/GL** 로 빌드된 각 모듈을 검사하여 런타임 동작을 캡처할 수 있습니다. 프로필 기반 최적화 빌드의 모든 모듈을 **/GL** 로 컴파일할 필요가 없습니다. 그러나 **/GL** 을 사용하여 컴파일한 모듈만 계측되어 나중에 프로필 기반 최적화에 사용할 수 있습니다.

- [/LTCG](reference/ltcg-link-time-code-generation.md) 및 [/GENPROFILE 또는 /FASTGENPROFILE](reference/genprofile-fastgenprofile-generate-profiling-instrumented-build.md)을 사용하여 연결합니다.

   **/LTCG** 와 **/GENPROFILE** 또는 **/FASTGENPROFILE** 를 모두 사용하면 계측된 앱이 실행될 때 `.pgd` 파일이 만들어집니다. 테스트 실행 데이터가 `.pgd` 파일에 추가된 후에는 다음 연결 단계(최적화된 이미지 만들기)에 대한 입력으로 사용할 수 있습니다. **/GENPROFILE** 을 지정할 경우 필요에 따라 **PGD=** _filename_ 인수를 추가하여 `.pgd` 파일의 기본값이 아닌 이름이나 위치를 지정할 수 있습니다. **/LTCG** 와 **/GENPROFILE** 또는 **/FASTGENPROFILE** 링커 옵션의 조합이 사용되지 않는 **/LTCG:PGINSTRUMENT** 링커 옵션을 대체합니다.

- 애플리케이션을 프로파일링합니다.

   프로파일링된 EXE 세션이 종료되거나 프로파일링된 DLL이 언로드될 때마다 `appname!N.pgc` 파일이 만들어집니다. `.pgc` 파일에는 특정 애플리케이션 테스트 실행에 대한 정보가 포함됩니다. *appname* 은 앱 이름이고 *N* 은 1부터 시작하는 숫자이며 디렉터리에 있는 다른 `appname!N.pgc` 파일 수에 따라 증가합니다. 테스트 실행이 최적화하려는 시나리오를 나타내지 않는 경우 `.pgc` 파일을 삭제할 수 있습니다.

   테스트 실행 중에는 [pgosweep](pgosweep.md) 유틸리티를 사용하여 현재 열려 있는 `.pgc` 파일 닫기와 새 `.pgc` 파일 만들기를 강제로 수행할 수 있습니다(예: 테스트 시나리오의 끝이 애플리케이션 종료와 일치하지 않는 경우).

   애플리케이션에서 PGO 함수 [PgoAutoSweep](pgoautosweep.md)를 직접 호출하여 호출 시점에 프로필 데이터를 `.pgc` 파일로 캡처할 수도 있습니다. 이렇게 하면 `.pgc` 파일에 캡처된 데이터가 적용되는 코드를 더욱 세밀하게 제어할 수 있습니다. 이 함수를 사용하는 방법의 예제는 [PgoAutoSweep](pgoautosweep.md) 설명서를 참조하세요.

   계측된 빌드를 만들 때 기본적으로 데이터 수집은 스레드로부터 안전하지 않은 모드로 수행되며, 이 모드는 더 빠르지만 정확하지 않을 수 있습니다. **/GENPROFILE** 또는 **/FASTGENPROFILE** 에 **EXACT** 인수를 사용하여 스레드로부터 안전한 모드로 데이터 수집을 지정할 수 있습니다. 이 경우 더 정확하지만 느립니다. 이 옵션은 계측된 빌드를 만들 때 사용되지 않는 [PogoSafeMode](environment-variables-for-profile-guided-optimizations.md#pogosafemode) 환경 변수나 사용되지 않는 **/POGOSAFEMODE** 링커 옵션을 설정한 경우에도 사용할 수 있습니다.

- **/LTCG** 및 **/USEPROFILE** 을 사용하여 연결합니다.

   **/LTCG** 및 [/USEPROFILE](reference/useprofile.md) 링커 옵션을 모두 사용하여 최적화된 이미지를 만듭니다. 이 단계에서는 입력으로 `.pgd` 파일을 사용합니다. **/USEPROFILE** 을 지정할 경우 필요에 따라 **PGD=** _filename_ 인수를 추가하여 `.pgd` 파일의 기본값이 아닌 이름이나 위치를 지정할 수 있습니다. 사용되지 않는 **/PGD** 링커 옵션을 사용하여 이 이름을 지정할 수도 있습니다. **/LTCG** 및 **/USEPROFILE** 의 조합은 사용되지 않는 **/LTCG:PGOPTIMIZE** 및 **/LTCG:PGUPDATE** 링커 옵션을 대체합니다.

최적화된 실행 파일을 만들고 나중에 더 최적화된 이미지를 만드는 데 추가 프로파일링이 유용한지를 확인할 수 있습니다. 계측된 이미지와 해당 `.pgd` 파일을 사용할 수 있는 경우 추가 테스트 실행을 수행하고 동일한 **/LTCG** 및 **/USEPROFILE** 링커 옵션을 사용하여 최신 `.pgd` 파일로 최적화된 이미지를 다시 빌드할 수 있습니다.

> [!NOTE]
> `.pgc` 및 `.pgd` 파일은 둘 다 이진 파일 형식입니다. 소스 제어 시스템에 저장된 경우 텍스트 파일에 적용될 수 있는 자동 변환을 수행하면 안 됩니다.

## <a name="optimizations-performed-by-pgo"></a>PGO에서 수행하는 최적화

프로필 기반 최적화에는 다음과 같은 검사와 개선 사항이 포함됩니다.

- **인라인 처리** – 예를 들어 함수 A가 함수 B를 자주 호출하고 함수 B는 상대적으로 작은 경우 프로필 기반 최적화에서는 함수 A에서 함수 B를 인라인 처리합니다.

- **가상 호출 추론** – 가상 호출 또는 함수 포인터를 통한 호출이 종종 특정 함수를 대상으로 하는 경우 프로필 기반 최적화에서 조건부로 실행되는 직접 호출을 자주 대상이 되는 함수에 추가하고 직접 호출은 인라인 처리할 수 있습니다.

- **레지스터 할당** – 프로필 데이터를 기반으로 최적화하면 레지스터 할당이 향상됩니다.

- **기본 블록 최적화** – 기본 블록 최적화를 사용하면 지정된 프레임 내에서 일시적으로 실행되는 자주 실행되는 기본 블록을 동일한 페이지 집합에 배치할 수 있습니다(지역). 따라서 사용되는 페이지 수가 최소화되므로 메모리 오버헤드도 최소화됩니다.

- **크기/속도 최적화** – 프로그램에서 가장 많이 실행하는 함수의 속도를 최적화할 수 있습니다.

- **함수 레이아웃** – 호출 그래프와 프로파일링된 호출자/호출 수신자 동작에 따라 동일한 실행 경로를 따르는 경향이 있는 함수가 동일한 섹션에 배치됩니다.

- **조건부 분기 최적화** - 값 프로브를 사용하여 프로필 기반 최적화에서 switch 문에 지정된 값이 다른 값보다 더 자주 사용되는지 확인할 수 있습니다.  그런 다음 switch 문에서 이 값을 끌어올 수 있습니다.  더 자주 true가 되는 블록에 따라 **`if`** 또는 **`else`** 블록이 먼저 배치되도록 최적화 프로그램에서 **`if`** ... **`else`** 의 순서를 지정할 수 있는 **`if`** ... **`else`** 명령을 사용하여 동일한 작업을 수행할 수 있습니다.

- **데드 코드 분리** – 프로파일링 중에 호출되지 않는 코드를 섹션 집합의 끝에 추가되는 특별한 섹션으로 이동합니다. 그러면 실질적으로 이 섹션이 자주 사용되는 페이지 외의 섹션으로 유지됩니다.

- **EH 코드 분리** - EH 코드는 예외적인 경우에만 실행되므로 종종 별도의 섹션으로 이동할 수 있습니다. 프로필 기반 최적화에서 예외가 예외적인 조건에서만 발생한다고 확인할 수 있으면 이동됩니다.

- **메모리 내장 함수** - 내장 함수를 확장할지 아닌지는 자주 호출되는지 여부에 달려 있습니다. 또한 내장 함수는 이동 또는 복사의 블록 크기에 따라 최적화할 수 있습니다.

## <a name="next-steps"></a>다음 단계

프로필 기반 최적화에 사용할 수 있는 다음과 같은 환경 변수, 함수 및 도구에 대해 자세히 알아보세요.

[프로필 기반 최적화 환경 변수](environment-variables-for-profile-guided-optimizations.md)<br/>
관련 변수는 테스트 시나리오의 런타임 동작을 지정하는 데 사용했습니다. 이제는 더 이상 사용되지 않으며 새 링커 옵션으로 바뀝니다. 이 문서에서는 환경 변수에서 링커 옵션으로 이동하는 방법을 보여 줍니다.

[PgoAutoSweep](pgoautosweep.md)<br/>
앱에 추가하여 `.pgc` 파일 데이터 캡처를 세밀하게 제어할 수 있는 함수입니다.

[pgosweep](pgosweep.md)<br/>
`.pgc` 파일에 모든 프로필 데이터를 기록하고 `.pgc` 파일을 닫고 새 `.pgc` 파일을 여는 명령줄 유틸리티입니다.

[pgomgr](pgomgr.md)<br/>
하나 이상의 `.pgc` 파일에서 프로필 데이터를 `.pgd` 파일에 추가하는 명령줄 유틸리티입니다.

[방법: 여러 개의 PGO 프로필을 단일 프로필로 병합](how-to-merge-multiple-pgo-profiles-into-a-single-profile.md)<br/>
**pgomgr** 사용법의 예입니다.

## <a name="see-also"></a>참조

[추가 MSVC 빌드 도구](reference/c-cpp-build-tools.md)
