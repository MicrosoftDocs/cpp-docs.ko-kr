---
title: 해제 절차 | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 82c5d0ca-70be-4d1a-a306-bfe01c29159f
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 5e2a5af5d8db5974aa10595bbd3bac1cd032a0f4
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/03/2018
---
# <a name="unwind-procedure"></a>해제 절차
해제 코드 배열은 내림차순으로 정렬 됩니다. 예외가 발생 하면 전체 컨텍스트가 컨텍스트 레코드에 운영 체제에 의해 저장 됩니다. 예외 디스패치 논리 호출 되를 예외 처리기를 찾으려면 다음 단계를 반복 해 서 실행 하는 합니다.  
  
1.  컨텍스트 레코드에 저장 된 현재 RIP를 사용 하 여 현재 함수 (또는 함수 부분에서는 연결 된 UNWIND_INFO 항목의 경우)에 대해 설명 하는 RUNTIME_FUNCTION 테이블 항목을 찾으려고 합니다.  
  
2.  없는 함수 테이블 항목이 발견 되는 리프 함수에는 다음 및 RSP 반환 포인터를 직접 처리 합니다. [Rsp] 반환 포인터는 업데이트 된 컨텍스트에 저장 됩니다, 시뮬레이션 된 RSP는 8, 씩 증가 및 1 단계를 반복 합니다.  
  
3.  함수 테이블 항목이 발견 되 면 에필로그에 a), b)에 프롤로그 또는 예외 처리기로 보호 되어야 하는 코드 c)에서 3 개의 영역 내에서 RIP을 상태로 남아 있을 수 있습니다.  
  
    -   사례는) 경우 RIP 에필로그 내에서 다음 함수 실행이 종료 된이 함수에 대 한이 예외와 관련 된 예외 처리기 있을 수 있고, 에필로그의 효과가 계산 컨텍스트는 호출자에 게 함수를 계속 해야 합니다. RIP 켜져 있는지 RIP에서 코드 스트림 에필로그 내에서 확인 하려면를 검사 합니다. 경우 해당 코드 스트림을 합법적인 에필로그의 뒤 부분에 일치 시킬 수 있습니다 및 에필로그에 에필로그의 나머지 부분을 시뮬레이션, 각 명령으로 업데이트 하는 컨텍스트 레코드 처리 됩니다. 그러면 1 단계를 반복 합니다.  
  
    -   사례 b) 제어 하지는 RIP 프롤로그 내에 있는 경우를 입력 해 함수,이 함수에 대 한이 예외와 관련 된 예외 처리기 있을 수는 프롤로그의 결과 계산 컨텍스트는 호출자에 게 함수를 실행 취소 해야 합니다. RIP은 프롤로그 내에서 경우에 함수 시작 까지의 거리 RIP 해제 정보에 인코딩된 프롤로그 크기 보다 작거나 합니다. 프롤로그의 결과 앞으로 오프셋으로 작은 보다 작거나 RIP 오프셋 함수 시작에서 첫 번째 항목에 대 한 해제 코드 배열을 통해 검색 한 다음 해제 코드 배열은에 나머지 모든 항목의 효과 실행 취소 하 여 해제 되었습니다. 1 단계를 반복 합니다.  
  
    -   사례 c) RIP 속하지 않을 경우 프롤로그 또는 에필로그와 함수에 예외 처리기 (UNW_FLAG_EHANDLER 설정 됨) 한 후 언어 특정 처리기가 호출 됩니다. 처리기의 데이터에 필터 함수를 적절 한 호출입니다. 언어별 처리기는 예외가 처리 되었는지 또는 검색은 계속 실행 되어야 하는 반환할 수 있습니다. 해제를 직접 시작할 수도 있습니다.  
  
4.  처리 상태를 반환 하는 언어별 처리기 실행을 계속할 경우 원래 컨텍스트 레코드를 사용 하 여 합니다.  
  
5.  언어별 처리기 없거나 "검색을 계속 합니다." 상태를 반환 하는 처리기를 컨텍스트 레코드 취소 해야 합니다는 호출자의 상태로 있습니다. 이 모든 결과를 각각 취소 해제 코드 배열 요소를 처리 하 여 수행 됩니다. 1 단계를 반복 합니다.  
  
 연결 되 면 해제와 같은 기본 단계는 계속 연결 정보 관련 됩니다. 유일한 차이점은 walking 해제 코드 배열은 배열의 끝에 도달 하면 프롤로그의 효과 해제 한 다음 연결할 부모 해제 정보 고 찾을 수는 전체 해제 코드 배열은 진행 된다는 점입니다. 이 연결 해제 정보 UNW_CHAINED_INFO 플래그 없이 도착 될 때까지 계속 및 해당 해제 코드 배열은 마칠 합니다.  
  
 최소한의 해제 데이터는 8 바이트입니다. 128 바이트의 스택을 이하로 할당 하 고 가능한 한 비휘발성 레지스터를 저장 하는 함수를 나타냅니다. 에이 크기는 연결 된 해제 정보 구조체 해제 코드가 없는와 길이가 0 인 프롤로그에 대 한 합니다.  
  
## <a name="see-also"></a>참고 항목  
 [예외 처리(x64)](../build/exception-handling-x64.md)