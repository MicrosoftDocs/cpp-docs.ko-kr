---
title: IEEE 부동 소수점 표시
ms.date: 05/06/2019
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: 47802a32d43824b4e568ca520c360dc7b12cbf8c
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231548"
---
# <a name="ieee-floating-point-representation"></a>IEEE 부동 소수점 표시

Microsoft C++(MSVC)는 IEEE 숫자 표준과 일치합니다. IEEE-754 표준에서는 하드웨어의 실수를 나타내는 한 방법인 부동 소수점 형식을 규정합니다. MSVC 컴파일러가 대상으로 하는 하드웨어에서 표현할 수 있는 부동 소수점 숫자에 대한 내부 형식은 적어도 5개입니다. 컴파일러는 이 가운데 2개만 사용합니다. *단정밀도*(4바이트) 및 *배정밀도*(8바이트) 형식이 MSVC에서 사용됩니다. 단정밀도는 **`float`** 키워드를 사용하여 선언됩니다. 배정밀도는 **`double`** 키워드를 사용하여 선언됩니다. 또한 IEEE 표준은 반정밀도(2바이트) 및 4배정밀도(16바이트) 형식뿐만 아니라 일부 C 및 C++ 컴파일러가 **`long double`** 데이터 형식으로 구현하는 확장 배정밀도(10바이트) 형식도 지정합니다. MSVC 컴파일러에서는 **`long double`** 데이터 형식이 고유 형식으로 처리되지만 스토리지 형식은 **`double`** 에 매핑됩니다. 그러나 하드웨어에서 지원되는 확장 배정밀도 형식을 포함하여 다른 형식을 사용하는 계산을 위한 내장 함수 및 어셈블리 언어 지원이 있습니다.

값은 다음과 같이 저장됩니다.

|값|저장|
|-----------|---------------|
|단정밀도(single-precision)|부호 비트, 8비트 지수, 23비트 유효 숫자|
|배정밀도|부호 비트, 11비트 지수, 52비트 유효 숫자|

단정밀도 및 배정밀도 형식에서는 소수 부분에 선행 1이 가정됩니다. 소수 부분을 유효 숫자라고 합니다(종종 가수라고도 함). 선행 1은 메모리에 저장되지 않으므로 1 미만 비트가 저장되더라도 유효 숫자는 실제로 24비트 또는 53비트입니다. 확장 배정밀도 형식은 실제로 이 비트를 저장합니다.

지수는 가능한 값의 절반으로 바이어스됩니다. 즉, 저장된 지수에서 이 바이어스를 빼서 실제 지수를 가져옵니다. 저장된 지수가 바이어스보다 작으면 실제로는 음의 지수입니다.

지수는 다음과 같이 바이어스됩니다.

|지수|바이어스|
|--------------|---------------|
|8비트(단정밀도)|127|
|11비트(배정밀도)|1023|

이러한 지수는 10의 거듭제곱이 아니라 2의 거듭제곱입니다. 즉, 저장된 8비트 지수는 -127에서 127 사이이고 0에서 254 사이로 저장됩니다. 값 2<sup>127</sup>은 대략 단정밀도의 실제 제한인 10<sup>38</sup>에 해당합니다.

유효 숫자는 1.XXX... 형식의 이진 소수로 저장됩니다. 이 소수는 1보다 크거나 같고 2보다 작은 값을 가집니다. 실수는 항상 정규화된 형식에 저장됩니다. 즉, 유효 숫자의 상위 비트가 항상 1이 되도록 유효 숫자가 왼쪽으로 이동됩니다. 이 비트는 항상 1이므로 단정밀도 및 배정밀도 형식에서는 가정됩니다(저장되지 않음). 이진(십진 아님) 소수점은 선행 1의 오른쪽에 있는 것으로 간주됩니다.

부동 소수점 표현 형식은 다음과 같습니다.

|서식|바이트 1|바이트 2|바이트 3|바이트 4|...|바이트 n|
|------------|------------|------------|------------|------------|---------|------------|
|단정밀도(single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|배정밀도|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S`는 부호 비트를 나타내고, `X`는 바이어스된 지수 비트이며, `M`은 유효 숫자 비트입니다. 단정밀도 및 배정밀도 형식에서는 가장 왼쪽 비트가 가정됩니다.

이진 소수점을 올바로 이동하려면 먼저 지수에서 바이어스를 제거한 다음 이진 소수점을 적절한 비트 수만큼 오른쪽 또는 왼쪽으로 이동합니다.

## <a name="special-values"></a>특수 값

부동 소수점 형식에는 특수하게 처리되는 일부 값이 포함됩니다.

### <a name="zero"></a>0

0은 정규화할 수 없습니다. 그러므로 단정밀도 또는 배정밀도 값의 정규화된 형식에서는 표현할 수 없습니다. 모든 0의 특수 비트 패턴은 0을 나타냅니다. 부호 비트가 설정된 상태에서 -0을 0으로 나타낼 수도 있지만, -0과 0은 항상 같음으로 비교됩니다.

### <a name="infinities"></a>무한대

+∞ 및 -∞ 값은 모두 1인 지수와 모두 0인 유효 숫자로 표시됩니다. 양수 및 음수는 부호 비트를 사용하여 표시됩니다.

### <a name="subnormals"></a>준정규 숫자

정규화된 형식의 가장 작은 숫자보다 작은 크기의 숫자를 나타낼 수 있습니다. 이러한 숫자를 준정규 또는 비정규 숫자라고 합니다. 지수가 모두 0이고 유효 숫자가 0이 아닌 경우 유효 숫자의 암시적 선행 비트는 1이 아닌 0으로 간주됩니다. 유효 숫자의 선행 0 수가 증가할수록 준정규 숫자의 전체 자릿수는 감소합니다.

### <a name="nan---not-a-number"></a>NaN - 숫자가 아님

IEEE 부동 소수점 형식으로 0/0과 같이 실수가 아닌 값을 나타낼 수 있습니다. 이러한 종류의 값을  NaN이라고 합니다. NaN은 모두 1인 지수와 0이 아닌 유효 숫자로 표시됩니다. NaN에는  자동 NaN(QNaN)과  신호 NaN(SNaN)의 두 종류가 있습니다. 자동 NaN은 유효 숫자에 선행 1이 있으며, 식을 통해 전파됩니다. 무한대로 나눈 결과 또는 무한대에 0을 곱한 결과와 같이 확정되지 않은 값을 나타냅니다. 신호 NaN에는 유효 숫자에 선행 0이 있습니다. 이들은 부동 소수점 하드웨어 예외를 알리기 위해 유효하지 않은 연산에 사용됩니다.

## <a name="examples"></a>예

다음은 단정밀도 형식의 몇 가지 예입니다.

- 값 2의 경우 부호 비트는 0입니다. 저장된 지수는 128 또는 이진수 1000 0000(127 + 1)입니다. 저장된 이진 유효 숫자는 (1)입니다. 000 0000 0000 0000 0000 0000은 암시된 선행 1과 이진 소수점을 포함하므로 실제 유효 숫자는 1입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 값 -2. 부호 비트가 설정된 것을 제외하고 +2와 동일합니다. 모든 IEEE 형식 부동 소수점 숫자의 음수도 마찬가지입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 값 4. 유효 숫자는 동일하고, 지수는 1씩 늘어나고, 바이어스 값은 129 또는 100 0000 1(이진)입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 값 6. 지수는 동일하고, 유효 숫자는 절반이 큰 (1)입니다. 100 0000 ... 0000 0000, 즉 이진 소수이기 때문에 1 1/2입니다(소수 자릿수의 값은 1/2, 1/4, 1/8 등이므로).

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 값 1. 유효 숫자가 다른 2의 거듭제곱과 동일하고, 바이어스된 지수는 127 또는 011 1111 1(이진)에서 2보다 작은 1입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 값 0.75. 바이어스된 지수는 126 또는 011 1111 0(이진)이고 유효 숫자는 (1)입니다. 100 0000 ... 0000 0000, 즉 1 1/2입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 값 2.5. 유효 숫자에서 1/4을 나타내는 비트가 설정된다는 점을 제외하고는 2와 정확히 동일합니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10은 반복되는 소수(이진)입니다. 유효 숫자는 1.6보다 작은 값이고, 바이어스된 지수는 1.6을 16으로 나눌 수 있음을 의미합니다. (이진으로 011 1101 1이며, 10진으로 123입니다.) 실제 지수는 123 - 127 = -4입니다. 즉, 곱할 계수는 2<sup>-4</sup> = 1/16입니다. 저장된 유효 숫자는 마지막 비트에서 반올림됩니다. 이는 표현할 수 없는 숫자를 가능한 한 정확하게 표현하려는 시도입니다. (1/10 및 1/100을 이진으로 정확하게 표현할 수 없는 이유는 1/3을 10진으로 정확하게 표현할 수 없는 이유와 비슷합니다.)

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 0은 특수한 경우로, 표현할 수 있는 양의 최소값에 대한 수식을 사용합니다(모두 0).

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>참조

[부동 소수점 숫자의 정밀도가 떨어지는 이유](why-floating-point-numbers-may-lose-precision.md)
