---
title: IEEE 부동 소수점 표시
ms.date: 11/04/2016
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: 69686e7e1c8994b799607eebf7e50387ed688272
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62188836"
---
# <a name="ieee-floating-point-representation"></a>IEEE 부동 소수점 표시

Microsoft Visual C++ IEEE 숫자 표준과 일치 됩니다. IEEE-754 표준 부동 소수점 형식을으로 하드웨어의 실제 숫자를 나타내는 방법을 설명 합니다. MSVC 컴파일러에 의해 대상으로 하는 하드웨어에서 표현할 수 있는 부동 소수점 숫자에 대 한 최소 5 개의 내부 형식 있지만 그 중 두 개는 컴파일러만 사용 합니다. 합니다 *정밀도* (4 바이트) 및 *배정밀도* 시각적 개체에 사용 되는 형식 (8 바이트) C++. 단 정밀도 키워드를 사용 하 여 선언 됩니다 **float**합니다. 배정밀도 키워드를 사용 하 여 선언 됩니다 **이중**합니다. IEEE 표준도 지정 *반 정밀도* (2 바이트) 및 *네 번 자릿수* (16 바이트) 형식으로 뿐만 *배정밀 확장도* (10 바이트) 형식으로 일부 C 및 C++ 으로 컴파일러 구현 합니다 **long double** 데이터 형식입니다. MSVC 컴파일러에서를 **long double** 데이터 형식은 고유 형식으로 처리 됩니다 있지만 저장소 형식에 매핑됩니다 **double**합니다. 그러나가 내장 및 어셈블리 언어 지원 확장-배정밀 (10 비트) 형식으로 포함 하는 다른 형식을 사용 하 여 계산에 대 한 하드웨어에서 지원 되는 경우.

값은 다음과 같이 저장 됩니다.

|값|로 저장|
|-----------|---------------|
|단정밀도(single-precision)|부호 비트, 지 수 8 비트, 23 비트 significand|
|double-precision|부호 비트, 지 수 11 비트, 52 비트 significand|
|double-extended-precision|부호 비트, 지 수 15 비트, 64 비트 significand|

단 정밀도 및 배정밀도 형식으로는 맡은 선행 1 이라는 소수 부분이 합니다 *significand* (라고도 하 고는 *가*), 즉에 저장 되지 않습니다 significands는 실제로 24 또는 53 비트 23 또는 52 비트 저장 된 경우에 메모리입니다. 확장-배정밀 형식을 실제로이 비트를 저장합니다.

가능한 값의 절반으로 오차는 합니다. 즉, 실제 지 수를 가져오려면 저장 된 지 수에서이 오차를 뺍니다. 저장된 된 지 수 바이어스 미만인 경우 실제로 음의 지 수 있습니다.

오차는 다음과 같습니다.

|지 수|으로 오차가 지정|
|--------------|---------------|
|8 비트 (단 정밀도)|127|
|11 비트 (배정밀도)|1023|
|15 비트 (확장-배정밀)|16383|

이러한 지 거듭제곱; 되지 이들은 2의 거듭제곱 이어야 합니다. 즉, 저장 된 지 수 8 비트는 0 ~ 254로 저장 127에서 이동 하면 – 127 까지입니다. 값 2<sup>127</sup> 대략 10<sup>38</sup>, 단 정밀도의 실제 한계는 있습니다.

형식의 이진 소수로 저장 되는 유효 숫자 1.XXX.... 이 소수 1 보다 크거나 같고 2 보다 작은 값이 있습니다. 실수에 항상 저장 되어 있음을 유의 *양식을 정규화*;는 유효 숫자는 왼쪽 이동는 유효 숫자의 상위 비트가 항상 1입니다. 이 비트가 1 인 항상 있으므로 (저장 안) 가정은 단 정밀도 및 배정밀도 형식입니다. 십진수가 아닌 이진 소수점 선행 1의 오른쪽에 있는 수로 간주 됩니다.

형식, 그런 다음 다양 한 크기는 다음과 같습니다.

|형식|byte 1|byte 2|byte 3|byte 4|...|byte n|
|------------|------------|------------|------------|------------|---------|------------|
|단정밀도(single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|double-precision|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|
|double-extended-precision|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S` 부호 비트를 나타내는 합니다 `X`의 편향는 지 수 비트 및 `M`의 significand 비트입니다. 왼쪽에 있는 비트 정밀도 및 배정밀도 형식으로 간주 됩니다 있지만 확장-배정도 형식의 3 바이트에 "1"로 note 합니다.

이진 소수점을 올바르게 이동 하려면 처음 옮김 지 수 및 다음 이진 소수점 오른쪽으로 이동 하거나 적절 한 비트 수를 유지 합니다.

## <a name="special-values"></a>특수 값

부동 소수점 형식에는 특별히 처리 되는 일부 값 포함 됩니다.

### <a name="zero"></a>0

0이를 통해 표현할 정규화 된 형식의 정밀도 또는 배정밀도 값을 정규화 할 수 없습니다. 특별 한 비트 패턴을 모두 0으로 0을 나타냅니다. 것도 가능-나타내는 기호가 있는 0으로 0 비트가 설정 되었으나-0 및 0 항상 동일한 것으로 비교 합니다.

### <a name="infinities"></a>무한대

+ ∞ 및 −∞ 값 모두의 지 수 및 모두 0으로 이루어진 significand로 표시 됩니다. 양수 및 음수 무한대 부호 비트를 사용 하 여 나타낼 수 있습니다.

### <a name="subnormals"></a>Subnormals

정규화 된 숫자 보다 작은 크기의 숫자를 나타내는 것이 가능 합니다. 이러한 번호 라고 *subnormal* 하거나 *denormal* 숫자입니다. 지 수는 모두 0 이며는 유효 숫자 0이 아닌 값에 유효 숫자의 암시적 선행 비트가 아닌 0으로 간주 됩니다. Subnormal 숫자 전체 자릿수는 유효 숫자에서 선행 0 수가 이동 하는 대로 이동 합니다.

### <a name="nan---not-a-number"></a>NaN-숫자가 아님

0과 같은 실수를 하지 않은 값을 나타낼 수 0, / IEEE 부동 소수점 형식에서입니다. 이러한 종류의 값이 호출 되는 *NaN*합니다. NaN은 모든과 0이 아닌 significand의 지 수로 표시 됩니다. Nan의 두 가지가 *quiet* Nan, 또는 QNaNs, 및 *신호* Nan, 또는 SNaNs 합니다. Quiet Nan는 유효 숫자에서 선행 하나 있고 식을 통해 일반적으로 전파 됩니다. 무한대를 나눈 또는 0으로 무한대를 곱한 결과 같이 비활성화 상태 값을 나타냅니다. 신호 보내기 Nan는 앞에 0에서 유효 합니다. 이러한 잘못 된 경우 부동 소수점 하드웨어 예외를 알리기 위해 하는 작업에 사용 됩니다.

## <a name="examples"></a>예제

다음은 단 정밀도 형식 몇 가지 예입니다.

- 값 2에 대 한 부호 비트는 0 및 저장된 된 지 수는 128 개입니다 또는 1을 더한 127은 1000 0000 이진 파일. 저장 된 이진 significand는 (1). 000 0000 0000 0000 0000 0000 이며 선행 하는 1과 이진 소수점이 있으므로 하나는 실제 유효 숫자입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 값-2입니다. 부호 비트가 설정 한다는 + 2와 같습니다. 이 모든 IEEE 형식이 부동 소수점 숫자의 음수 마찬가지입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 값 4입니다. 동일한 significand 지 수 (편향된 값은 129 또는 이진 100 0000 1 1 씩 증가.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 값 6입니다. 지 수, 유효 숫자는 절반 만큼 더 큰-(1). 100 0000 ... 0000 0000 이진 소수 이기 때문 이므로 1 1/2 소수 자릿수 값은 1/2, 1/4, 1/8 및 등입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 값 1입니다. 두 개의 편향된 지 수의 다른 거듭제곱으로 동일한 유효 숫자는 1 2 보다 작은 127 또는 이진 011 1111 1입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 0.75 값입니다. 편향된 지 수는 126 011 1111 0에 이진 및 유효는 (1). 100 0000 ... 0000 0000, 즉 1 1/2입니다.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 2.5 값입니다. 점을 제외 하면 2와 동일 1/4 나타내는 비트가 설정 됩니다는 유효 숫자에서.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10은 이진에서 반복 되는 소수입니다. 유효 1.6, 이며 편향된 지수가 64f6eb0d 1.6 16으로 나눌 (10 진수에서 123 인 이진 011 1101 1 임). 실제 지 수는 123 127 =-4로 곱하는 요소는 2 의미<sup>-4</sup> = 1/16입니다. 저장된 significand 마지막에서 올림 되는-최대한 정확 하 게 표현할 수를 나타내는 하려고 합니다. (이유 1/10과 1/100 이진에 정확 하 게 나타낼 수 있는 이유는 1/3을 정확히 나타낼 수 없는 10 진수에서 비슷합니다.)

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 0은 최소 가능한 표현할 수 있는 양수 값으로 모두 0 인 수식을 사용 하는 특별 한 경우.

   |값|수식|이진 표현|16진수|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>참고자료

[부동 소수점 숫자의 정밀도가 떨어지는 이유](why-floating-point-numbers-may-lose-precision.md)