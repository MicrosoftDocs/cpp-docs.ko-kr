---
title: IEEE 부동 소수점 표시
ms.date: 05/06/2019
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: de132dcf28747cd866229cff8972e2aed271a047
ms.sourcegitcommit: 9d4ffb8e6e0d70520a1e1a77805785878d445b8a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/20/2019
ms.locfileid: "69630351"
---
# <a name="ieee-floating-point-representation"></a>IEEE 부동 소수점 표시

Microsoft C++ (MSVC)는 IEEE 숫자 표준과 일치 합니다. IEEE-754 표준에서는 부동 소수점 형식에 대해 설명 하며,이를 통해 하드웨어의 실수를 나타낼 수 있습니다. MSVC 컴파일러의 대상 하드웨어에서 표현할 수 있는 부동 소수점 숫자에 대 한 내부 형식은 5 개 이상 이지만 컴파일러는 둘 중 하나만 사용 합니다. MSVC에서 *단 정밀도* (4 바이트) 및 *배정밀* 도 (8 바이트) 형식이 사용 됩니다. 단일 전체 자릿수는 **float**키워드를 사용 하 여 선언 됩니다. 배정밀도는 **double**키워드를 사용 하 여 선언 됩니다. 또한 IEEE 표준은 *전체* 자릿수 (2 바이트)와 *4* 바이트 (16 바이트) 형식을 지정 하 고 일부 C 및 C++ 컴파일러는 **long 형식으로 구현 하는 배정밀도 (10 바이트) 형식을 지정 합니다. double** 데이터 형식입니다. MSVC 컴파일러에서 **long double** 데이터 형식은 고유 형식으로 처리 되지만 저장소 형식은 **double**로 매핑됩니다. 그러나 하드웨어에서 지원 되는 배정밀도 (10 바이트) 형식을 포함 하 여 다른 형식을 사용 하는 계산에 대 한 내장 및 어셈블리 언어 지원이 있습니다.

값은 다음과 같이 저장 됩니다.

|값|다음으로 저장|
|-----------|---------------|
|단정밀도(single-precision)|부호 비트, 8 비트 지 수, 23 비트 significand|
|double-precision|부호 비트, 11 비트 지 수, 52 비트 significand|
|double-extended-precision|부호 비트, 15 비트 지 수, 64 비트 significand|

단 정밀도와 배정밀도 형식에서 *significand* (그리고가 수 라고도 함) 라는 소수 부분에는 선행 1이 있다고 가정 하므로 significands는 실제로 24 또는53입니다. 비트 (23 또는 52 비트만 저장 됨) 배정밀도 확장 정밀도 형식은 실제로이 비트를 저장 합니다.

지 수는 가능한 값의 절반으로 편향 됩니다. 즉, 저장 된 지 수에서이 바이어스를 빼서 실제 지 수를 가져옵니다. 저장 된 지수가 바이어스 보다 낮으면 실제로 음수 지 수입니다.

지수가 다음과 같이 편향 됩니다.

|지 수|편향 기준|
|--------------|---------------|
|8 비트 (단 정밀도)|127|
|11 비트 (배정밀도)|1023|
|15 비트 (배정밀도)|16383|

이러한 지수가 10의 거듭제곱은 아닙니다. 2의 거듭제곱입니다. 즉, 저장 된 지 수 8 비트의 범위는-127에서 127 사이이 고 0에서 254로 저장 됩니다. 값 2<sup>127</sup> 은 대략 단 정밀도의 실제 한도 인 10<sup>38</sup>에 해당 합니다.

Significand는 1.XXX 형식의 이진 분수로 저장 됩니다. 이 분수의 값은 1 보다 크거나 같고 2 보다 작아야 합니다. 실수는 항상 *정규화 된 형식*으로 저장 됩니다. 즉, significand의 상위 비트가 항상 1이 되도록 significand가 왼쪽으로 이동 됩니다. 이 비트는 항상 1 이므로 단 정밀도와 배정밀도 형식으로 (저장 되지 않음) 가정 됩니다. 이진수 (10 진수 아님) 지점은 선행 1의 오른쪽에 있는 것으로 간주 됩니다.

형식은 다양 한 크기의 경우 다음과 같습니다.

|형식|byte 1|byte 2|바이트 3|byte 4|...|바이트 n|
|------------|------------|------------|------------|------------|---------|------------|
|단정밀도(single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|double-precision|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|
|double-extended-precision|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S`는 부호 비트를 나타내고, `X`는 편향 지 수 비트이 `M`고,의는 significand 비트입니다. 가장 왼쪽에 있는 비트는 단 정밀도와 배정밀도 형식으로 간주 되지만 이중 확장 정밀도 형식의 바이트 3에는 "1"로 표시 됩니다.

이진 점을 제대로 이동 하려면 먼저 지 수를 적용 하지 않은 다음 이진 점을 적절 한 비트 수의 오른쪽 이나 왼쪽으로 이동 합니다.

## <a name="special-values"></a>특수 값

부동 소수점 형식에는 특수 하 게 처리 되는 일부 값이 포함 됩니다.

### <a name="zero"></a>0

0은 정규화 할 수 없습니다 .이 값을 사용 하면 단 정밀도 또는 배정밀도 값의 정규화 된 형식으로 unrepresentable 수 있습니다. 모든 0의 특수 비트 패턴은 0을 나타냅니다. 부호 비트가 설정 된 상태에서 0으로 0을 나타낼 수도 있지만,-0과 0은 항상 동일 하 게 비교 됩니다.

### <a name="infinities"></a>무한대

\+ ∞ 및 − ∞ 값은 모든 값의 지 수로 표시 되 고 모든 0은 significand로 표시 됩니다. 긍정 및 부정 무한대 모두 부호 비트를 사용 하 여 나타낼 수 있습니다.

### <a name="subnormals"></a>Subnormals

가장 작은 정규화 된 숫자 보다 작은 크기의 숫자를 나타낼 수 있습니다. 이러한 수치를 *subnormal* 또는 *denormal* 숫자 라고 합니다. 지수가 모두 0이 고 significand가 0이 아닌 경우 significand의 암시적 선행 비트는 0이 아닌 0으로 간주 됩니다. 하위 일반 숫자의 전체 자릿수는 significand의 앞에 오는 0의 수가 위로 이동 합니다.

### <a name="nan---not-a-number"></a>NaN-숫자가 아닙니다.

IEEE 부동 소수점 형식으로 0/0과 같이 실수 값이 아닌 값을 나타낼 수 있습니다. 이러한 종류의 값을 *NaN*이라고 합니다. NaN은 모든 값과 0이 아닌 significand의 지 수로 표시 됩니다. Nan, *quiet* Nan, QNaNs, *신호* nan 또는 snans의 두 가지 종류가 있습니다. Quiet Nan는 significand에 선행 하는 것 이며 일반적으로 식을 통해 전파 됩니다. 무한대로 나눈 결과 또는 무한대를 0으로 곱한 결과와 같이 확정 되지 않은 값을 나타냅니다. 신호 Nan에는 significand에 앞에 오는 0이 있습니다. 이러한 작업은 부동 소수점 하드웨어 예외를 알리기 위해 유효 하지 않은 작업에 사용 됩니다.

## <a name="examples"></a>예

다음은 단 정밀도 형식의 몇 가지 예입니다.

- 값 2의 경우 부호 비트는 0이 고, 저장 된 지 수는 128 또는 1000 0000 ()입니다 .이 값은 127 + 1입니다. 저장 된 이진 significand는 (1)입니다. 000 0000 0000 0000 0000 0000는 암시 된 선행 1과 이진 점을 포함 하므로 실제 significand는 1입니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 값-2입니다. 부호 비트가 설정 된 경우를 제외 하 고 + 2와 동일 합니다. 모든 IEEE 형식 부동 소수점 숫자의 음수에 적용 됩니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 값 4입니다. 동일한 significand, 지 수는 1 씩 늘어납니다 (바이어스 값은 129 또는 100 0000 1 이진으로)

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 값 6입니다. 동일한 지 수, significand의 절반이 큼, 즉 (1)입니다. 100 0000 ... 0000 0000 (이진 분수 이므로)는 소수 자릿수 값이 1/2, 1/4, 1/8 등 이므로 1 1/2입니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 값 1입니다. Significand가 2의 다른 거듭제곱이와 동일 하 고, 편향 지 수는 127의 경우 1 보다 작거나, 이진의 경우 011 1111 1입니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 값 0.75입니다. 편향 지 수는 126, 011 1111 0 (이진)이 고 significand는 (1)입니다. 100 0000 ... 0000 0000 (1 1/2)

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 값 2.5입니다. 1/4을 나타내는 비트가 significand에서 설정 된다는 점을 제외 하 고는 2와 정확히 동일 합니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10는 이진의 반복 되는 분수입니다. Significand는 1.6에 불과합니다. 편향 지 수는 1.6를 16으로 나누려고 한다는 것을 의미 합니다. 즉, 이진의 011 1101 1 (십진수의 123)입니다. True 지 수는 123-127 =-4입니다. 즉, 곱할 계수는 2<sup>-4</sup> = 1/16입니다. 저장 된 significand는 마지막 비트로 반올림 됩니다. unrepresentable 숫자를 가능한 한 정확 하 게 표현 하려고 시도 합니다. 1/10 및 1/100이 이진으로 정확 하 게 표현할 수 없는 이유는 1/3가 정확 하 게 decimal로 표현할 수 없는 이유와 비슷합니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 0은 표현할 수 있는 최소 값 (모두 0)에 대 한 수식을 사용 하는 특수 한 경우입니다.

   |값|수식|이진 표시|16진수|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>참고자료

[부동 소수점 숫자의 정밀도가 떨어지는 이유](why-floating-point-numbers-may-lose-precision.md)