---
title: 데코레이팅된 이름
ms.date: 09/05/2018
helpviewer_keywords:
- decorated names, definition
- name decoration [C++]
- names [C++], decorated
ms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344
ms.openlocfilehash: c7821fc9fca1c9a965ea83584415b9baf17ec683
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/31/2018
ms.locfileid: "50579112"
---
# <a name="decorated-names"></a>데코레이팅된 이름

C 및 C++ 프로그램의 함수, 데이터 및 개체는 내부적으로 데코레이트된 이름으로 표시됩니다. A *데코 레이트 된 이름* 되는 개체, 데이터 또는 함수 정의 컴파일할 때 컴파일러에서 생성 된 인코딩된 문자열입니다. 호출 규칙, 형식, 함수 매개 변수 및 기타 정보를 이름과 함께 기록합니다. 라고도이 이름 장식은 *이름 꾸미기*, 링커가 올바른 함수를 찾을 수 있습니다 및 실행 파일을 연결 하는 경우 개체입니다.

데코레이트된 명명 규칙은 다양한 버전의 Visual C++에서 변경되었고 대상 아키텍처에 따라 달라질 수 있습니다. Visual C++, C 및 C++를 사용하여 만든 소스 파일과 올바르게 연결하려면 동일한 컴파일러 도구 집합, 플래그 및 대상 아키텍처를 사용하여 DLL 및 라이브러리를 컴파일해야 합니다.

##  <a name="Using"></a> 데코레이팅된 이름 사용

일반적으로 성공적으로 컴파일 및 연결되는 코드를 작성하기 위해 데코레이트된 이름을 알 필요가 없습니다. 데코레이트된 이름은 컴파일러 및 링커의 내부 구현 세부 정보입니다. 일반적으로 도구는 데코레이트되지 않은 형식으로 이름을 처리할 수 있습니다. 그러나 함수 이름을 링커 및 기타 도구로 지정할 때 데코레이트된 이름이 필요할 수 있습니다. 예를 들어 오버로드된 C++ 함수, 네임스페이스 멤버, 클래스 생성자, 소멸자 및 특수 멤버 함수와 일치하려면 데코레이트된 이름을 지정해야 합니다. 옵션 플래그 및 데코레이트된 이름이 필요한 기타 상황에 대한 자세한 내용은 사용 중인 도구 및 옵션에 대한 설명서를 참조하세요.

함수 이름, 클래스, 호출 규칙, 반환 형식 또는 매개 변수를 변경하면 데코레이트된 이름도 변경됩니다. 이 경우 새 데코레이트된 이름을 가져오고 데코레이트된 이름이 지정된 모든 위치에 사용해야 합니다.

이름 장식은 다른 프로그래밍 언어 또는 다른 컴파일러를 사용하여 작성된 코드에 연결할 경우에도 중요합니다. 컴파일러에 따라 다른 이름 장식 규칙이 사용됩니다. 실행 파일이 다른 언어로 작성된 코드에 연결되면 내보낸 이름/가져온 이름이 호출 규칙과 일치하도록 주의해야 합니다. 어셈블리 언어 코드에서는 Visual C++를 데코레이트된 이름 및 호출 규칙을 사용하여 Visual C++를 사용하여 작성된 소스 코드에 연결합니다.

##  <a name="Format"></a> C + + 형식의 데코 레이트 된 이름

C++ 함수에 대한 데코레이트된 이름에는 다음 정보가 들어 있습니다.

- 함수 이름.

- 멤버 함수인 경우 함수가 멤버로 있는 클래스. 여기에는 함수가 들어 있는 클래스 등을 포함하는 클래스가 포함될 수 있습니다.

- 함수가 네임스페이스 일부인 경우 함수가 속한 네임스페이스.

- 함수 매개 변수 형식.

- 호출 규칙.

- 함수의 반환 형식입니다.

함수 및 클래스 이름은 데코레이트된 이름으로 인코딩됩니다. 데코레이트된 이름의 나머지 부분은 컴파일러 및 링커에 대해 내부적인 의미가 있는 코드입니다. 데코레이트되지 않은 C++ 이름과 데코레이트된 C++ 이름의 예는 다음과 같습니다.

|데코레이트되지 않은 이름|데코레이트된 이름|
|----------------------|--------------------|
|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|
|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|

##  <a name="FormatC"></a> C 형식으로 데코 레이트 된 이름

C 함수에 대한 장식 형식은 다음 표와 같이 선언에 사용되는 호출 규칙에 따라 달라집니다. 또한 이 형식은 C++ 코드가 `extern "C"` 링크를 포함하도록 선언될 때 사용되는 장식 형식입니다. 기본 호출 규칙은 `__cdecl`입니다. 64비트 환경에서는 함수가 데코레이트되지 않습니다.

|호출 규칙|장식|
|------------------------|----------------|
|`__cdecl`|선행 밑줄 (**_**)|
|`__stdcall`|선행 밑줄 (**_**) 및 후행 at 기호 (**\@**) 뒤에 10 진수에서 매개 변수 목록의 바이트 수|
|`__fastcall`|선행 및 후행 at 기호 (**\@**) 뒤에 매개 변수 목록의 바이트 수를 나타내는 10 진수 숫자입니다.|
|`__vectorcall`|두 개의 at 기호 (**\@\@**) 뒤에 매개 변수 목록의 바이트 수를 10 진수|

##  <a name="Viewing"></a> 보기를 데코 레이트 된 이름

데이터, 개체 또는 함수 정의나 프로토타입이 포함된 소스 파일을 컴파일하고 나서 기호 이름의 데코레이트된 형식을 가져올 수 있습니다. 프로그램에서 데코레이트된 이름을 검사하려면 다음 방법의 하나를 사용합니다.

#### <a name="to-use-a-listing-to-view-decorated-names"></a>목록을 사용하여 데코레이트된 이름 표시

1. 데이터, 개체 또는 함수 정의 나 프로토타입이 포함 된 소스 파일을 컴파일하여 목록을 생성 합니다 [파일 형식이 나열](../../build/reference/fa-fa-listing-file.md) 소스 코드를 사용 하 여 어셈블리를 설정 하는 컴파일러 옵션 (**/FAs**).

   예를 들어 입력 `cl /c /FAs example.cpp` 목록 파일을 생성 하려면 개발자 명령 프롬프트에서 example.asm 합니다.

2. 결과 목록 파일에서 PUBLIC으로 시작하고 세미콜론으로 끝난 뒤에 데코레이트되지 않은 데이터 또는 함수 이름이 이어지는 줄을 찾습니다. PUBLIC과 세미콜론 사이에 있는 기호는 데코레이트된 이름입니다.

#### <a name="to-use-dumpbin-to-view-decorated-names"></a>DUMPBIN을 사용하여 데코레이트된 이름 표시

1. 입력 된.obj 또는.lib 파일에서 내보낸된 기호를 보려면 `dumpbin /symbols` `objfile` 개발자 명령 프롬프트에서.

2. 데코레이트된 형식의 기호를 찾으려면 괄호 안에 있는 데코레이트되지 않은 이름을 찾습니다. 트 데코 레이 된 이름이 같은 줄에서 파이프 후 (&#124;) 문자와 데코 레이트 되지 않은 이름 앞입니다.

##  <a name="Undecorated"></a> 데코 레이트 되지 않은 보기 이름

undname.exe를 사용하여 데코레이트된 이름을 데코레이트되지 않은 형식으로 변환할 수 있습니다. 이 예제에서는 어떻게 작동하는지 보여 줍니다.

```
C:\>undname ?func1@a@@AAEXH@Z
Microsoft (R) C++ Name Undecorator
Copyright (C) Microsoft Corporation. All rights reserved.

Undecoration of :- "?func1@a@@AAEXH@Z"
is :- "private: void __thiscall a::func1(int)"
```

## <a name="see-also"></a>참고 항목

[ 빌드 도구](../../build/reference/c-cpp-build-tools.md)<br/>
[extern을 사용하여 링크 지정](../../cpp/using-extern-to-specify-linkage.md)