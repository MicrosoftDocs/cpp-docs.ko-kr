---
title: 데코레이팅된 이름
ms.date: 09/05/2018
helpviewer_keywords:
- decorated names, definition
- name decoration [C++]
- names [C++], decorated
ms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344
ms.openlocfilehash: f6d81029d20d9aaca96ff184f48e94a9ce35d56e
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81320510"
---
# <a name="decorated-names"></a>데코레이팅된 이름

C 및 C++ 프로그램의 함수, 데이터 및 개체는 내부적으로 데코레이트된 이름으로 표시됩니다. *데코레이션된 이름은* 개체, 데이터 또는 함수 정의를 컴파일하는 동안 컴파일러가 만든 인코딩된 문자열입니다. 호출 규칙, 형식, 함수 매개 변수 및 기타 정보를 이름과 함께 기록합니다. *이름 문글거리기라고도*하는 이 이름 장식은 실행 기능을 연결할 때 링커가 올바른 함수와 개체를 찾는 데 도움이 됩니다.

장식된 명명 규칙은 다양한 버전의 Visual Studio에서 변경되었으며 다른 대상 아키텍처에서도 다를 수 있습니다. Visual Studio, C 및 C++ DLL 및 라이브러리를 사용하여 만든 원본 파일과 올바르게 연결하려면 동일한 컴파일러 도구 집합, 플래그 및 대상 아키텍처를 사용하여 컴파일해야 합니다.

> [!NOTE]
> Visual Studio 2015로 빌드된 라이브러리는 Visual Studio 2017 또는 Visual Studio 2019로 빌드된 응용 프로그램에서 사용할 수 있습니다.

## <a name="using-decorated-names"></a><a name="Using"></a>장식된 이름 사용

일반적으로 성공적으로 컴파일 및 연결되는 코드를 작성하기 위해 데코레이트된 이름을 알 필요가 없습니다. 데코레이트된 이름은 컴파일러 및 링커의 내부 구현 세부 정보입니다. 일반적으로 도구는 데코레이트되지 않은 형식으로 이름을 처리할 수 있습니다. 그러나 함수 이름을 링커 및 기타 도구로 지정할 때 데코레이트된 이름이 필요할 수 있습니다. 예를 들어 오버로드된 C++ 함수, 네임스페이스 멤버, 클래스 생성자, 소멸자 및 특수 멤버 함수와 일치하려면 데코레이트된 이름을 지정해야 합니다. 옵션 플래그 및 데코레이트된 이름이 필요한 기타 상황에 대한 자세한 내용은 사용 중인 도구 및 옵션에 대한 설명서를 참조하세요.

함수 이름, 클래스, 호출 규칙, 반환 형식 또는 매개 변수를 변경하면 데코레이트된 이름도 변경됩니다. 이 경우 새 데코레이트된 이름을 가져오고 데코레이트된 이름이 지정된 모든 위치에 사용해야 합니다.

이름 장식은 다른 프로그래밍 언어 또는 다른 컴파일러를 사용하여 작성된 코드에 연결할 경우에도 중요합니다. 컴파일러에 따라 다른 이름 장식 규칙이 사용됩니다. 실행 파일이 다른 언어로 작성된 코드에 연결되면 내보낸 이름/가져온 이름이 호출 규칙과 일치하도록 주의해야 합니다. 어셈블리 언어 코드는 MSVC를 사용하여 작성된 소스 코드에 연결하기 위해 MSVC데코레이팅된 이름 및 호출 규칙을 사용해야 합니다.

## <a name="format-of-a-c-decorated-name"></a><a name="Format"></a>C++ 장식된 이름의 형식

C++ 함수에 대한 데코레이트된 이름에는 다음 정보가 들어 있습니다.

- 함수 이름입니다.

- 멤버 함수인 경우 함수가 멤버로 있는 클래스. 여기에는 함수가 들어 있는 클래스 등을 포함하는 클래스가 포함될 수 있습니다.

- 함수가 네임스페이스 일부인 경우 함수가 속한 네임스페이스.

- 함수 매개 변수 형식.

- 호출 규칙.

- 함수의 반환 형식입니다.

함수 및 클래스 이름은 데코레이트된 이름으로 인코딩됩니다. 데코레이트된 이름의 나머지 부분은 컴파일러 및 링커에 대해 내부적인 의미가 있는 코드입니다. 데코레이트되지 않은 C++ 이름과 데코레이트된 C++ 이름의 예는 다음과 같습니다.

|데코레이트되지 않은 이름|데코레이트된 이름|
|----------------------|--------------------|
|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|
|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|

## <a name="format-of-a-c-decorated-name"></a><a name="FormatC"></a>C 장식 된 이름의 형식

C 함수에 대한 장식 형식은 다음 표와 같이 선언에 사용되는 호출 규칙에 따라 달라집니다. 또한 이 형식은 C++ 코드가 `extern "C"` 링크를 포함하도록 선언될 때 사용되는 장식 형식입니다. 기본 호출 규칙은 `__cdecl`입니다. 64비트 환경에서는 함수가 데코레이트되지 않습니다.

|호출 규칙|장식|
|------------------------|----------------|
|`__cdecl`|선행 밑줄 **(_**)|
|`__stdcall`|선행 밑줄 **(_**) 및 기호**\@**(에서 후행) 뒤에 소수점 의 매개 변수 목록에서 바이트 의 수|
|`__fastcall`|[표] 다음으로 기호()에서**\@** 선행 및 후행 매개 변수 목록의 바이트 수를 나타내는 소수 자릿수|
|`__vectorcall`|기호 ()**\@** 다음에 매개 변수 목록에서 소수 점의 바이트다음에 두 개의 후행|

## <a name="viewing-decorated-names"></a><a name="Viewing"></a>장식된 이름 보기

데이터, 개체 또는 함수 정의나 프로토타입이 포함된 소스 파일을 컴파일하고 나서 기호 이름의 데코레이트된 형식을 가져올 수 있습니다. 프로그램에서 데코레이트된 이름을 검사하려면 다음 방법의 하나를 사용합니다.

#### <a name="to-use-a-listing-to-view-decorated-names"></a>목록을 사용하여 데코레이트된 이름 표시

1. 데이터, 개체 또는 함수 정의 또는 프로토타입이 포함된 원본 파일을 소스**코드(/FA)를**사용하여 어셈블리로 설정된 [목록 파일 유형](fa-fa-listing-file.md) 컴파일러 옵션을 사용하여 목록을 생성합니다.

   예를 들어 `cl /c /FAs example.cpp` 개발자 명령 프롬프트를 입력하여 목록 파일(예.asm)을 생성합니다.

2. 결과 목록 파일에서 PUBLIC으로 시작하고 세미콜론으로 끝난 뒤에 데코레이트되지 않은 데이터 또는 함수 이름이 이어지는 줄을 찾습니다. PUBLIC과 세미콜론 사이에 있는 기호는 데코레이트된 이름입니다.

#### <a name="to-use-dumpbin-to-view-decorated-names"></a>DUMPBIN을 사용하여 데코레이트된 이름 표시

1. 내보낸 기호를 .obj 또는 .lib 파일에서 `dumpbin /symbols` `objfile` 보려면 개발자 명령 프롬프트를 입력합니다.

2. 데코레이트된 형식의 기호를 찾으려면 괄호 안에 있는 데코레이트되지 않은 이름을 찾습니다. 데코레이션된 이름은 파이프(&#124;) 문자 다음과 장식되지 않은 이름 앞에 같은 줄에 있습니다.

## <a name="viewing-undecorated-names"></a><a name="Undecorated"></a>장식되지 않은 이름 보기

undname.exe를 사용하여 데코레이트된 이름을 데코레이트되지 않은 형식으로 변환할 수 있습니다. 이 예제에서는 어떻게 작동하는지 보여 줍니다.

```
C:\>undname ?func1@a@@AAEXH@Z
Microsoft (R) C++ Name Undecorator
Copyright (C) Microsoft Corporation. All rights reserved.

Undecoration of :- "?func1@a@@AAEXH@Z"
is :- "private: void __thiscall a::func1(int)"
```

## <a name="see-also"></a>참고 항목

[추가 MSVC 빌드 도구](c-cpp-build-tools.md)<br/>
[extern을 사용하여 링크 지정](../../cpp/using-extern-to-specify-linkage.md)
