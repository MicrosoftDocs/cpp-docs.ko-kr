---
title: "IEEE 부동 소수점 표시 | Microsoft Docs"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 17fae0cbb16208d5c7e7346f354f3501e4803d96
ms.sourcegitcommit: 9239c52c05e5cd19b6a72005372179587a47a8e4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/16/2018
---
# <a name="ieee-floating-point-representation"></a>IEEE 부동 소수점 표시
Microsoft Visual c + +는 IEEE 숫자 표준 일치 합니다. 세 종류의 실수로 가지가 있습니다. 실제\*4 및 real\*8 Visual c + +에서 사용 됩니다. 실제\*4 라는 단어를 사용 하 여 선언 된 **float**합니다. 실제\*8 단어를 사용 하 여 선언 된 **double**합니다. Windows 32 비트 프로그래밍에는 `long double` 데이터 형식은 **double**합니다. 하지만가 실제를 사용 하 여 계산에 대 한 어셈블리 언어 지원 * 10 데이터 형식입니다.  
  
 값은 다음과 같이 저장 됩니다.  
  
|값|으로 저장|  
|-----------|---------------|  
|real*4|부호 비트, 지 수 8 비트가 수 23 비트|  
|real*8|부호 비트, 지 수 11 비트가 수 52 비트|  
|real * 10|부호 비트, 15 비트 지 수, 64 비트가 수|  
  
 Real에서 * 4 및 real\*8 형식 비트만 되지만 실제로 24 또는 53 비트 23 또는 52 비트 저장 되므로 메모리에 저장 되지 않은 수의 맡은 선행 1이가 있습니다. 실제\*10 형식은이 비트 저장 되기 때문입니다.  
  
 가능한 값의 절반으로 오차는 합니다. 즉, 실제 지 수를 저장 된 지 수에서이 오차를 뺍니다. 저장 된 지 수 바이어스 미만인 경우 실제로 음의 지 수입니다.  
  
 오차는 다음과 같습니다.  
  
|지 수|으로 오차가 지정|  
|--------------|---------------|  
|8 비트 (real * 4)|127|  
|11 비트 (real * 8)|1023|  
|15 비트 (real * 10)|16383|  
  
 이러한 지 거듭제곱; 않습니다. 이들은 2의 거듭제곱입니다. 즉, 저장 된 지 수 8 비트 최대 127 일 수 있습니다. 10 값 2 * * 127와 대략 같습니다\*\*실시간의 실제 제한이 있는 38\*4입니다.  
  
 가 수 폼의 이진 소수로 저장 된 1.XXX.... 이 소수는 1 보다 크거나 같고 2 보다 작은 값입니다. 실수는 항상 정규화 된 형식;에 저장 하는 참고 즉,가 수 왼쪽으로 자리는 수의 상위 비트가 항상 1입니다. 이 비트가 1 이면 항상 때문에 (저장 안) 가정 됩니다는 real * 4 및 real\*8 형식입니다. 이진 십진수가 아닌 지점 바로 선행 1의 오른쪽에 것으로 간주 됩니다.  
  
 형식으로 다음, 여러 크기는 다음과 같습니다.  
  
|형식|1 바이트|2 바이트|3 바이트|4 바이트|...|바이트 n|  
|------------|------------|------------|------------|------------|---------|------------|  
|real*4|`SXXX XXXX`|`XMMM MMMM`|`MMMM MMMM`|`MMMM MMMM`|||  
|real*8|`SXXX XXXX`|`XXXX MMMM`|`MMMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
|real * 10|`SXXX XXXX`|`XXXX XXXX`|`1MMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
  
 `S` 부호 비트를 나타냅니다는 `X`의 지 수 비트 및 `M`의 수 비트 됩니다. 왼쪽에 있는 비트 실시간 가정 참고 * 4 및 real\*8 형식과 같은 하지만 실제 바이트 3에서 "1"으로 제공 되며\*10 형식입니다.  
  
 이진 소수점을 제대로 이동 하려면 먼저 옮김 지 수와 다음 이진 소수점 오른쪽으로 이동 또는 남아 있는 비트의 적절 한 수입니다.  
  
## <a name="examples"></a>예제  
 다음은 몇 가지 예 real에서 * 4 형식:  
  
-   다음 예제에서는 부호 비트는 0이 고 저장 된 지 수는 128, 또는 100 0000 127 + 1는에서 0입니다. 저장 된가 수는 (1.) 000 0000 ... 0000 0000, 이며 선행 하는 1과 이진 소수점이 있으므로 실제 수는 1입니다.  
  
    ```  
                        SXXX XXXX XMMM MMMM ... MMMM MMMM  
    2   =  1  * 2**1  = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000  
    ```  
  
-   부호 비트가 설정 된 점을 제외 하 고는 + 2와 같습니다. 이 모든 IEEE 형식 부동 소수점 숫자에 적용 됩니다.  
  
    ```  
    -2  = -1  * 2**1  = 1100 0000 0000 0000 ... 0000 0000 = C000 0000  
    ```  
  
-   동일한 수, 지 수 (편향된 값은 129 또는 이진 100 0000 1 1 씩 증가.  
  
    ```  
    4  =  1  * 2**2  = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000  
    ```  
  
-   지 수는가 수는 절반으로-(1). 100 0000 중... 0000 0000 이진 소수 이므로 1 1/2 (소수 자릿수 값은 1/2, 1/4, 1/8, 및 등).  
  
    ```  
    6  = 1.5 * 2**2  = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000  
    ```  
  
-   다른 두가 수 동일 지 수는 1 두 개 미만의 127 또는 이진 011 1111 1입니다.  
  
    ```  
    1  = 1   * 2**0  = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000  
    ```  
  
-   편향된 지 수는 126 011 1111 진수로 0 및가 수는 (1). 100 0000 ... 0000 0000, 즉 1 1/2입니다.  
  
    ```  
    .75 = 1.5 * 2**-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000  
    ```  
  
-   점을 제외 하면 2와 동일 1/4를 나타내는 비트는에 비트가 설정 합니다.  
  
    ```  
    2.5 = 1.25 * 2**1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000  
    ```  
  
-   1/10 진수로 반복 되는 소수입니다. 가 수 1.6, 이며 편향된 지 수 것으로 표시 1.6 16 피연산자로 나눠집니다 (이 10 진수에서 123 011 1101 1). 실제 지 수는 123 127 =-4, 2 * *-4 = 1/16 곱할 요인 임을 의미 합니다. 마지막 비트에서 저장 된가 수까지 반올림 하는 참고-수를 나타내는 표현할 수 가능한 정확 하 게 시도 합니다. (이유 1/10과 1/100 정확 하 게 나타낼 수는 1/3을 정확히 나타낼 수 없는 10 진수에서 이유 비슷합니다.)  
  
    ```  
    0.1 = 1.6 * 2**-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD  
    ```  
  
-   `0  = 1.0 * 2**-128 = all zeros--a special case.`  
  
## <a name="see-also"></a>참고 항목  
 [부동 소수점 숫자의 정밀도가 떨어지는 이유](../../build/reference/why-floating-point-numbers-may-lose-precision.md)