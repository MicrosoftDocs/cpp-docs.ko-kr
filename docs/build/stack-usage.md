---
title: x64 스택 사용
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: 3318a3512f83e242496454ffa2dc4aa8d26e1fc3
ms.sourcegitcommit: ff3cbe4235b6c316edcc7677f79f70c3e784ad76
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/19/2018
ms.locfileid: "53627321"
---
# <a name="x64-stack-usage"></a>x64 스택 사용

RSP의 현재 주소를 넘는 모든 메모리에 일시적으로 간주 됩니다. OS 또는 디버거 사용자 디버그 세션 또는 인터럽트 처리기 중이 메모리를 덮어쓸 수 있습니다. 따라서 RSP 항상 읽기 또는 스택 프레임으로 값을 쓰기를 시도 하기 전에 설정 해야 합니다.

이 단원에서는 지역 변수에 대한 스택 공간 할당 및 **alloca** 내장 함수에 대해 설명합니다 .

## <a name="stack-allocation"></a>스택 할당

함수의 프롤로그는 로컬 변수에 대 한 스택 공간을 할당, 매개 변수 스택 레지스터 저장 되 고 매개 변수를 등록 합니다.

매개 변수 영역 스택의 맨 아래에 항상 (경우에 `alloca` 는) 해당 값은 항상 반환 주소 옆에 있는 모든 함수 호출 중 되도록 합니다. 4 개 이상의 항목을 포함 하지만 모든 매개 변수를 포함할 충분 한 공간이 호출할 수 있는 모든 함수에서 항상 필요 합니다. 공간 매개 변수 자체 스택에; 넣지 않는 경우에 항상 등록 매개 변수에 대해 할당 되는 호출 수신자는 모든 매개 변수에 대해 할당 된 공간의 보장 됩니다. 집 주소에 레지스터 인수에 대 한 필수 되므로 호출된 된 함수에서 인수 목록 (va_list) 또는 개별 인수로 하는 경우에 인접 한 영역을 사용할 수 있습니다. 이 영역에서는 썽크 실행 하는 동안 및 디버깅 옵션으로 레지스터 인수를 저장 하는 데 편리한 위치 (예를 들어이 쉽게 인수에서 프롤로그 코드의 집 주소에 저장 되는 경우 디버깅 중에). 호출된 된 함수에 4 개 미만의 매개 변수가 하는 경우에 이러한 4 개의 스택 위치가 호출된 된 함수를 효과적으로 소유 하며 호출된 된 함수 매개 변수 레지스터 값을 저장 하는 것 외에도 다른 용도로 사용할 수 있습니다.  따라서 호출자 수 정보를 저장할 스택의이 지역에서 함수 호출.

공간을 동적으로 할당 하는 경우 (`alloca`) 함수에서 다음 비휘발성 레지스터를 사용 해야 프레임 포인터로 스택의 고정 부분의 표시 하며 레지스터를 저장 하 고 프롤로그에 초기화 해야 하는 합니다. 해당 경우 `alloca` 는 사용 동일한 호출 수신자에 게 동일한 호출자에서 호출 있을 수는 등록 매개 변수에 대 한 다른 집 주소입니다.

스택의 항상 유지 관리될지 16 바이트 (예를 들어 반환 주소 푸시 후), 프롤로그 내에서 제외 하 고 표시 된 위치를 제외 하 고 맞추고 [함수 형식](#function-types) 프레임 함수의 특정 클래스에 대 한 합니다.

다음은 예제 함수는 호출에서 리프가 아닌 B 함수 프롤로그를 작동 하는 위치 스택 레이아웃이 스택의 맨 아래에서 B에 필요한 모든 레지스터 및 스택 매개 변수의 공간을 이미 할당 합니다. 호출 반환 주소를 푸시하고 B의 프롤로그 지역 변수, 비휘발성 레지스터 및 함수를 호출 하는 데 필요한 공간에 대 한 공간을 할당 합니다. B를 사용 하는 경우 `alloca`에 영역 저장 로컬 변수/비휘발성 레지스터와 매개 변수 스택 영역 사이의 공간 할당 됩니다.

![AMD 변환 예제](../build/media/vcamd_conv_ex_5.png "AMD 변환 예제")

함수 B를 사용 하는 다른 함수를 호출할 때 RCX에 대 한 반환 주소 집 주소 바로 아래 푸시됩니다.

## <a name="dynamic-parameter-stack-area-construction"></a>동적 매개 변수 스택 영역 생성

프레임 포인터를 사용 하는 경우 매개 변수 스택 영역을 동적으로 생성 하는 옵션도가 있습니다. 이렇게 하지 않으면 현재 x64에서 컴파일러.

## <a name="function-types"></a>함수 형식

두 형식의 함수는 기본적으로 합니다. 스택 프레임을 필요로 하는 함수는 호출을 *함수를 프레임*합니다. 스택 프레임 필요 하지 않은 함수가 호출 되는 *함수를 리프*합니다.

프레임 함수 스택 공간을 할당, 다른 함수를 호출, 비휘발성 레지스터를 저장 또는 예외 처리를 사용 하는 함수가입니다. 또한 함수 테이블 항목을 필요합니다. 프레임 함수 프롤로그와 에필로그가 필요합니다. 프레임 함수 스택 공간을 동적으로 할당 하 고 프레임 포인터를 사용할 수 있습니다. 프레임 함수에 표준 호출의 전체 기능에 있습니다.

프레임 함수가 다른 함수를 호출 하지 경우 스택의 맞출 필요는 없습니다 (단원에 언급 [스택 할당](#stack-allocation)).

리프 함수는 함수 테이블 항목 필요 하지 않습니다. 즉, 모든 함수를 호출 하거나 스택 공간을 할당할 수 없습니다는 RSP 등의 모든 비휘발성 레지스터 변경할 수 없습니다 것입니다. 실행 되는 동안 스택 정렬 되지 않은 그대로 허용 됩니다.

## <a name="malloc-alignment"></a>malloc 맞춤

[malloc](../c-runtime-library/reference/malloc.md) 에 할당 되는 메모리에 맞출 수 있고 기본 맞춤이 있는 개체를 저장 하도록 적절히 정렬 되는 메모리를 반환 합니다. A *기본 맞춤* 는 맞춤은 맞춤 사양 없이 구현에서 지원 되는 가장 큰 맞춤 보다 작거나 같은입니다. (이것은 맞춤에 대 한 필요한 Visual c + +에서는 `double`, 또는 8 바이트입니다. 64비트 플랫폼을 대상으로 하는 코드에서는 16바이트입니다. 예를 들어, 4 바이트 할당 4 바이트 보다 작은 개체를 지 원하는 경계에 정렬 합니다.

Visual c + +를 갖는 형식이 허용 *확장 된 맞춤*, 라고도 되 *과도 하 게 정렬* 형식입니다. 예를 들어 SSE 형식 [__m128](../cpp/m128.md) 및 `__m256`를 사용 하 여 선언 된 형식과 `__declspec(align( n ))` 여기서 `n` 은 8 보다 큼, 맞춤 확장. 확장 된 맞춤이 필요한 개체에 적합 한 경계에서 메모리 맞춤은 반드시 `malloc`입니다. 사용 과다 정렬 된 형식에 대 한 메모리를 할당할 [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md) 및 관련 함수입니다.

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)를 사용하려면 16바이트 맞춤이어야 하고 프레임 포인터를 사용해야 합니다.

할당 된 스택 공간을 포함 해야 후 이후 호출 함수의 매개 변수에 대 한에 설명 된 대로 [스택 할당](#stack-allocation)합니다.

## <a name="see-also"></a>참고 항목

[x64 소프트웨어 규칙](../build/x64-software-conventions.md)<br/>
[align(C++)](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)