---
title: x64 스택 사용
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: 902e4304ac124be46c6edf0860118dc522b34890
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/16/2020
ms.locfileid: "79422753"
---
# <a name="x64-stack-usage"></a>x64 스택 사용

RSP의 현재 주소를 벗어난 모든 메모리는 휘발성(volatile)으로 간주됩니다. 운영 체제나 디버거는 사용자 디버그 세션을 진행하는 동안 또는 중단 처리기에서 이 메모리를 덮어쓸 수 있습니다. 따라서 값을 스택 프레임에서 읽거나 스택 프레임에 쓰기 전에 항상 RSP를 설정해야 합니.

이 섹션에서는 지역 변수 및 **alloca** 내장 함수에 대 한 스택 공간의 할당에 대해 설명 합니다.

## <a name="stack-allocation"></a>스택 할당

함수의 프롤로그는 지역 변수, 저장 된 레지스터, 스택 매개 변수 및 레지스터 매개 변수에 대 한 스택 공간을 할당 합니다.

매개 변수 영역은 항상 스택의 맨 아래에 있습니다 (`alloca` 사용 되는 경우에도). 모든 함수를 호출 하는 동안 항상 반환 주소에 인접 하 게 됩니다. 4 개 이상의 항목을 포함 하지만 호출 될 수 있는 함수에 필요한 모든 매개 변수를 저장할 수 있는 공간이 항상 충분 합니다. 매개 변수 자체가 스택으로 열리지 않는 경우에도 항상 레지스터 매개 변수에 공간이 할당 됩니다. 호출 수신자는 모든 매개 변수에 대 한 공간이 할당 되도록 보장 합니다. 호출 된 함수가 인수 목록 (va_list)의 주소 또는 개별 인수를 사용 해야 하는 경우 인접 한 영역을 사용할 수 있도록 레지스터 인수에는 홈 주소가 필요 합니다. 이 영역에는 썽크 실행 중에 레지스터 인수를 저장 하는 편리한 위치와 디버깅 옵션이 있습니다. 예를 들어, 프롤로그 코드의 홈 주소에 저장 된 경우에는 디버깅 중에 인수를 쉽게 찾을 수 있습니다. 호출 된 함수에 4 개 미만의 매개 변수가 있는 경우에도 이러한 4 개의 스택 위치는 호출 된 함수가 효과적으로 소유 하며, 매개 변수 레지스터 값을 저장 하는 것 외에 다른 용도로 호출 된 함수에서 사용할 수 있습니다.  따라서 호출자는 함수 호출을 통해이 스택 영역에 정보를 저장 하지 않을 수 있습니다.

함수에서 공간을 동적으로 할당 하는 경우 (`alloca`), 비휘발성 레지스터를 프레임 포인터로 사용 하 여 스택의 고정 부분을 표시 하 고 레지스터를 프롤로그에 저장 하 고 초기화 해야 합니다. `alloca`를 사용 하는 경우 동일한 호출자의 동일한 호출 수신자에 대 한 호출에는 register 매개 변수에 대 한 다른 홈 주소가 있을 수 있습니다.

스택은 프롤로그 내에서 (예: 반환 주소가 푸시되는 경우), 그리고 특정 프레임 함수 클래스의 [함수 형식](#function-types) 에 지정 된 경우를 제외 하 고는 항상 16 바이트 맞춤으로 유지 됩니다.

다음은 함수 A가 리프가 아닌 함수 B를 호출 하는 스택 레이아웃의 예입니다. 함수 A의 프롤로그에는 스택의 맨 아래에 있는 B에 필요한 모든 레지스터 및 스택 매개 변수에 대 한 공간을 이미 할당 했습니다. 호출에서 반환 주소를 푸시합니다. B의 프롤로그는 지역 변수, 비휘발성 레지스터 및 함수를 호출 하는 데 필요한 공간에 대 한 공간을 할당 합니다. B가 `alloca`를 사용 하는 경우 지역 변수/비휘발성 등록 저장 영역과 매개 변수 스택 영역 사이에 공간이 할당 됩니다.

![AMD 변환 예제](../build/media/vcamd_conv_ex_5.png "AMD 변환 예제")

함수 B에서 다른 함수를 호출 하면 반환 주소가 RCX의 홈 주소 바로 아래에 푸시됩니다.

## <a name="dynamic-parameter-stack-area-construction"></a>동적 매개 변수 스택 영역 생성

프레임 포인터를 사용하는 경우 매개 변수 스택 영역을 동적으로 생성하는 옵션을 활용할 수 있습니다. x64 컴파일러에서는 현재 이 옵션을 사용할 수 없습니다.

## <a name="function-types"></a>함수 형식

기본적으로 두 가지 유형의 함수가 있습니다. 스택 프레임을 필요로 하는 함수를 *프레임 함수*라고 합니다. 스택 프레임을 필요로 하지 않는 함수를 *리프 함수*라고 합니다.

프레임 함수는 스택 공간을 할당 하거나, 다른 함수를 호출 하거나, 비휘발성 레지스터를 저장 하거나, 예외 처리를 사용 하는 함수입니다. 또한 함수 테이블 항목이 필요 합니다. 프레임 함수에는 프롤로그 및 에필로그가 필요 합니다. 프레임 함수는 스택 공간을 동적으로 할당 하 고 프레임 포인터를 사용할 수 있습니다. 프레임 함수는이 호출 표준의 전체 기능을 삭제 합니다.

프레임 함수에서 다른 함수를 호출 하지 않는 경우에는 스택을 정렬할 필요가 없습니다 (섹션 [스택 할당](#stack-allocation)에서 참조 됨).

리프 함수는 함수 테이블 항목을 필요로 하지 않는 함수입니다. RSP를 비롯 한 모든 비휘발성 레지스터를 변경할 수 없습니다 .이는 함수를 호출 하거나 스택 공간을 할당할 수 없음을 의미 합니다. 실행 되는 동안에는 스택을 정렬 되지 않은 상태로 둘 수 있습니다.

## <a name="malloc-alignment"></a>malloc 맞춤

[malloc](../c-runtime-library/reference/malloc.md) 는 기본 맞춤이 적용 되 고 할당 된 메모리 양에 맞을 수 있는 개체를 저장 하는 데 적절 하 게 맞춰진 메모리를 반환 하도록 보장 됩니다. *기본 맞춤* 은 맞춤 사양이 없는 구현에서 지원 되는 가장 큰 맞춤 보다 작거나 같은 맞춤입니다. 시각적 개체 C++는 `double`또는 8 바이트에 필요한 맞춤입니다. 64 비트 플랫폼을 대상으로 하는 코드에서는 16 바이트입니다. 예를 들어 4 바이트 할당은 4 바이트 또는 더 작은 개체를 지 원하는 경계에 정렬 됩니다.

시각적 C++ 개체는 과도 하 게 *정렬* 된 형식으로도 알려진 *확장 된 맞춤*을 포함 하는 형식을 허용 합니다. 예를 들어 SSE 형식 [__m128](../cpp/m128.md) 및 `__m256`및 `__declspec(align( n ))`를 사용 하 여 선언 된 형식 `n` 8 보다 크면 확장 된 맞춤이 사용 됩니다. 확장 맞춤이 필요한 개체에 적합 한 경계의 메모리 맞춤은 `malloc`보장 되지 않습니다. 과도 하 게 정렬 된 형식에 대해 메모리를 할당 하려면 [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md) 및 관련 함수를 사용 합니다.

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md) 16 바이트로 정렬 되어야 하 고 프레임 포인터를 사용 하는 데 필요 합니다.

할당 된 스택에는 [스택 할당](#stack-allocation)에 설명 된 대로 이후에 호출 된 함수의 매개 변수에 대 한 공간을 포함 해야 합니다.

## <a name="see-also"></a>참고 항목

[x64 소프트웨어 규칙](../build/x64-software-conventions.md)<br/>
[align](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
