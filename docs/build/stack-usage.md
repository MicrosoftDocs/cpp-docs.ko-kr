---
title: x64 스택 사용
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: b598c33fbdd56630ca3e5ef0da551f38a73baa26
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335536"
---
# <a name="x64-stack-usage"></a>x64 스택 사용

RSP의 현재 주소를 벗어난 모든 메모리는 휘발성으로 간주됩니다: OS 또는 디버거는 사용자 디버그 세션 또는 인터럽트 처리기 중에 이 메모리를 덮어쓸 수 있습니다. 따라서 RSP는 스택 프레임에 값을 읽거나 쓰기전에 항상 설정해야 합니다.

이 섹션에서는 로컬 변수및 **할당내** 의 스택 공간 할당에 대해 설명합니다.

## <a name="stack-allocation"></a>스택 할당

함수의 프롤로그에서는 로컬 변수, 저장된 레지스터, 스택 매개 변수 및 레지스터 매개 변수에 대한 스택 공간을 할당합니다.

매개 변수 영역은 항상 스택의 맨 `alloca` 아래에 있으므로(사용되는 경우에도) 함수 호출 중에 항상 반환 주소에 인접합니다. 여기에는 적어도 네 개의 항목이 포함되어 있지만 호출될 수 있는 함수에 필요한 모든 매개 변수를 보유하기에 충분한 공간이 항상 충분합니다. 매개 변수 자체가 스택에 집에 없는 경우에도 항상 레지스터 매개 변수에 공간이 할당됩니다. callee는 모든 매개 변수에 공간이 할당되었음을 보장합니다. 집 주소는 레지스터 인수에 필요하므로 호출된 함수가 인수 목록(va_list) 또는 개별 인수의 주소를 가져가야 하는 경우 연속 영역을 사용할 수 있습니다. 또한 이 영역은 썽크 실행 및 디버깅 옵션으로 레지스터 인수를 저장하는 편리한 위치를 제공합니다(예: 프롤로그 코드의 집 주소에 저장된 경우 디버깅 중에 인수를 쉽게 찾을 수 있음). 호출된 함수에 4개 미만의 매개 변수가 있더라도 이러한 4개의 스택 위치는 호출된 함수에 의해 효과적으로 소유되며 매개 변수 레지스터 값을 저장하는 것 외에 다른 용도로 호출된 함수에서 사용할 수 있습니다.  따라서 호출자는 함수 호출을 통해 스택의 이 영역에 정보를 저장할 수 없습니다.

함수에서 공간이 동적으로`alloca`할당된 경우 비휘발성 레지스터를 프레임 포인터로 사용하여 스택의 고정된 부분의 베이스를 표시해야 하며 해당 레지스터를 저장하고 프롤로그에 초기화해야 합니다. 사용될 때 `alloca` 동일한 호출자의 동일한 호출 수신자 호출에 대한 호출에는 레지스터 매개 변수에 대해 다른 집 주소가 있을 수 있습니다.

스택은 프롤로그(예: 반환 주소 푸시 후)를 제외하고 는 항상 16바이트 정렬되어 유지되며 특정 프레임 함수 클래스에 대해 [함수 유형에](#function-types) 표시된 경우를 제외하고는 항상 정렬됩니다.

다음은 함수 A가 리프가 아닌 함수 B. Function A의 프롤로그를 호출하는 스택 레이아웃의 예로, 스택 맨 아래에 B가 요구하는 모든 레지스터 및 스택 매개 변수에 대해 이미 공간을 할당했습니다. 호출은 반환 주소를 푸시하고 B의 프롤로그는 로컬 변수, 비휘발성 레지스터 및 함수를 호출하는 데 필요한 공간에 대한 공간을 할당합니다. B가 `alloca`사용하는 경우 로컬 변수/비휘발성 레지스터 저장 영역과 매개 변수 스택 영역 사이에 공간이 할당됩니다.

![AMD 변환 예제](../build/media/vcamd_conv_ex_5.png "AMD 변환 예제")

함수 B가 다른 함수를 호출하면 반환 주소가 RCX의 집 주소 바로 아래에 푸시됩니다.

## <a name="dynamic-parameter-stack-area-construction"></a>동적 매개 변수 스택 영역 구성

프레임 포인터를 사용하는 경우 매개 변수 스택 영역을 동적으로 만드는 옵션이 있습니다. 이 작업은 현재 x64 컴파일러에서 수행되지 않습니다.

## <a name="function-types"></a>함수 형식

기본적으로 두 가지 유형의 함수가 있습니다. 스택 프레임이 필요한 함수를 *프레임 함수라고*합니다. 스택 프레임이 필요하지 않은 함수를 *리프 함수라고*합니다.

프레임 함수는 스택 공간을 할당하거나, 다른 함수를 호출하거나, 비휘발성 레지스터를 저장하거나, 예외 처리를 사용하는 함수입니다. 또한 함수 테이블 항목이 필요합니다. 프레임 함수에는 프롤로그와 에필로그가 필요합니다. 프레임 함수는 스택 공간을 동적으로 할당할 수 있으며 프레임 포인터를 사용할 수 있습니다. 프레임 함수는 이 호출 표준의 모든 기능을 사용할 수 있습니다.

프레임 함수가 다른 함수를 호출하지 않으면 스택을 정렬할 필요가 없습니다(섹션 [스택 할당에서](#stack-allocation)참조).

리프 함수는 함수 테이블 항목을 필요로 하지 않는 함수입니다. RSP를 포함하여 비휘발성 레지스터를 변경할 수 없으므로 함수를 호출하거나 스택 공간을 할당할 수 없습니다. 스택이 실행되는 동안 정렬되지 않은 상태로 둘 수 있습니다.

## <a name="malloc-alignment"></a>malloc 정렬

[malloc은](../c-runtime-library/reference/malloc.md) 기본 정렬이 있고 할당된 메모리 양에 맞을 수 있는 개체를 저장하기 위해 적절하게 정렬된 메모리를 반환하도록 보장됩니다. *기본 정렬은* 정렬 사양 없이 구현에서 지원하는 가장 큰 정렬보다 적거나 동일한 정렬입니다. Visual C++에서는 이 정렬이 `double`8바이트 또는 8바이트에 필요한 정렬입니다. 64비트 플랫폼을 대상으로 하는 코드에서는 16바이트입니다. 예를 들어 4바이트 할당은 4바이트 또는 더 작은 개체를 지원하는 경계에 정렬됩니다.

Visual C++는 정렬을 *확장한*형식을 허용하며, 이 형식은 *오버정렬* 형식이라고도 합니다. 예를 들어 SSE [형식은 __m128](../cpp/m128.md) 및 `__m256`및 는 `__declspec(align( n ))` `n` 8보다 큰 위치를 사용하여 선언된 형식이 확장된 정렬을 갖습니다. 확장 정렬이 필요한 개체에 적합한 경계의 메모리 정렬은 `malloc`에 의해 보장되지 않습니다. 과도하게 정렬된 형식에 메모리를 할당하려면 [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md) 및 관련 함수를 사용합니다.

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md) 16바이트 정렬되어야 하며 프레임 포인터를 사용하려면 추가로 필요합니다.

할당된 스택은 [스택 할당에서](#stack-allocation)설명한 대로 이후에 호출되는 함수의 매개 변수에 대한 공간을 포함해야 합니다.

## <a name="see-also"></a>참고 항목

[x64 소프트웨어 규칙](../build/x64-software-conventions.md)<br/>
[정렬](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
