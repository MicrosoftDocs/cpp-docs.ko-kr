---
title: 오류 및 예외 처리(모던 C++)
ms.date: 05/07/2019
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: bb27a92347b327e22afc4f6bb2fb248c12290cae
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/07/2019
ms.locfileid: "65222150"
---
# <a name="errors-and-exception-handling-modern-c"></a>오류 및 예외 처리(모던 C++)

대부분의 시나리오에서 모던 C++은 논리 오류 및 런타임 오류를 처리하는 기본 방법으로 예외를 사용합니다. 스택에 오류를 감지하는 함수 간의 몇 가지 함수호출이 포함될 수 있고 이를 처리하는 방법을 확인하기 위한 컨텍스트가 있는 경우 특히 더 그렇습니다. 예외는 오류를 감지하여 정보를 호출 스택에 정보를 전달하는 코드에 대한 공식적이고 잘 정의된 방법을 제공합니다.

프로그램 오류는 일반적으로 잘못된 프로그래밍으로 인한 논리 오류, 예를 들어 "범위를 벗어난 인덱스" 오류와 프로그래머가 제어할 수 없는 런타임 오류, 예를 들어 "네트워크 서비스를 사용할 수 없음"의 두 범주로 구분됩니다. C 스타일 프로그래밍과 COM에서 오류 보고는 오류 코드 또는 특정 함수에 대한 상태 코드를 나타내는 값을 반환하거나 호출자가 모든 함수 호출 후 오류가 있었는지 선택적으로 확인할 수 있는 전역 변수를 설정하여 관리합니다. 예를 들어 COM 프로그래밍은 HRESULT 반환 값을 사용하여 호출자에게 오류를 전달하고 Win32 API에는 호출 스택에서 보고된 마지막 오류를 확인하는 GetLastError 함수가 있습니다. 두 경우 모두 호출자가 코드를 인식하고 적절하게 응답할 수 있습니다. 호출자가 오류 코드를 명시적으로 처리하지 않는 경우 프로그램이 경고 없이 중단되거나 계속 잘못된 데이터를 사용하여 실행되고 잘못된 결과를 생성할 수 있습니다.

다음과 같은 이유로 모던 C++에서는 예외를 선호합니다.

- 예외는 호출 코드가 오류 조건을 인식하고 처리하도록 합니다. 예외가 처리되지 않으면 프로그램 실행이 중지됩니다.

- 예외 오류를 처리할 수 있는 호출 스택의 위치로 이동 합니다. 중간 함수는 예외를 전파할 수. 있습니다 다른 레이어와 조정 필요가 없습니다.

- 예외 스택 언와인딩 메커니즘은 예외가 발생된 후 잘 정의된 규칙에 따라 범위의 모든 개체를 제거합니다.

- 예외는 오류를 감지하는 코드 및 오류를 처리하는 코드를 분명히 구분할 수 있습니다.

다음 간단한 예제는 C++에서 예외를 발생(throw)하고 처리(catch)하는 데 필요한 구문을 보여줍니다.

```cpp

#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

C++에서 예외 사용은 C# 및 Java와 같은 언어에서의 예외와 비슷합니다. **try** 블록에서 예외가 *발생*하면 해당 예외의 유형과 일치하는 첫 번째 연관된 **catch** 블록에 의해 포착됩니다. 즉, 실행은 **throw** 문에서 **catch** 문으로 이동합니다. 사용할 수 있는 catch 블록이 없으면 `std::terminate`가 호출되고 프로그램이 종료됩니다. C++에서는 모든 유형이 throw될 수 있습니다. 하지만 `std::exception`에서 직접 또는 간접적으로 파생되는 유형을 throw하는 것이 좋습니다. 이전 예제에서 예외 유형 [invalid_argument](../standard-library/invalid-argument-class.md)는 표준 라이브러리의 [\<stdexcept>](../standard-library/stdexcept.md) 헤더 파일에 정의되어 있습니다. C++은 예외가 발생하면 모든 리소스가 해제되는 **finally** 블록을 제공하지 않으며 필요하지도 않습니다. 스마트 포인터를 사용하는 리소스 획득 초기화(RAII) 관용구는 리소스 정리에 필요한 기능을 제공합니다. 자세한 내용은 [방법: 예외 안전성을 위한 디자인](../cpp/how-to-design-for-exception-safety.md)을 참조합니다. C++ 스택 언와인딩 메커니즘에 대한 자세한 내용은 [예외 및 스택 언와인딩](../cpp/exceptions-and-stack-unwinding-in-cpp.md)을 참조합니다.

## <a name="basic-guidelines"></a>기본 지침

강력한 오류 처리는 모든 프로그래밍 언어에서 까다로운 문제입니다. 예외가 좋은 오류 처리를 지원하는 여러 기능을 제공하기는 하지만 사용자를 대신해 모든 작업을 수행할 수는 없습니다. 예외 메커니즘의 혜택을 누리려면 코드를 디자인할 때 예뢰를 염두에 둡니다.

- 절대 발생하지 않아야 하는 오류를 확인하려면 어설션을 사용합니다. 예외를 사용하여 발생할 수 있는 오류, 예를 들어 공용 함수의 매개 변수에 대한 입력 유효성 검증 오류를 점검하세요. 자세한 정보는 **예외 vs 어설션** 섹션을 참조합니다.

- 오류를 처리하는 코드가 하나 이상의 개입 함수 호출로 오류를 감지하는 코드와 분리될 수 있는 경우 예외를 사용합니다. 오류를 처리하는 코드가 오류를 감지하는 코드에 밀접하게 연결되어 있으면 성능이 중요한 루프에서 오류 코드를 대신 사용할지 고려합니다.

- Throw 하거나 예외를 전파할 수 있는 모든 함수에 대 한 세 가지 예외 보증 중 하나를 제공 합니다: 강력한 보장, 기본 보장 또는 nothrow (noexcept) 보장 합니다. 자세한 내용은 [방법: 예외 안전성을 위한 디자인](../cpp/how-to-design-for-exception-safety.md)합니다.

- 값에 따라 예외를 발생(throw)시키고 참조로 포착(catch)합니다. 처리할 수 없는 것은 포착(catch)하지 않도록 주의합니다.

- C++11에서 더이상 사용되지 않는 예외 사양을 사용하지 마세요. 자세한 내용은 **예외 사양 및 noexcept** 섹션을 참조합니다.

- 가능하다면 표준 라이브러리 예외 형식을 사용합니다. [exception 클래스](../standard-library/exception-class.md) 계층에서 사용자 정의 예외 형식을 파생시킵니다.

- 소멸자 또는 메모리 할당 해제 함수에서 예외가 빠져나오는 것을 허용하지 마세요.

## <a name="exceptions-and-performance"></a>예외 및 성능

예외가 발생하지 않으면 예외 메커니즘은 성능 비용이 매우 적습니다. 예외가 발생하면 스택 통과 및 해제 비용은 함수 호출 비용과 거의 비슷합니다. **try** 블록을 입력한 후 호출 스택을 추적하려면 추가 데이터 구조가 필요하며 예외가 발생하면 스택을 해제하기 위해 추가 지침이 필요합니다. 그러나 대부분의 시나리오에서 성능 및 메모리 사용 공간 비용은 중요하지 않습니다. 성능에 예외가 미치는 부정적인 영향은 매우 메모리 제약이 심한 시스템이나 오류가 정기적으로 발생하고 이를 처리하는 코드가 이를 보고하는 코드와 밀접하게 결합되어 있는, 성능이 중요한 루프에서만 중요합니다. 어떤 경우든 프로파일링하거나 측정하지 않고 예외의 실제 비용을 알 수는 없습니다. 드문 경우이지만 비용이 중요한 경우라도 정확성이 향상되고 유지 관리가 용이하며 잘 설계된 예외 정책에 의해 제공되는 다른 장점에 대해 비교하여 평가할 수 있습니다.

## <a name="exceptions-vs-assertions"></a>예외 vs 어셜션

예외와 어설션은 프로그램에서 런타임 오류를 감지하기 위한 두 가지 고유 메커니즘입니다. 어설션을 사용하여 개발 중에 모든 코드가 올바른 경우 절대로 맞지 않는 조건을 테스트합니다. 예외를 사용하여 이러한 오류를 처리하는 것은 의미가 없습니다. 오류는 코드의 무언가를 수정해야 한다는 것을 나타내며, 프로그램이 런타임 시 복구해야 하는 조건을 나타내지는 않기 때문입니다. 어설션은 명령문에서 실행을 중지하므로 디버거에서 프로그램 상태를 검사할 수 있습니다. 예외는 첫 번째 적절한 catch 핸들러에서 계속 실행됩니다. "파일을 찾을 수 없음" 또는 "메모리 부족"과 같이 코드가 올바른 경우에도 런타임에 발생할 수 있는 오류 조건을 확인하려면 예외를 사용하세요. 복구 과정이 단지 메시지를 로그에 출력하고 프로그램을 종료하더라도 이러한 조건에서 복구하고자 할 수 있습니다. 항상 예외를 사용하여 공용 함수에 대한 인수를 확인하세요. 함수에 오류가 없더라도 사용자가 전달할 수 있는 인수를 완전히 제어하지 못할 수 있습니다.

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>Windows SEH 예외 vs C++ 예외

C 및 C++ 프로그램 모두 Windows 운영 체제에서 구조적 예외 처리(SEH) 메커니즘을 사용할 수 있습니다. SEH의 개념은 SEH는 **try** 및 **catch** 대신 **__try**, **__except** 및 **__finally** 구문을 사용한다는 점을 제외하고는 C++ 예외의 개념과 유사합니다. Microsoft C++ 컴파일러(MSVC)에서는 SEH에 대해 C++ 예외가 구현됩니다. 그러나 C++ 코드를 작성할 때는 C++ 예외 구문을 사용하세요.

SEH에 대한 자세한 내용은 참조 하세요. [구조적 예외 처리(C/C++)](../cpp/structured-exception-handling-c-cpp.md)를 참조합니다.

## <a name="exception-specifications-and-noexcept"></a>예외 사양 및 noexcept

예외 사양은 함수에서 발생할 수 있는 예외를 지정하는 방식으로 C++에 도입되었습니다. 그러나 예외 사양은 실제로 문제가 있는 것으로 나타났으며 C++11 초안 표준에서는 더 이상 사용되지 않습니다. 함수가 예외를 벗어날 수 없음을 나타내는 `throw()`를 제외하고 예외 사양을 사용하지 않는 것이 좋습니다. `throw(`*type*`)` 유형의 예외 사양을 사용해야 하는 경우 MSVC는 특정 방식으로 표준에서 벗어납니다. 자세한 내용은 [예외 사양(throw)](../cpp/exception-specifications-throw-cpp.md)를 참조합니다. `noexcept` 지정자는 `throw()` 대신 선호되는 대안으로 C++11에 도입되었습니다.

## <a name="see-also"></a>참고자료

[방법: 예외 코드와 예외가 아닌 코드 간 인터페이스](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[C++의 진화(모던 C++)](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[C++ 언어 참조](../cpp/cpp-language-reference.md)<br/>
[C++ 표준 라이브러리](../standard-library/cpp-standard-library-reference.md)
