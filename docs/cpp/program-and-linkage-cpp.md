---
title: 번역 단위 및 연결(C++)
ms.date: 12/11/2019
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: 791ec53d4df863b218db463f2b9b9401bf6f466d
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81374326"
---
# <a name="translation-units-and-linkage"></a>변환 단위 및 링크

C++ *프로그램에서는 변수*또는 함수 이름과 같은 기호를 범위 내에서 여러 번 선언할 수 있지만 한 번만 정의할 수 있습니다. 이 규칙은 "하나의 정의 규칙"(ODR)입니다. *선언은* 프로그램에 이름을 도입(또는 다시 도입)합니다. *정의는* 이름을 소개합니다. 이름이 변수를 나타내는 경우 정의는 변수를 명시적으로 초기화합니다. *함수 정의는* 시그니처와 함수 본문으로 구성됩니다. 클래스 정의는 모든 클래스 멤버를 나열 하는 블록 다음에 클래스 이름으로 구성 됩니다. 멤버 함수의 본문은 다른 파일에 별도로 정의할 수 있습니다.

다음 예제에서는 몇 가지 선언을 보여 주며 있습니다.

```cpp
int i;
int f(int x);
class C;
```

다음 예제에서는 몇 가지 정의를 보여 주며 다음과 같은 정의를 보여 주며 다음과 같은 정의를 보여 주며 다음과 같은 정의를 보여 주

```cpp
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```

프로그램은 하나 이상의 *번역 단위로*구성됩니다. 변환 단위는 구현 파일과 직접 또는 간접적으로 포함하는 모든 헤더로 구성됩니다. 구현 파일에는 일반적으로 *cpp* 또는 *cxx의*파일 확장자가 있습니다. 헤더 파일은 일반적으로 *h* 또는 *hpp의*확장명이 있습니다. 각 번역 단위는 컴파일러에 의해 독립적으로 컴파일됩니다. 컴파일이 완료되면 링커는 컴파일된 번역 단위를 단일 *프로그램으로*병합합니다. ODR 규칙위반은 일반적으로 링커 오류로 표시됩니다. 링커 오류는 동일한 이름에 서로 다른 변환 단위에서 두 개의 서로 다른 정의가 있을 때 발생합니다.

일반적으로 여러 파일에 걸쳐 변수를 표시하는 가장 좋은 방법은 헤더 파일에 넣는 것입니다. 그런 다음 선언이 필요한 모든 *cpp* 파일에 #include 지시문을 추가합니다. 헤더 내용 주위에 *포함 가드를* 추가하면 선언하는 이름이 한 번만 정의되도록 할 수 있습니다.

C++20에서는 헤더 파일에 대한 향상된 대안으로 [모듈이](modules-cpp.md) 도입됩니다.

경우에 따라 *cpp* 파일에서 전역 변수 또는 클래스를 선언해야 할 수도 있습니다. 이러한 경우 컴파일러와 링커에게 이름에 어떤 종류의 *연결이* 있는지 알려주는 방법이 필요합니다. 링크유형은 개체 이름이 한 파일에만 적용되는지 아니면 모든 파일에만 적용되는지 여부를 지정합니다. 연결 개념은 전역 이름에만 적용됩니다. 링크의 개념은 범위 내에서 선언된 이름에는 적용되지 않습니다. 범위는 함수 또는 클래스 정의와 같은 둘러싸는 중괄호 집합에 의해 지정됩니다.

## <a name="external-vs-internal-linkage"></a>외부 와 내부 연결

*자유 함수는* 전역 또는 네임스페이스 범위에서 정의된 함수입니다. 비const 전역 변수 및 자유 함수는 기본적으로 *외부 연결이 있습니다.* 프로그램의 모든 번역 단위에서 볼 수 있습니다. 따라서 다른 전역 개체는 해당 이름을 가질 수 없습니다. *내부 연결이* 있거나 *연결이 없는* 기호는 선언된 변환 단위 내에서만 볼 수 있습니다. 이름에 내부 연결이 있는 경우 다른 번역 단위에 동일한 이름이 있을 수 있습니다. 클래스 정의 또는 함수 본문으로 선언된 변수에는 연결이 없습니다.

전역 이름을 **명시적으로 정적으로**선언하여 내부 연결을 갖도록 강제할 수 있습니다. 이렇게 하면 가시성이 선언된 동일한 변환 단위로 제한됩니다. 이 컨텍스트에서 **정적** 은 로컬 변수에 적용할 때와 다른 것을 의미합니다.

다음 개체에는 기본적으로 내부 연결이 있습니다.

- const 개체
- constexpr 개체
- 형식 정의
- 네임스페이스 범위의 정적 개체

const 개체 외부 연결을 제공하려면 외부 **로** 선언하고 값을 할당합니다.

```cpp
extern const int value = 42;
```

자세한 내용은 [extern을](extern-cpp.md) 참조하십시오.

## <a name="see-also"></a>참고 항목

[기본 개념](../cpp/basic-concepts-cpp.md)
