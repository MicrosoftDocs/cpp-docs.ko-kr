---
title: 캐스트 표기법 및 safe_cast의 도입&lt; &gt; | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- casting
- C-style casts and /clr, motivation for new cast notation
- safe_cast keyword [C++]
ms.assetid: 4eb1d000-3b93-4394-a37b-8b8563f8dc4d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 6b9432b40099f9893d7fd270faf5375646fb0493
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33111642"
---
# <a name="cast-notation-and-introduction-of-safecastltgt"></a>캐스트 표기법 및 safe_cast의 도입&lt;&gt;
캐스트 표기법 Visual c + + Managed Extensions for c + + 변경 되었습니다.  
  
 초기 구조를 만들어 보다 어렵습니다 경험을을 기존 구조를 수정 합니다. 더 적은 자유도 않으며 솔루션 뿐만 아니라 이상적인 재구성 이란 이었지만 기존 구조적 한계 사이의 있습니다.  
  
 언어 확장은 또 다른 예입니다. 초기 1990 년대에서으로 개체 지향 프로그래밍이 중요 한 패러다임을 c + +의 형식 안전 다운 캐스트 기능에 대 한 필요성 목소리가 높아졌습니다. 다운 캐스팅은 기본 클래스 포인터 또는 참조에 대 한 포인터 또는 참조 파생된 클래스의 사용자를 명시적으로 변환 합니다. 캐스팅이 명시적 캐스트가 필요 합니다. 이유는 기본 클래스 포인터의 실제 형식이 런타임;의 요소 컴파일러 따라서 확인할 수 없습니다 것입니다. 또는 호출과 가상 함수 호출 처럼 다운 캐스트 기능은 동적 확인 형식이 필요 합니다. 이 두 가지 질문 시 발생합니다.  
  
-   이유는 다운 캐스트 되어야 개체 지향 패러다임에 필요 합니까? 가상 함수 메커니즘으로 충분 하지 않은? 즉, 이유 하나 주장 하지 다운 캐스트 (또는 모든 종류의 캐스트)에 대 한 모든 요구 디자인 오류인?  
  
-   다운 캐스트를 지 원하는 c + +에서 문제를 이유 해야 하나요? 즉, 것은 문제가 아니며 Smalltalk 같은 개체 지향 언어에서 (또는 이후에 Java와 C#)? 어떤 어려운 다운 캐스트는 기능을 지원 하는 c + +에 대 한 것 입니까?  
  
 가상 함수 패밀리에 공통 형식 종속 알고리즘을 나타냅니다. (여기에서 고려 하지는 ISO c + +에서 지원 되지 않는 CLR 프로그래밍에 사용할 수 있고 흥미로운 디자인 대안을 나타내는 인터페이스). 클래스 계층 구조는은 공통 인터페이스 (가상 함수)와 일련의 응용 프로그램의 실제 패밀리 형식을 나타내는 구체적 파생된 클래스를 선언 하는 추상 기본 클래스에서 해당 제품군의 디자인은 일반적으로 표현 도메인입니다.  
  
 A `Light` 컴퓨터 생성 이미지 (CGI) 응용 프로그램 도메인, 예를 들어, 계층 구조와 같은 공통 특성을 가집니다 `color`, `intensity`, `position`, `on`, `off`등입니다. 스포트라이트, 방향성 광원, 비 방향 light (태양 대기) 또는 처럼 조명 아마도 빛 인지 관계 없이 공통 인터페이스를 사용 하 여 여러 광원을 제어할 수 있습니다. 이 경우 해당 가상 인터페이스에 게 특정 light 유형 좋기는 필요는 없습니다. 그러나 프로덕션 환경에서 속도 필수입니다. 하나를 다운 캐스트 하 가상 메커니즘을 사용 하는 대신 수행할 수 없습니다는 호출의 인라인 실행을 수행 하 여 각 메서드를 명시적으로 호출 합니다.  
  
 따라서 c + +에서 다운 캐스트 이유 중 하나는 런타임 성능이 크게 향상 그런 가상 메커니즘을 표시 하지 않는 것입니다. (이 수동 최적화 자동화 연구의 활성 영역 인지 확인 합니다. 그러나 더 어렵습니다 해결 교체 명시적으로 사용 비용을 초과 하는 `register` 또는 `inline` 키워드입니다.)  
  
 다운 캐스트에 두 번째 이유는 다형성의 이중 특성을 벗어납니다. 한 가지 방법은 다형성은 폼의 수동 및 동적 쌍 나뉩니다.  
  
 가상 호출 (및 다운 캐스트 기능은) 나타내는 다형성의 동적 사용: 프로그램 실행의 특정 인스턴스에 있는 기본 클래스 포인터의 실제 형식에 따라 동작을 수행 하는 하나입니다.  
  
 하지만 파생된 된 클래스 개체에는 기본 클래스 포인터를 할당는 수동 형태의 다형성; 다형성 전송 메커니즘으로 사용 합니다. 이것은의 기본 사용 `Object`, 예를 들어 사전 일반 CLR 프로그래밍의 합니다. 수 동적으로 사용 되는 경우 일반적으로 선택한 전송 및 저장소에 대 한 기본 클래스 포인터 너무 추상 되는 인터페이스를 제공 합니다. `Object`예를 들어; 인터페이스를 통해 약 5 개의 메서드를 제공 합니다. 더 구체적인 동작 요구 명시적 캐스트 합니다. 예를 들어 스포트라이트의 각도 또는 속도 감쇠를 조정 하려면, 해야 다운 캐스트 명시적으로 합니다. 하위 종류 패밀리 내 가상 인터페이스 많은 자식 가능한 모든 메서드가의 상위 집합이 될 수 없으므로 하므로 다운 캐스트 기능은 항상 필요 개체 지향 언어입니다.  
  
 안전한 다운 캐스트 경우 걸린 이유가 c + + 너무 오래 하나를 추가 하는 다음 기능 개체 지향 언어에서 필요? 포인터의 런타임 형식에 대 한 정보를 사용할 수 있도록 하는 방법에 문제가 있는 것입니다. 가상 함수의 경우 런타임 정보에에서 설정 되어 두 부분 컴파일러에서:  
  
-   추가 가상 테이블 포인터 멤버를 포함 하는 클래스 개체 (시작 나; 클래스 개체의 끝 부분에는 자체는 흥미로운 기록이) 적절 한 가상 테이블을 해결 하는 합니다. 스포트라이트 개체 스포트라이트 가상 테이블, 방향성 광원, 방향 밝은 가상 테이블 및 등을 해결 하는 예를 들어  
  
-   각 가상 함수에 연결 된 테이블에서 슬롯을 고정 하 고 실제 인스턴스를 호출 하는 테이블 내에 저장 된 주소로 표시 됩니다. 예를 들어 가상 `Light` 소멸자 슬롯 0, 연관 될 수 있으며 `Color` 슬롯 1, 및 등입니다. 컴파일 타임에 설정 되 고 최소한의 오버 헤드를 나타내는 있기 때문에 이것이 고정적인 경우 효율적인 방법입니다.  
  
 그런 다음 문제를 형식 정보를 사용할 수 있도록 포인터 또는 두 번째 주소를 추가 하 여 어떤 종류의 인코딩 형식을 직접 추가 하 여 c + + 포인터의 크기를 변경 하지 않고 사용 방법이 있습니다. 하지 않는 것이 이러한 프로그래머 (및 프로그램)에 따라 허용 여전히 널리 사용 사용자 커뮤니티 이었던 개체 지향 패러다임-를 사용 하지 않도록 결정 하는 합니다. 다른 가능한 다형 클래스 형식에 대 한 특별 한 포인터를 도입 하 하지만이 방법은 복잡 하며 포인터 산술 연산 문제에 특히 두 하기가 어렵습니다. 것도 하지에 허용 되는 현재 연결된 형식, 동적으로 업데이트 된 각 포인터를 연결 하는 실행 시간 테이블을 유지 합니다.  
  
 이 문제는 서로 다르지만 합법적인 프로그래밍 관점을 포함 하는 사용자 커뮤니티 있습니다. 솔루션은 해당 위해서라도 뿐 아니라 상호 운용할 수 있는 기능 수 있도록 하는 두 명의 커뮤니티 간 절충을 여야 합니다. 즉, 양쪽에서 제공 하는 솔루션 사용할 수 있도록 가능성이 솔루션 완벽 하 게 되도록 마지막으로 구현. 실제 해결 다형 클래스의 정의 흥미로운: 가상 함수를 포함 하는 다형 클래스입니다. 다형 클래스는 동적 형식 안전 다운 캐스트를 지원합니다. 모든 다형 클래스는 각각 연결 된 가상 테이블에 해당 추가 포인터 멤버를 포함 하기 때문에 유지 관리-포인터-를 주소로 문제가 해결 되었습니다. 따라서 연결 된 형식 정보를 확장 된 가상 테이블 구조에 저장할 수 있습니다. 형식이 안전한 다운 캐스트 비용 시설 사용자에 게 거의 대부분 지역화 됩니다.  
  
 다음 문제가 형식 안전 다운 캐스트 연산자 구문 했습니다. 캐스트 인 ISO c + + 위원회는 원래 제안 되지 않은 캐스트 구문을이 예제와 같이 사용:  
  
```  
spot = ( SpotLight* ) plight;  
```  
  
 하지만이 거부 되었습니다. 위원회에서 사용자가 캐스팅 비용을 제어 하도록 허용 하지 않았습니다. 동적 형식이 안전한 다운 캐스트은 이전에 안전 하지 않지만 정적 동일한 구문을 사용 하는 경우 캐스트 표기법 되는 대체 하 고 사용자에 게 불필요 한 비용이 아마도 너무 높은 경우에 런타임 오버 헤드를 표시 하지 않을 수 있는 기능이 없습니다.  
  
 일반적으로 c + +에서는 항상는 메커니즘은 컴파일러에서 지 원하는 기능을 억제 하기. 예를 들어 해제할 수 있습니다 가상 메커니즘 클래스 범위 연산자를 사용 하거나 (`Box::rotate(angle)`) 하거나 클래스 개체 (보다는 포인터 또는 클래스의 참조)를 통해 가상 메서드를 호출 합니다. 두 번째 억제 언어에 필요 하지 않은 폼의 선언에서 임시의 생성을 억제 비슷합니다 구현 문제의 품질:  
  
```  
// compilers are free to optimize away the temporary  
X x = X::X( 10 );  
```  
  
 제안서를 이전 상태로 만드는 추가 고려 사항에 대 한 여러 대체 표기법이 고려 되었으며 되었고 가지 위원회 폼의 하므로 (`?type`)는 알 수-표시 된 즉, 동적 특성입니다. 이 표기법을 사용 하면 정적 또는 동적 두 형식 사이 전환 하는 기능 아무도 하지만 너무 되어 기쁩니다. 따라서부터 다시 했습니다. 세 번째 및 성공이 이제 표준 `dynamic_cast<type>`, 4 개의 새 스타일의 캐스트 표기법의 집합에 일반화 된입니다.  
  
 ISO-c + +에서 `dynamic_cast` 반환 `0` 적절 하지 않은 포인터 형식에 적용 하 고 throw 하는 경우는 `std::bad_cast` 참조 형식에 적용 하는 동안 예외가 발생 했습니다. Managed extensions for c + +에서는 적용 `dynamic_cast` 항상 반환 됩니다 (포인터 표현)로 인해 관리 되는 참조 형식에 `0`합니다. `__try_cast<type>` 함수와 유사한 버전으로의 변형을 throw 된 예외에 도입 된는 `dynamic_cast`throw 한다는 점을 제외 하 고, `System::InvalidCastException` 캐스팅에 실패 하는 경우.  
  
```  
public __gc class ItemVerb;  
public __gc class ItemVerbCollection {  
public:  
   ItemVerb *EnsureVerbArray() [] {  
      return __try_cast<ItemVerb *[]>  
         (verbList->ToArray(__typeof(ItemVerb *)));  
   }  
};  
```  
  
 새 구문에서 `__try_cast` 로 변경 되었습니다 `safe_cast`합니다. 새 구문에서 동일한 코드 조각은 다음과 같습니다.  
  
```  
public ref class ItemVerb;  
public ref class ItemVerbCollection {  
public:  
   array<ItemVerb^>^ EnsureVerbArray() {  
      return safe_cast<array<ItemVerb^>^>  
         ( verbList->ToArray( ItemVerb::typeid ));  
   }  
};  
```  
  
 관리 되는 환경에서 코드를 확인할 수 없는 상태로 유지 하는 방법으로 형식 간의 캐스팅 하는 프로그래머의 기능을 제한 하 여 확인할 수 있는 코드에 대 한 허용 해야 합니다. 새 구문으로 표시 하는 동적 프로그래밍 패러다임의 가장 중요 한 측면입니다. 이러한 이유로 이전 스타일 캐스트의 인스턴스는 내부적으로로 변경 런타임 캐스트 하므로 예입니다.  
  
```  
// internally recast into the   
// equivalent safe_cast expression above  
( array<ItemVerb^>^ ) verbList->ToArray( ItemVerb::typeid );   
```  
  
 반면에 다형성 활성 및 수동 모드 모두에서 제공 되므로 하위 비가상 API에 액세스 하기 위해 다운 캐스트를 수행 하는 데 필요한 경우에 따라. 이 발생할 수 있습니다, 그리고 예를 들어 클래스의 구성원으로 하는 주소 어떤 (전송 메커니즘으로 동적 다형성) 계층 구조 내에서 입력 하는 특정 프로그램 컨텍스트 내에서 실제 인스턴스 이라고 합니다. 이 경우 캐스팅 런타임 검사가 필요 하면 오버 헤드가 너무 수 있습니다. 새 구문은 프로그래밍 언어의 관리 되는 시스템 역할을 하는 것을 하는 경우 컴파일 타임 수 있는 방법을 제공 해야 (즉, 정적) 다운 캐스트 합니다. 바로 이러한 이유로의 응용 프로그램은 `static_cast` 표기법 다운 캐스트 컴파일 타임을 계속 수행할 수:  
  
```  
// ok: cast performed at compile-time.   
// No run-time check for type correctness  
static_cast< array<ItemVerb^>^>(verbList->ToArray(ItemVerb::typeid));  
```  
  
 문제는 대개 수행 하는 프로그래머는 `static_cast` 올바르고; 판단이, 즉 관리 코드를 확인할 수 있으려면 수 없습니다. 이 네이티브 동적 프로그램 패러다임 보다 더 긴급 한 문제는 아니지만 시스템 언어는 사용자를 차단할 수는 정적 및 런타임 캐스트 사이 전환 하는 기능을 프로그래밍 내 충분 하지 않습니다.  
  
 그러나 경우는 성능과 새 구문에서 문제 네이티브 프로그래밍의 경우에 이전 스타일의 캐스트 표기법 및 새로운 스타일 간에 성능에서 차이점이 `static_cast` 표기법입니다. 새 구문에서 이전 스타일의 캐스트 표기법은 새 스타일의 사용 보다 훨씬 더 비쌉니다 하지만 `static_cast` 표기법입니다. 이유는 컴파일러에 내부적으로 예외를 throw 하는 런타임 검사에는 이전 스타일 표기법을 사용 하는 변환입니다. 또한도 변경 코드의 실행 프로필-시키는 응용 프로그램 종료 상태로 확인할 수 없는 예외가 발생 수 있으므로 동일한 오류가 발생 하는 경우 해당 예외를 발생 하지 않습니다는 `static_cast` 표기법이 사용 되었습니다. 새 스타일으로 표시 하 여에 이렇게 구성 하면만 클러스터링 하나 있습니다. 하지만; 실패 한 경우에 그렇지 않으면 이전 스타일 표기법 명확한 이유를 훨씬 느리게 실행을 사용 하는 프로그램 하면 다음과 같은 C 프로그래머 문제 비슷합니다.  
  
```  
// pitfall # 1:   
// initialization can remove a temporary class object,   
// assignment cannot  
Matrix m;  
m = another_matrix;  
  
// pitfall # 2: declaration of class objects far from their use  
Matrix m( 2000, 2000 ), n( 2000, 2000 );  
if ( ! mumble ) return;  
```  
  
## <a name="see-also"></a>참고 항목  
 [일반적인 언어 변경 사항 (C + + /cli CLI)](../dotnet/general-language-changes-cpp-cli.md)   
 [/Clr을 사용한 C 스타일 캐스트 (C + + /cli CLI)](../windows/c-style-casts-with-clr-cpp-cli.md)   
 [safe_cast](../windows/safe-cast-cpp-component-extensions.md)