---
title: 캐스트 표기법 및 safe_cast 미치는&lt; &gt; | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- casting
- C-style casts and /clr, motivation for new cast notation
- safe_cast keyword [C++]
ms.assetid: 4eb1d000-3b93-4394-a37b-8b8563f8dc4d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 88e8165bde08b65b4f078c4b48863c2088132fca
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/19/2018
ms.locfileid: "46427866"
---
# <a name="cast-notation-and-introduction-of-safecastltgt"></a>캐스트 표기법 및 safe_cast의 소개&lt;&gt;

캐스트 표기법 Visual c + + Managed Extensions for c + + 변경 되었습니다.

기존 구조를 수정 하는 것은 초기 구조를 작성 하는 보다 어렵습니다 환경입니다. 더 적은 자유도 되며 솔루션에서 절충 이상적인 재구성 사이의 란 귀하는 기존 구조적 종속성을 지정 합니다.

언어 확장은 다른 예입니다. 1990 년대 초반에 다시 개체 지향 프로그래밍이으로 중요 한 패러다임을 c + +의 형식 안전 다운 기능에 대해 필요 목소리가 높아졌습니다. 다운 캐스팅은 기본 클래스 포인터 또는 포인터에 대 한 참조 또는 파생된 클래스 참조의 사용자를 명시적으로 변환 합니다. 캐스팅이 명시적 캐스트가 필요 합니다. 이유는 기본 클래스 포인터의 실제 형식은 런타임에; 측면 컴파일러 따라서 없습니다 확인 합니다. 또는 호출과 가상 함수 호출 처럼 다운 기능을 하려면 일종의 동적 확인 합니다. 이 두 가지 질문을 발생 시킵니다.

- 이유는 다운 캐스트 되어야 개체 지향 패러다임에 필요 합니까? 가상 함수 메커니즘으로 충분 하지 않은? 즉, 이유 요구할 수 없습니다 하나 다운 캐스트 (또는 모든 종류의 캐스트)에 대 한 필요가 디자인 오류는?

- 다운 캐스트를 지원 해야 c + +의 문제를 될 하는 이유 결국 있지 Smalltalk와 같은 개체 지향 언어의 문제 (또는 이후에, Java 및 C#)? 어떤 어려운 다운 기능을 지원 하는 c + +에 대 한 것 입니까?

가상 함수 형식 패밀리 일반적인 형식 종속 알고리즘을 나타냅니다. (여기에서 고려 하지 인터페이스와 흥미로운 디자인 대안을 나타내는 CLR 프로그래밍에 사용할 수 있지만 ISO-C + +에서 지원 되지 않습니다). 해당 제품군의 디자인은 일반적으로 응용 프로그램의 실제 제품군 형식을 나타내는 구체적 파생된 클래스의 집합과 공통 인터페이스 (가상 함수)를 선언 하는 추상 기본 클래스가 있는 클래스 계층 구조를 표현 도메인입니다.

A `Light` 컴퓨터 생성 이미지 (CGI) 응용 프로그램 도메인, 예를 들어, 계층 구조와 같은 일반적인 특성을 가집니다 `color`를 `intensity`, `position`를 `on`, `off`등. 특정 광원을 추천, 방향성 광원, 비 방향 조명을 (태양 인지) 또는 차 광원 등 인지에 관계 없이 공통 인터페이스를 사용 하 여 여러 광원을 제어할 수 있습니다. 이 경우 해당 가상 인터페이스를 특정 light 형식으로 다운 캐스팅 필요는 없습니다. 그러나 프로덕션 환경에서는 속도 필수입니다. 하나는 다운 될 수 있습니다 하 고 명시적으로 하는 경우 이렇게 하 여 가상 메커니즘을 사용 하는 대신 인라인 실행 호출을 수행할 수 있습니다 각 메서드를 호출 합니다.

따라서 c + +에서 다운 이유 중 하나는 런타임 성능 크게 향상에 대 한 보답 가상 메커니즘은 표시 하지 않으려면입니다. (참고가 수동 최적화의 자동화는 활성 영역을 연구 합니다. 그러나 더 어렵습니다 보다 명시적으로 사용의 대체를 해결 하는 `register` 또는 `inline` 키워드입니다.)

다운 벗어난 다형성의 이중 특성을 두 번째 이유입니다. 단방향 다형성은 폼의 수동 및 동적 쌍 나뉩니다.

가상 호출을 다운 기능을 나타내는 다형성의 동적 사용: 프로그램 실행의 특정 인스턴스에서 해당 기본 클래스 포인터의 실제 형식에 따라 작업을 수행 하는 하나입니다.

하지만 파생된 된 클래스 개체에는 기본 클래스 포인터를 할당는 수동 형태의 다형성; 이 전송 메커니즘으로는 다형성을 사용 합니다. 기본 사용 하는 것이 `Object`, 예를 들어, 사전 일반 CLR 프로그래밍에서 합니다. 수 동적으로 사용 하는 경우 일반적으로 선택한 전송 및 저장소에 대 한 기본 클래스 포인터는 너무 추상적 하는 인터페이스를 제공 합니다. `Object`예를 들어; 인터페이스를 통해 약 5 개의 메서드를 제공 합니다. 더 구체적인 동작 요구 명시적인 다운 합니다. 예를 들어, 스포트라이트의 각도, 속도 감쇠를 조정 하고자 하는 경우는 해야 다운 명시적으로 합니다. 하위 형식의 제품군 내에서 가상 인터페이스를 여러 자식에 가능한 모든 메서드가의 상위 집합이 될 수 없으므로 및 개체 지향 언어를 내 다운 기능을 항상 필요 합니다 때문입니다.

다운 안전한 이유 않은 c + + 시간이 오래 걸리는 하나를 추가 하려면 다음 기능을 개체 지향 언어에서 필요? 포인터의 런타임 형식에 대 한 정보를 사용할 수 있도록 하는 방법에 문제가 있는 것입니다. 가상 함수의 경우 런타임 정보는 설정 두 부분으로 컴파일러에서:

- 클래스 개체에 추가 가상 테이블 포인터 멤버를 포함 (시작 또는 끝 클래스 개체;는 그 자체로 흥미로운 기록이) 적절 한 가상 테이블 주소입니다. 스포트라이트를 추천 가상 테이블을, 방향성 광원, 광원 방향 가상 테이블 및 등을 해결 하는 예를 들어,

- 각 가상 함수에 연결 된 테이블의 슬롯을 고정 하 고 실제 인스턴스를 호출 하는 테이블 내에 저장 된 주소로 표시 됩니다. 예를 들어, 가상 `Light` 소멸자 슬롯 0에 연관 될 수 있으며 `Color` 슬롯 1, 및 등입니다. 왜냐하면 고정적인 경우 효율적인 전략을 컴파일 타임에 설정 되 고 최소한의 오버 헤드를 나타내는입니다.

그런 다음 문제를 형식 정보를 사용할 수 있도록 포인터에 대 한 두 번째 주소를 추가 하거나 직접 일종의 인코딩 형식을 추가 하 여 c + + 포인터의 크기를 변경 하지 않고 있는 방법이 있습니다. 프로그래머 (및 프로그램)는 허용 가능한 것이 주된 사용자 커뮤니티는 여전히 개체 지향 패러다임-를 사용 하지 않도록 하는 합니다. 또 다른 가능성 클래스 다형 형식에 대 한 특별 한 포인터를 소개 했지만이 혼동 되 고 포인터 산술 연산 문제가 특히 여 두 가지 하기가 어렵습니다. 또한 됩니다 현재 연결 된 해당 형식이 고이 동적으로 업데이트를 사용 하 여 각 포인터를 연결 하는 런타임 테이블 유지 관리를 허용 합니다.

문제는 사용자 집단에 서로 다르지만 합법적인 프로그래밍 펼치고 있는 합니다. 솔루션은 해당 위해서라도 뿐 아니라 상호 운용할 수 있도록 허용 하 여 두 집단에서 절충을 이어야 합니다. 즉, 양쪽에서 제공 하는 솔루션은 적합 하지 않을 가능성이 솔루션 완벽 하 게 되도록 마지막으로 구현 합니다. 다형 클래스의 정의 중심으로 하는 실제 해상도: 다형 클래스는 가상 함수를 포함 하는 것입니다. 다형 클래스는 동적 형식 안전을 다운 캐스트를 지원합니다. 모든 다형 클래스는 각각 연결 된 가상 테이블에 해당 추가 포인터 멤버를 포함 하기 때문에 유지 관리는-포인터-를 주소로 문제가 해결 되었습니다. 따라서 연결된 형식 정보를 확장 된 가상 테이블 구조에 저장할 수 있습니다. 형식이 안전한 다운 비용 기능의 사용자에 게 지역화 (거의) 됩니다.

형식이 안전한 다운 캐스트를 사용 하 여 다음 문제가 구문입니다. 캐스트 이기 때문에이 예제와 같이 표시 되지 않은 캐스트 구문을 사용 하는 ISO-C + + 위원회에 원래 제안:

```
spot = ( SpotLight* ) plight;
```

하지만이 캐스팅 하는 비용을 제어 하는 사용자를 허용 하지 않아 위원회에서 거부 되었습니다. 동적 형식이 안전한 다운은 정적 이전에 안전 하지 않은 하지만 동일한 구문을 사용 하는 경우 캐스트 표기법에 대체 되며 사용자가 불필요 하 고 너무 가장 비용이 많이 드는 경우 런타임 오버 헤드를 표시 하지 않을 수 있는 기능이 없습니다.

일반적으로 c + +에서는 항상는 메커니즘은 컴파일러에서 지 원하는 기능을 표시 하지 않으려면입니다. 예를 들어, 해제할 수 있습니다 가상 메커니즘 클래스 범위 연산자를 사용 하거나 (`Box::rotate(angle)`) 클래스 개체 (보다는 포인터나 참조를 해당 클래스의)를 통해 가상 메서드를 호출 하는 방법입니다. 두 번째 억제 없어도 언어 이지만 구현 문제를 유사한 형식의 선언에 임시 생성을 억제 하는 품질:

```
// compilers are free to optimize away the temporary
X x = X::X( 10 );
```

제안서를 이전 상태로 만드는 추가 고려 사항에 대 한 여러 대체 표기법이 논의 되었습니다 하 고 폼의 위원회로 돌아온 것은 되므로 (`?type`), 해당 임의의-표시 하는 동적 특성, 합니다. 이 기능을 통해 사용자-정적 또는 동적-두 가지 형식 사이 전환 하는 기능 되었지만 아무도 너무 만족 합니다. 다시 그리기 보드에 있었습니다. 세 번째 및 성공적인 표기법은 이제 표준 `dynamic_cast<type>`, 4 개의 새 스타일 캐스트 표기법의 집합에는 일반화 된 합니다.

ISO-c + +에서 `dynamic_cast` 반환 `0` 부적절 한 포인터 형식에 적용 하 고 throw를 `std::bad_cast` 참조 형식에 적용 하는 동안 예외가 발생 합니다. Managed extensions for c + +를 적용 `dynamic_cast` 항상 반환 됩니다 (때문에 대 한 포인터 표현) 관리 되는 참조 형식으로 `0`입니다. `__try_cast<type>` 소개 된 함수와 유사한 버전으로의 variant를 throw 하는 예외를 `dynamic_cast`throw 한다는 점을 제외 하 고, `System::InvalidCastException` 캐스트가 실패 한 경우.

```
public __gc class ItemVerb;
public __gc class ItemVerbCollection {
public:
   ItemVerb *EnsureVerbArray() [] {
      return __try_cast<ItemVerb *[]>
         (verbList->ToArray(__typeof(ItemVerb *)));
   }
};
```

새 구문의 `__try_cast` 는으로 다시 캐스팅 되었습니다 `safe_cast`합니다. 새 구문에서 동일한 코드 조각은 다음과 같습니다.

```
public ref class ItemVerb;
public ref class ItemVerbCollection {
public:
   array<ItemVerb^>^ EnsureVerbArray() {
      return safe_cast<array<ItemVerb^>^>
         ( verbList->ToArray( ItemVerb::typeid ));
   }
};
```

관리 되는 세계에서 확인할 수 없는 코드를 유지 하는 방법으로 형식 간에 캐스팅 하는 프로그래머의 기능을 제한 하 여 확인할 수 있는 코드에 대 한 허용 하도록 반드시 합니다. 새 구문으로 표현 되는 동적 프로그래밍 패러다임의 중요 한 측면입니다. 이러한 이유로 이전 스타일 캐스트의 인스턴스 내부에서 변경 됩니다 런타임 캐스팅으로 하므로 예입니다.

```
// internally recast into the
// equivalent safe_cast expression above
( array<ItemVerb^>^ ) verbList->ToArray( ItemVerb::typeid );
```

반면에 다형성 활성 및 수동 모드에서 제공 되므로 하위 형식의 가상이 아닌 API에 액세스 하기 위해 다운 캐스트를 수행 하는 데 필요한 경우가 있습니다. 이 발생할 수 있습니다, 그리고 예를 들어, 클래스의 멤버를 사용 하 여 하는 주소 어떤 (전송 메커니즘으로 수동 다형성) 계층 구조 내에서 입력 되지만 특정 프로그램 컨텍스트 내에서 실제 인스턴스를 라고 합니다. 이 경우 캐스팅 되는 런타임 검사를 하지 오버 헤드가 너무 수 있습니다. 새 구문 프로그래밍 언어를 관리 되는 시스템으로 사용할 경우 컴파일 타임 수 있는 방법을 제공 해야 합니다 (즉, 정적) 다운 합니다. 이유는 응용 프로그램을 `static_cast` 표기법 다운 컴파일 시간을 계속 수행할 수:

```
// ok: cast performed at compile-time.
// No run-time check for type correctness
static_cast< array<ItemVerb^>^>(verbList->ToArray(ItemVerb::typeid));
```

문제는 수행 하는 프로그래머는 보장할 방법이 있는지는 `static_cast` 올바르고 내려온; 즉, 관리 코드를 확인할 수 있는 방법이 있으면입니다. 네이티브 동적 프로그램 패러다임 보다 더 긴급 한 문제 이지만 프로그래밍 언어는 사용자를 허용 하지 않도록 정적 및 런타임 캐스팅을 전환할 수는 시스템 내에서 충분 하지 않습니다.

하지만 경우는 성능과 새 구문에서 문제 네이티브 프로그래밍에는 이전 스타일의 캐스트 표기법 및 새 스타일 간의 성능에서 차이가 없습니다 `static_cast` 표기법입니다. 새 구문에서는 이전 스타일 캐스트 표기법의 새로운 스타일의 사용 보다 훨씬 더 비쌉니다 하지만 `static_cast` 표기법입니다. 원인은 컴파일러 예외를 throw 하는 런타임 검사에 이전 스타일 표기법을 사용 하는 내부적으로 변환 합니다. 또한도 변경 코드의 실행 프로필-아마도 신중 하 게 응용 프로그램을 가져오는 예외로 발생 수 있으므로 동일한 오류가 발생 하는 경우 해당 예외를 발생 하지 않습니다는 `static_cast` 표기법 사용 되었습니다. 하나에 새 스타일 표기법을 사용 하는 데 도움이 됩니다 생각할 수 있습니다. 실패 하는 경우에 그렇지 않은 경우 이전 스타일 표기법을 사용 하 여 실행 속도가 크게 저하에 대 한 표시는 그 이유를 이해 하는 프로그램 하면 같은 C 프로그래머가 문제 비슷합니다.

```
// pitfall # 1:
// initialization can remove a temporary class object,
// assignment cannot
Matrix m;
m = another_matrix;

// pitfall # 2: declaration of class objects far from their use
Matrix m( 2000, 2000 ), n( 2000, 2000 );
if ( ! mumble ) return;
```

## <a name="see-also"></a>참고 항목

[일반적인 언어 변경 사항(C++/CLI)](../dotnet/general-language-changes-cpp-cli.md)<br/>
[/Clr을 사용한 C 스타일 캐스트 (C + + /cli CLI)](../windows/c-style-casts-with-clr-cpp-cli.md)<br/>
[safe_cast](../windows/safe-cast-cpp-component-extensions.md)