---
title: 링커 도구 오류 LNK2001
ms.date: 05/17/2017
f1_keywords:
- LNK2001
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
ms.openlocfilehash: dba197be71fc77af6d95c2ec62053928ac1627cc
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/31/2018
ms.locfileid: "50631662"
---
# <a name="linker-tools-error-lnk2001"></a>링커 도구 오류 LNK2001

확인 되지 않은 외부 기호 "*기호*"

컴파일된 코드에서는 참조 또는 호출 *기호*하지만에 라이브러리 또는 개체 파일을 링커에 지정 기호가 정의 되지 않습니다.

이 오류 메시지 오류가 나옵니다 [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md)합니다. LNK1120 오류를 해결 하려면 모든 LNK2001 및 LNK2019 오류를 수정 해야 합니다.

## <a name="possible-causes"></a>가능한 원인

이 오류는 여러 가지 있지만 링커 없는 변수나 함수에 대 한 참조를 포함 하는 모든 *해결*를 찾거나에 대 한 정의입니다. 기호가 없을 때 확인할 수 있습니다 *선언*, 하지는 않지만 *정의*이므로 정의 다른 소스 파일 또는 라이브러리에 있을 수 있습니다. 링커에서 기호, 참조 되었지만 정의 되지 않는 경우 오류가 발생 합니다.

### <a name="coding-issues"></a>코딩 문제

이 오류 때문일 수 있습니다 일치 하지 않는 경우 소스 코드에 모듈 정의 (.def) 파일입니다. 예를 들어 변수 이름을 지정 하면 `var1` 하나의 c + + 소스 파일 및으로 액세스 하려고 `VAR1` 다른이 오류가 생성 됩니다. 이 문제를 해결 하려면 사용은 일관 되 게 철자를 입력 하 고 이름은 대/소문자입니다.

이 오류를 사용 하는 프로젝트에서 발생할 수 있습니다 [함수 인라이닝](../../error-messages/tool-errors/function-inlining-problems.md) 헤더 파일이 아닌 소스 파일에서 함수를 정의 하는 경우. 인라인 된 함수를 정의 하는 소스 파일 외부 볼 수 없습니다. 이 문제를 해결 하려면 선언 된 헤더에 인라인 된 함수를 정의 합니다.

이 오류는 사용 하지 않고 c + + 프로그램에서 C 함수를 호출 하는 경우에 발생할 수 있습니다는 `extern "C"` C 함수를 선언 합니다. 컴파일러는 C 및 c + + 코드에 대 한 다른 내부 기호 명명 규칙을 사용 하 고 기호를 확인 하는 경우 링커는에 대 한 내부 기호 이름입니다. 이 문제를 해결 하려면 사용는 `extern "C"` C 함수를 사용 하면 컴파일러가 해당 기호에 대 한 내부 C 명명 규칙을 사용 하는 c + + 코드에서의 모든 선언 래퍼입니다. 컴파일러 옵션 [/Tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) 하 고 [/Tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) 컴파일러가 파일 이름 확장명에 관계 없이, 파일을 c + + 또는 C로 컴파일합니다. 이러한 옵션에는 내부 함수 이름은 원하는 것과 다른 될 수 있습니다.

이 오류는 함수 또는 외부 링크가 없는 데이터를 참조 하려고 하 여 발생할 수 있습니다. C + +에서 인라인 함수 및 `const` 으로 명시적으로 지정 되지 않은 데이터는 내부 링크 `extern`합니다. 이 문제를 해결 하려면 사용 하 여 명시적 `extern` 정의 원본 파일 외부 기호에 대 한 선언을 참조 합니다.

이 오류를 때문일 수 있습니다는 [함수 본문 또는 변수 누락](../../error-messages/tool-errors/missing-function-body-or-variable.md) 정의 합니다. 이 오류는 선언, 정의 하지, 변수, 함수 또는 클래스 코드에서 때 일반적인 합니다. 컴파일러는 함수 프로토타입이 필요 또는 `extern` 함수 코드 또는 변수에 공백이 있기 때문에 오류 않고 링커에서 개체 파일을 생성 하는 변수 선언 함수에 대 한 호출 또는 변수에 대 한 참조를 확인할 수 없습니다 예약 되어 있습니다. 이 문제를 해결 하려면 모든 참조 된 함수 및 변수는 소스 파일 또는 링크에 포함 된 라이브러리에서 정의 완벽 하 게 되어 있는지 확인 합니다.

이 오류를 반환 및 매개 변수 형식 또는 함수 정의 일치 하지 않는 호출 규칙을 사용 하는 함수 호출에서 발생할 수 있습니다. C + + 개체 파일에 [이름 데코레이션](../../error-messages/tool-errors/name-decoration.md) 기호의 경우 일치 호출에 사용 되는 트 데코 레이 된 최종 함수 이름에는 호출 규칙, 클래스 또는 네임 스페이스 범위 및 함수의 반환 형식과 매개 변수 형식은 통합 다른 개체 파일에서 함수 확인 됩니다. 이 문제를 해결 하려면 선언, 정 및 모든 함수 호출에이 동일한 범위, 유형 및 호출 규칙을 사용 해야 합니다.

함수 프로토타입이 클래스 정의에 포함 되지 경우 c + + 코드에서이 오류가 발생할 수 있습니다 [구현을 포함](../../error-messages/tool-errors/missing-function-body-or-variable.md) 함수 후 호출 합니다. 이 문제를 해결 하려면 클래스의 멤버를 선언 된 모든 호출에 대 한 정의 제공 해야 합니다.

이 오류는 추상 기본 클래스에서 순수 가상 함수를 호출 하려고 하 여 발생할 수 있습니다. 순수 가상 함수에는 기본 클래스 구현이 없습니다. 이 문제를 해결 하려면 가상 함수 호출 모두 구현 해야 합니다.

함수 내에서 선언 된 변수를 사용 하 여이 오류를 발생할 수 있습니다 ([지역 변수](../../error-messages/tool-errors/automatic-function-scope-variables.md)) 해당 함수의 범위 밖에 있습니다. 이 문제를 해결 하려면 범위에 있지 않은 변수에 대 한 참조를 제거 하거나 상위 범위 변수를 이동 합니다.

이 오류는 ATL 프로젝트의 릴리스 버전 빌드 CRT 시작 코드가 필요 하다는 메시지를 생성 하는 경우에 발생할 수 있습니다. 이 문제를 해결 하려면 다음 중 하나를 수행

- 제거 `_ATL_MIN_CRT` 전처리기의 목록에서 CRT 시작 코드를 포함할 수 있도록 정의 합니다. 참조 [일반 속성 페이지 (프로젝트)](../../ide/general-property-page-project.md) 자세한 내용은 합니다.

- 가능 하면 CRT 시작 코드는 CRT 함수에 대 한 호출을 제거 합니다. 대신에 해당 하는 Win32를 사용 합니다. 사용 예를 들어 `lstrcmp` 대신 `strcmp`합니다. CRT 시작 코드를 필요로 하는 알려진된 함수를 사용 하는 문자열을 부동 소수점 함수 같습니다.

### <a name="compilation-and-link-issues"></a>컴파일 및 연결 문제

프로젝트 라이브러리에 대 한 참조를 손실 된 경우이 오류가 발생할 수 있습니다 (합니다. LIB) 또는 개체 (합니다. OBJ) 파일입니다. 이 문제를 해결 하려면 프로젝트에 필요한 라이브러리 또는 개체 파일에 대 한 참조를 추가 합니다. 자세한 내용은 [링커 입력 파일로.lib 파일](../../build/reference/dot-lib-files-as-linker-input.md)합니다.

사용 하는 경우이 오류가 발생할 수 있습니다 합니다 [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) 하거나 [/Zl](../../build/reference/zl-omit-default-library-name.md) 옵션입니다. 이러한 옵션을 지정 하는 경우 명시적으로 포함 하지 않으면 필요한 코드를 포함 하는 라이브러리 프로젝트에 연결 되지 않습니다. 이 문제를 해결 하려면 명시적으로 링크 명령줄에 사용 되는 모든 라이브러리를 포함 합니다. 이러한 옵션을 사용 하는 경우 많은 이름이 없습니다. CRT 또는 표준 라이브러리 함수를 표시 하는 경우 명시적으로 링크의 CRT 및 표준 라이브러리 Dll 또는 라이브러리 파일을 포함 합니다.

사용 하 여 컴파일하는 경우는 **/clr** 옵션,.cctor에 대 한 누락 된 참조 될 수 있습니다. 이 문제를 해결 하려면 참조 [혼합 어셈블리 초기화](../../dotnet/initialization-of-mixed-assemblies.md) 자세한 내용은 합니다.

응용 프로그램의 디버그 버전을 빌드할 때 릴리스 모드 라이브러리에 링크 하면이 오류가 발생할 수 있습니다. 마찬가지로, 옵션을 사용 하는 경우 **/MTd** 하거나 **/MDd** 정의 또는 `_DEBUG` 다음 릴리스 라이브러리에 연결, 다른 문제와 많은 잠재적인 해결 되지 않은 외부 소요 될 수 있습니다. 유사한 문제를 해도 디버그 라이브러리를 사용 하 여 릴리스 모드 빌드를 연결 합니다. 이 문제를 해결 하려면 디버그 빌드에서 디버그 라이브러리를 사용 하 고 소매 라이브러리에 일반 정품에서 빌드에 있는지를 확인 합니다.

이 오류는 라이브러리의 버전에서 코드 기호 참조 하지만 다른 버전의 링커에 라이브러리를 제공 하는 경우에 발생할 수 있습니다. 일반적으로 개체 파일 또는 라이브러리가 다른 버전의 컴파일러에 대해 작성 된 혼합할 수 없습니다. 새 버전에서 제공 되는 라이브러리는 이전 버전에서는 그 반대로 포함 된 라이브러리에서 찾을 수 없는 기호를 포함할 수 있습니다. 이 문제를 해결 하려면 함께 연결 하기 전에 모든 개체 파일 및 동일한 버전의 컴파일러를 사용 하 여 라이브러리를 빌드하십시오.

- 도구 &#124; 옵션 &#124; 프로젝트 &#124; VC + + 디렉터리 대화 상자에서 라이브러리 파일 선택를 사용 하면 라이브러리 검색 순서를 변경할 수 있습니다. 프로젝트의 속성 페이지 대화 상자에서 링커 폴더는 만료 될 수 있는 경로 포함할 수도 있습니다.

- 이 문제는 (아마도 다른 위치로), 새 SDK가 설치 되어 있고 검색 순서를 새 위치를 가리키도록 업데이트 되지 않습니다 나타날 수 있습니다. 일반적으로 경로 추가 하는 새 SDK에 포함 및 라이브러리의 기본 Visual c + + 위치 앞에 디렉터리입니다. 또한 포함 된 경로 포함 하는 프로젝트는 유효 하지만 다른 위치에 설치 되어 있는 새 버전에서 추가 된 새 기능에 대 한 오래 된 이전 경로 가리키기도 합니다.

- 명령줄에서 빌드를 사용자 고유의 환경 변수를 만든 도구, 라이브러리 및 헤더 파일에 경로 일관 된 버전으로 확인 합니다. 자세한 내용은 참조 하세요. [명령줄 빌드에 맞는 경로 및 환경 변수 설정](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)

현재 없는 표준 [c + + 명명](../../error-messages/tool-errors/name-decoration.md) 컴파일러 공급 업체나 다른 컴파일러 버전 간에 합니다. 따라서 다른 컴파일러로 컴파일한 개체 파일을 링크할 수 하지 않고 동일한 명명 스키마를 생성을 오류 LNK2001.

[혼합 인라인이 아닌 컴파일 옵션](../../error-messages/tool-errors/function-inlining-problems.md) 서로 다른 모듈에서 해도 LNK2001이 발생할 수 있습니다. C + + 라이브러리 함수 인라이닝 설정으로 만들어집니다 (**/Ob1** 하거나 **/ob2**) 하지만 해제 함수를 설명 하는 해당 헤더 파일의 인라인 (없습니다 `inline` 키워드),이 오류 발생합니다. 이 문제를 해결 하려면 함수 정의 `inline` 다른 소스 파일에 포함할 헤더 파일에 있습니다.

사용 하는 경우는 `#pragma inline_depth` 컴파일러 지시문에 있어야는 [2 이상 집합의 값](../../error-messages/tool-errors/function-inlining-problems.md), 이용할 수 있는지 확인 합니다 [/Ob1](../../build/reference/ob-inline-function-expansion.md) 또는 [/ob2](../../build/reference/ob-inline-function-expansion.md) 컴파일러 옵션.

이 오류는 링크를 생략 하면 리소스 전용 DLL을 만들 때 /NOENTRY 옵션입니다. 이 문제를 해결 하려면 /NOENTRY 옵션을 link 명령에 추가 합니다.

이 오류는 프로젝트에서 잘못 되었습니다. /subsystem은 또는 /ENTRY 설정을 사용 하는 경우에 발생할 수 있습니다. 예를 들어 콘솔 응용 프로그램을 작성 하 고 /subsystem 경우 확인 되지 않은 외부 오류가 발생 한 `WinMain`합니다. 이 문제를 해결 하려면 프로젝트 형식에 대 한 옵션을 일치 해야 합니다. 이러한 옵션 및 진입점에 대 한 자세한 내용은 참조 하세요. 합니다 [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md) 하 고 [/ENTRY](../../build/reference/entry-entry-point-symbol.md) 링커 옵션입니다.

### <a name="exported-symbol-issues"></a>내보낸된 기호 문제

이 오류는.def 파일에 나열 된 내보내기는 찾을 수 없을 때 발생 합니다. 이 올바르게 입력 되어, c + + 데코 레이트 된 이름을 사용 하 여 존재 하지 않는 발생할 수 있습니다. .Def 파일에 데코레이팅된 이름을 사용 하지 않습니다. 이 문제를 해결 하려면 불필요 한 내보내기를 제거 하 고 사용 하 여 `extern "C"` 내보낸된 기호에 대 한 선언 합니다.

## <a name="what-is-an-unresolved-external-symbol"></a>확인 되지 않은 외부 기호 란?

A *기호* 함수 또는 컴파일된 개체 파일 또는 라이브러리에서 내부적으로 사용 하는 전역 변수 이름입니다. 기호가 *정의* 함수 본문에 대 한 컴파일된 코드를 배치할 전역 변수 또는 함수에 대 한 저장소가 할당 하는 개체 파일에 있습니다. *외부 기호* 기호입니다 *참조*즉, 사용 또는 개체 파일에 호출 되지만 다른 라이브러리 또는 개체 파일에 정의 합니다. *기호를 내보내는* 개체 파일 또는 정의 하는 라이브러리에서 공개적으로 사용할 수 있는 것입니다. 링커 해야 *해결*를 찾거나 개체 파일에서 참조 하는 응용 프로그램 또는 DLL에 연결 될 때 모든 외부 기호에 대해 일치 하는 정의 합니다. 연결 된 파일에서 일치 하는 내보낸된 기호를 검색 하 여 외부 기호를 확인할 수 없는 경우에 링커 오류가 발생 합니다.

## <a name="use-the-decorated-name-to-find-the-error"></a>데코 레이트 된 이름을 사용 하 여 오류를 찾으려면

C + + 컴파일러 및 링커 사용 [이름 데코레이션](../../error-messages/tool-errors/name-decoration.md)라고도 *이름 꾸미기*, 변수 형식 또는 반환 형식, 매개 변수 형식, 범위 및 호출 하는 방법에 대 한 추가 정보를 인코딩합니다 규칙 기호 이름에는 함수입니다. 이 트 데코 레이 된 이름에는 링커가 외부 기호를 확인 하기 위해 검색 기호 이름이입니다.

추가 정보를 사용 하면 기호 이름의 일부가, 함수 또는 변수 선언의 정확히 일치 하지 않는 함수 또는 변수를 정의 하는 경우 연결 오류가 발생할 수 있습니다. 이 동일한 헤더 파일은 소스 파일을 컴파일하는 경우 다른 컴파일러 플래그를 사용 하는 경우 호출 코드 및 정의 코드 모두에 사용 됩니다 하는 경우에 발생할 수 있습니다. 예를 들어, 코드를 사용 하 여 컴파일된 경우이 오류가 발생할 수 있습니다 합니다 `__vectorcall` 기본값을 사용 하 여 호출 클라이언트를 필요로 하는 라이브러리에 연결 하는 호출 규칙에 있지만 `__cdecl` 또는 `__fastcall` 호출 규칙입니다. 이 경우 기호가 일치 하지 않는 호출 규칙 다르기 때문에

이러한 종류의 오류 원인을 찾을 수, 있도록 링커 오류 메시지 모두 "친숙 한 이름을 표시," 소스 코드 및 확인 되지 않은 외부 기호에 대 한 괄호 안에 트 데코 레이 된 이름에 사용 되는 이름입니다. 다른 트 데코 레이 된 이름과 비교할 수 있게 되기가 데코레이팅된 이름을 변환 하는 방법을 알 필요가 없습니다. 예상 되는 기호가 이름과 실제 기호 이름을 비교할 컴파일러를 사용 하 여 포함 된 명령줄 도구를 사용할 수 있습니다.

- [/exports](../../build/reference/dash-exports.md) 하 고 [/기호](../../build/reference/symbols.md) DUMPBIN 명령줄 도구의 옵션을.dll 및 개체 또는 라이브러리 파일에 정의 된 기호를 검색할 수 있습니다. 내보낸 데코레이팅된는 트 데코 레이 된 이름이 링커가 검색 하는 이름 일치를 확인 하려면이 사용할 수 있습니다.

경우에 따라 링커가 기호의 트 데코 레이 된 이름을만 보고할 수 있습니다. 데코 레이트 되지 않은 형태의 데코레이팅된 이름 가져오려면 UNDNAME 명령줄 도구를 사용할 수 있습니다.

## <a name="additional-resources"></a>추가 자료

LNK2001에 대 한 가능한 원인 및 해결 하는 방법에 대 한 자세한 내용은 스택 오버플로 질문을 참조 하세요 [정의 되지 않은 참조/확인 되지 않은 외부 기호 오류가 이란 무엇 이며 어떻게 해결 하나요?](http://stackoverflow.com/q/12573816/2002113)합니다.

