---
title: 링커 도구 오류 LNK2001
ms.date: 12/19/2019
f1_keywords:
- LNK2001
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
ms.openlocfilehash: b6d1e53d8f057ddc93e2dfde65cb951d247dfcc0
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/20/2019
ms.locfileid: "75302135"
---
# <a name="linker-tools-error-lnk2001"></a>링커 도구 오류 LNK2001

> 확인 되지 않은 외부 기호 "*symbol*"

컴파일된 코드는 *기호*에 대 한 참조 또는 호출을 수행 합니다. 기호는 링커에서 검색 한 라이브러리나 개체 파일에 정의 되어 있지 않습니다.

이 오류 메시지 다음에 심각한 오류 [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md)이 발생 합니다. 오류 LNK1120를 해결 하려면 먼저 모든 LNK2001 및 LNK2019 오류를 수정 합니다.

LNK2001 오류를 가져오는 방법에는 여러 가지가 있습니다. 모든 함수는 링커가 *확인할*수 없는 함수 또는 변수에 대 한 *참조* 를 포함 하거나에 대 한 정의를 찾을 수 있습니다. 컴파일러는 코드에서 기호를 *선언* 하지 않는 경우를 식별할 수 있지만, 코드에서 기호를 *정의* 하지 않는 경우에는 식별할 수 있습니다. 정의가 다른 소스 파일 또는 라이브러리에 있을 수 있기 때문입니다. 코드가 기호를 참조 하지만 정의 된 적이 없는 경우 링커에서 오류를 생성 합니다.

## <a name="what-is-an-unresolved-external-symbol"></a>확인 되지 않은 외부 기호는 무엇입니까?

*기호* 는 함수 또는 전역 변수의 내부 이름입니다. 컴파일된 개체 파일 또는 라이브러리에서 사용 되거나 정의 되는 이름 형식입니다. 전역 변수는 저장소에 할당 된 개체 파일에 정의 됩니다. 함수는 함수 본문에 대 한 컴파일된 코드가 배치 되는 개체 파일에 정의 됩니다. *외부 기호* 는 하나의 개체 파일에서 참조 되지만 다른 라이브러리나 개체 파일에 정의 되어 있습니다. *내보낸 기호* 는 해당 기호를 정의 하는 개체 파일이 나 라이브러리에서 공개적으로 사용할 수 있는 기호입니다.

응용 프로그램 또는 DLL을 만들려면 사용 된 모든 기호에 정의가 있어야 합니다. 링커에서는 각 개체 파일에서 참조 하는 모든 외부 기호에 대해 일치 하는 정의를 *확인*하거나 찾아야 합니다. 외부 기호를 확인할 수 없으면 링커가 오류를 생성 합니다. 링커가 연결 된 파일에서 내보낸 일치 하는 기호 정의를 찾을 수 없음을 의미 합니다.

## <a name="compilation-and-link-issues"></a>컴파일 및 링크 문제

이 오류는 다음과 같은 경우에 발생할 수 있습니다.

- 프로젝트에 라이브러리에 대 한 참조가 없는 경우 (. LIB) 또는 개체 (. OBJ) 파일입니다. 이 문제를 해결 하려면 필요한 라이브러리 또는 개체 파일에 대 한 참조를 프로젝트에 추가 합니다. 자세한 내용은 [링커 입력으로 사용할 Lib 파일](../../build/reference/dot-lib-files-as-linker-input.md)을 참조 하세요.

- 프로젝트에 라이브러리에 대 한 참조가 있는 경우 (. LIB) 또는 개체 (. OBJ) 파일을 다시 사용 하려면 다른 라이브러리의 기호가 필요 합니다. 종속성을 유발 하는 함수를 호출 하지 않는 경우에도이 문제가 발생할 수 있습니다. 이 문제를 해결 하려면 다른 라이브러리에 대 한 참조를 프로젝트에 추가 합니다. 자세한 내용은 [연결에 대 한 클래식 모델 이해: 타는 대로 기호 가져오기](https://devblogs.microsoft.com/oldnewthing/20130108-00/?p=5623)를 참조 하세요.

- [/Nodefaultlib](../../build/reference/nodefaultlib-ignore-libraries.md) 또는 [/zl](../../build/reference/zl-omit-default-library-name.md) 옵션을 사용 하는 경우 이러한 옵션을 지정 하는 경우 필요한 코드를 포함 하는 라이브러리는 프로젝트에 명시적으로 포함 되지 않은 경우 프로젝트에 연결 되지 않습니다. 이 문제를 해결 하려면 사용 하는 모든 라이브러리를 링크 명령줄에 명시적으로 포함 합니다. 이러한 옵션을 사용할 때 CRT 또는 표준 라이브러리 함수 이름이 누락 된 경우 링크에 CRT 및 표준 라이브러리 Dll 또는 라이브러리 파일을 명시적으로 포함 합니다.

- **/Clr** 옵션을 사용 하 여 컴파일하는 경우입니다. `.cctor`에 대 한 참조가 누락 되었을 수 있습니다. 이 문제를 해결 하는 방법에 대 한 자세한 내용은 [혼합 어셈블리 초기화](../../dotnet/initialization-of-mixed-assemblies.md)를 참조 하세요.

- 응용 프로그램의 디버그 버전을 빌드할 때 릴리스 모드 라이브러리에 연결 하는 경우 마찬가지로 **/MTd** 또는 **/mdd** 옵션을 사용 하거나 `_DEBUG`를 정의 하 고 릴리스 라이브러리에 연결 하는 경우 다른 문제가 있을 수 있습니다. 디버그 라이브러리를 사용 하 여 릴리스 모드 빌드를 연결 하는 경우에도 유사한 문제가 발생 합니다. 이 문제를 해결 하려면 디버그 빌드에서 디버그 라이브러리를 사용 하 고 소매 빌드에서 일반 정품 라이브러리를 사용 해야 합니다.

- 코드가 하나의 라이브러리 버전에서 기호를 참조 하지만 라이브러리의 다른 버전을 연결 하는 경우 일반적으로 다른 버전의 컴파일러에 대해 빌드된 개체 파일이 나 라이브러리는 혼합할 수 없습니다. 한 버전에서 제공 되는 라이브러리에는 다른 버전에 포함 된 라이브러리에서 찾을 수 없는 기호가 포함 될 수 있습니다. 이 문제를 해결 하려면 함께 연결 하기 전에 동일한 버전의 컴파일러를 사용 하 여 모든 개체 파일 및 라이브러리를 빌드합니다. 자세한 내용은 [ C++ 이진 호환성 2015-2019](../../porting/binary-compat-2015-2017.md)을 참조 하세요.

- 라이브러리 경로가 만료 된 경우 **도구 > 옵션 > 프로젝트 > VC + + 디렉터리** 대화 상자에 있는 **라이브러리 파일** 선택에서 라이브러리 검색 순서를 변경할 수 있습니다. 프로젝트의 속성 페이지 대화 상자에 있는 링커 폴더에는 오래 된 경로가 포함 될 수도 있습니다.

- 새 Windows SDK 설치 (다른 위치에 있을 수 있음) 새 위치를 가리키도록 라이브러리 검색 순서를 업데이트 해야 합니다. 일반적으로 새 SDK include 및 lib 디렉터리의 경로를 기본 시각적 C++ 위치 앞에 배치 해야 합니다. 또한 포함 된 경로를 포함 하는 프로젝트는 유효 하지만 오래 된 경로를 계속 가리킬 수 있습니다. 다른 위치에 설치 된 새 버전에서 추가 된 새 기능에 대 한 경로를 업데이트 합니다.

- 명령줄에서 빌드하는 경우 사용자 고유의 환경 변수를 만들었습니다. 도구, 라이브러리 및 헤더 파일에 대 한 경로가 일관 된 버전으로 이동 하는지 확인 합니다. 자세한 내용은 [명령줄 빌드에 대 한 경로 및 환경 변수 설정](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md) 을 참조 하세요.

## <a name="coding-issues"></a>코딩 문제

이 오류는 다음과 같은 이유로 인해 발생할 수 있습니다.

- 소스 코드 또는 모듈 정의 (.def) 파일의 대/소문자가 일치 하지 않습니다. 예를 들어 하나의 C++ 소스 파일에서 변수 이름을 `var1` 하 고 다른 파일에서 `VAR1`으로 액세스 하려고 하면이 오류가 발생 합니다. 이 문제를 해결 하려면 일관 되 고 대/소문자 이름을 사용 합니다.

- [함수 인라이닝을](../../error-messages/tool-errors/function-inlining-problems.md)사용 하는 프로젝트입니다. 헤더 파일이 아닌 소스 파일에 `inline`로 함수를 정의 하는 경우 발생할 수 있습니다. 인라인 함수는 해당 함수를 정의 하는 소스 파일 외부에서 볼 수 없습니다. 이 문제를 해결 하려면 선언 된 헤더에서 인라인 함수를 정의 합니다.

- C 함수에 대 한 `extern "C"` C++ 선언을 사용 하지 않고 프로그램에서 c 함수를 호출 합니다. 컴파일러는 C 및 C++ 코드에 대해 서로 다른 내부 기호 명명 규칙을 사용 합니다. 내부 기호 이름은 기호를 확인할 때 링커가 찾는 기능입니다. 이 문제를 해결 하려면 C++ 코드에서 사용 되는 c 함수의 모든 선언에 대해 `extern "C"` 래퍼를 사용 합니다. 그러면 컴파일러가 해당 기호에 대 한 c 내부 명명 규칙을 사용 합니다. 컴파일러 옵션 [/tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) 및 [/tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) 를 통해 컴파일러는 파일 이름 확장명 C++ 에 관계 없이 각각 또는 C로 파일을 컴파일합니다. 이러한 옵션은 내부 함수 이름이 필요한 것과 다를 수 있습니다.

- 외부 링크가 없는 함수 또는 데이터를 참조 하려고 했습니다. 에서 C++`extern`로 명시적으로 지정 되지 않은 경우 인라인 함수 및 `const` 데이터에 내부 링크가 있습니다. 이 문제를 해결 하려면 정의 소스 파일 외부에서 참조 되는 기호에 명시적 `extern` 선언을 사용 합니다.

- [함수 본문 또는 변수 정의가 누락 되었습니다](../../error-messages/tool-errors/missing-function-body-or-variable.md) . 이 오류는 선언 하는 경우 일반적으로 코드에서, 변수, 함수 또는 클래스를 정의 하지 않습니다. 컴파일러는 오류 없이 개체 파일을 생성 하는 함수 프로토타입 또는 `extern` 변수 선언만 필요 하지만 함수 코드 또는 예약 된 변수 공간이 없으므로 링커에서는 함수에 대 한 호출 또는 변수에 대 한 참조를 확인할 수 없습니다. 이 문제를 해결 하려면 연결 하는 소스 파일이 나 라이브러리의 모든 참조 된 함수 및 변수를 정의 해야 합니다.

- 반환 및 매개 변수 형식이 나 함수 정의의 매개 변수와 일치 하지 않는 호출 규칙을 사용 하는 함수 호출입니다. 개체 C++ 파일에서 [이름 데코레이션](../../error-messages/tool-errors/name-decoration.md) 은 호출 규칙, 클래스 또는 네임 스페이스 범위, 함수의 반환 및 매개 변수 형식을 인코딩합니다. 인코딩된 문자열은 최종 데코레이팅된 함수 이름의 일부가 됩니다. 이 이름은 링커에서 다른 개체 파일의 함수에 대 한 호출을 확인 하거나 일치 시키는 데 사용 됩니다. 이 문제를 해결 하려면 함수 선언, 정의 및 호출이 모두 동일한 범위, 형식 및 호출 규칙을 사용 하는지 확인 합니다.

- C++클래스 정의에 함수 프로토타입을 포함 하지만 함수 [구현을 포함](../../error-messages/tool-errors/missing-function-body-or-variable.md) 하지 않는 경우 호출 하는 코드입니다. 이 문제를 해결 하려면 호출 하는 모든 클래스 멤버에 대 한 정의를 제공 해야 합니다.

- 추상 기본 클래스에서 순수 가상 함수를 호출 하려고 한 경우 순수 가상 함수에는 기본 클래스 구현이 없습니다. 이 문제를 해결 하려면 모든 호출 된 가상 함수가 구현 되어 있는지 확인 합니다.

- 함수 ([지역 변수](../../error-messages/tool-errors/automatic-function-scope-variables.md)) 내에서 선언 된 변수를 해당 함수의 범위 밖으로 사용 하려고 합니다. 이 문제를 해결 하려면 범위에 없는 변수에 대 한 참조를 제거 하거나 변수를 더 높은 범위로 이동 합니다.

- ATL 프로젝트의 릴리스 버전을 빌드할 때 CRT 시작 코드가 필요 하다는 메시지를 생성 합니다. 이 문제를 해결 하려면 다음 중 하나를 수행 하십시오.

  - 전처리기 시작 코드를 포함할 수 있도록 전처리기 목록에서 `_ATL_MIN_CRT` 제거 합니다. 자세한 내용은 [일반 속성 페이지 (프로젝트)](../../build/reference/general-property-page-project.md)를 참조 하세요.

  - 가능 하면 CRT 시작 코드가 필요한 CRT 함수에 대 한 호출을 제거 합니다. 대신 해당 Win32에 해당 하는를 사용 합니다. 예를 들어 `strcmp` 대신 `lstrcmp`을 사용합니다. CRT 시작 코드가 필요한 알려진 함수는 문자열 및 부동 소수점 함수 중 일부입니다.

## <a name="consistency-issues"></a>일관성 문제

현재는 컴파일러 공급 업체 간의 [ C++ 이름 데코레이션](../../error-messages/tool-errors/name-decoration.md) 표준 또는 동일한 컴파일러의 서로 다른 버전 사이에는 없습니다. 다른 컴파일러로 컴파일된 개체 파일은 동일한 명명 스키마를 사용 하지 않을 수 있습니다. 연결 하면 오류 LNK2001이 발생할 수 있습니다.

서로 다른 모듈에서 [인라인 및 비 인라인 컴파일 옵션을 혼합](../../error-messages/tool-errors/function-inlining-problems.md) 하면 LNK2001이 발생할 수 있습니다. 함수 인라이닝을 C++ on으로 설정 하 여 라이브러리를 만든 경우 ( **/ob1** 또는 **/ob1**) 함수를 설명 하는 해당 헤더 파일에 인라인 해제 (`inline` 키워드가 없음)가 발생 하면이 오류가 발생 합니다. 이 문제를 해결 하려면 다른 소스 파일에 포함 하는 헤더 파일에 `inline` 함수를 정의 합니다.

`#pragma inline_depth` 컴파일러 지시문을 사용 하는 경우 [2 이상의 값](../../error-messages/tool-errors/function-inlining-problems.md)을 설정 했는지 확인 하 고 [/ob1](../../build/reference/ob-inline-function-expansion.md) 또는 [/ob2](../../build/reference/ob-inline-function-expansion.md) 컴파일러 옵션을 사용 해야 합니다.

리소스 전용 DLL을 만들 때/NOENTRY 링크 옵션을 생략 하면이 오류가 발생할 수 있습니다. 이 문제를 해결 하려면/NOENTRY 옵션을 link 명령에 추가 합니다.

프로젝트에서 잘못 된/SUBSYSTEM 또는/ENTRY 설정을 사용 하는 경우이 오류가 발생할 수 있습니다. 예를 들어 콘솔 응용 프로그램을 작성 하 고/SUBSYSTEM: WINDOWS를 지정 하는 경우 `WinMain`에 대해 확인 되지 않은 외부 오류가 생성 됩니다. 이 문제를 해결 하려면 프로젝트 형식에 대 한 옵션과 일치 하는지 확인 합니다. 이러한 옵션 및 진입점에 대 한 자세한 내용은 [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md) and [/entry](../../build/reference/entry-entry-point-symbol.md) 링커 옵션을 참조 하세요.

## <a name="exported-def-file-symbol-issues"></a>.Def 파일 기호 문제를 내보냈습니다.

이 오류는 .def 파일에 나열 된 내보내기를 찾을 수 없을 때 발생 합니다. 내보내기가 없거나, 철자가 잘못 되었거나, 데코레이팅된 이름을 사용 C++ 하기 때문일 수 있습니다. .Def 파일에는 데코레이팅된 이름이 사용 되지 않습니다. 이 문제를 해결 하려면 불필요 한 내보내기를 제거 하 고 내보낸 기호에 대 한 `extern "C"` 선언을 사용 합니다.

## <a name="use-the-decorated-name-to-find-the-error"></a>데코레이팅된 이름을 사용 하 여 오류를 찾습니다.

컴파일러 C++ 와 링커는 이름 *구분*이 라고도 하는 [이름 데코레이션](../../error-messages/tool-errors/name-decoration.md)을 사용 합니다. 이름 데코레이션은 해당 기호 이름에서 변수의 형식에 대 한 추가 정보를 인코딩합니다. 함수의 기호 이름은 반환 형식, 매개 변수 형식, 범위 및 호출 규칙을 인코딩합니다. 이 데코레이팅된 이름은 링커가 외부 기호를 확인 하기 위해 검색 하는 기호 이름입니다.

함수 또는 변수의 선언이 함수 또는 변수의 정의와 *정확히* 일치 하지 않는 경우 링크 오류가 발생할 수 있습니다. 모든 차이가 일치 시킬 기호 이름의 일부가 되기 때문입니다. 호출 코드와 정의 코드 모두에 동일한 헤더 파일이 사용 되는 경우에도 오류가 발생할 수 있습니다. 다른 컴파일러 플래그를 사용 하 여 소스 파일을 컴파일하는 경우에 발생 하는 한 가지 방법이 있습니다. 예를 들어 `__vectorcall` 호출 규칙을 사용 하도록 코드가 컴파일되면 기본 `__cdecl` 또는 `__fastcall` 호출 규칙을 사용 하 여 클라이언트에서 호출 하는 라이브러리에 연결 합니다. 이 경우 호출 규칙은 다르므로 기호가 일치 하지 않습니다.

원인을 찾을 수 있도록 오류 메시지에 두 가지 버전의 이름이 표시 됩니다. "이름", 소스 코드에 사용 되는 이름 및 데코레이팅된 이름 (괄호 안에 표시)을 모두 표시 합니다. 데코레이팅된 이름을 해석 하는 방법을 알 필요가 없습니다. 여전히 다른 데코레이팅된 이름과 비교할 수 있습니다. 명령줄 도구를 통해 예상 되는 기호 이름과 실제 기호 이름을 찾고 비교할 수 있습니다.

- DUMPBIN 명령줄 도구의 [/내보내기](../../build/reference/dash-exports.md) 및 [/SYMBOLS](../../build/reference/symbols.md) 옵션은 여기에서 유용 합니다. 이러한 파일은 .dll 및 개체 또는 라이브러리 파일에 정의 된 기호를 찾는 데 도움이 될 수 있습니다. 기호 목록을 사용 하 여 내보낸 데코레이팅된 이름이 링커가 검색 하는 데코레이팅된 이름과 일치 하는지 확인할 수 있습니다.

- 경우에 따라 링커는 기호에 대 한 데코레이팅된 이름만 보고할 수 있습니다. UNDNAME.EXE 명령줄 도구를 사용 하 여 데코 레이트 되지 않은 형식의 데코레이팅된 이름을 가져올 수 있습니다.

## <a name="additional-resources"></a>추가 자료

자세한 내용은 Stack Overflow 질문 ["정의 되지 않은 참조/확인 되지 않은 외부 기호 오류 및 수정 하는 방법"](https://stackoverflow.com/q/12573816/2002113)을 참조 하세요.
