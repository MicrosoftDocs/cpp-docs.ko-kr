---
description: '자세한 정보: 컴파일러 오류 C3500 ~ C3999'
title: 컴파일러 오류 C3500 ~ C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: bf0075e9064b7e03c0b733119300ee90d77884fc
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238572"
---
# <a name="compiler-errors-c3500-through-c3999"></a>컴파일러 오류 C3500 ~ C3999

설명서의이 섹션에 있는 문서는 컴파일러에 의해 생성 되는 오류 메시지의 하위 집합을 설명 합니다.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>오류 메시지

|Error|메시지|
|-----------|-------------|
|[컴파일러 오류 C3500](compiler-error-c3500.md)|잘못 된 ProgID '*progid*'|
|[컴파일러 오류 C3501](compiler-error-c3501.md)|ProgID '*progid*'에 대해 등록 된 typelib가 없습니다.|
|컴파일러 오류 C3502|ProgID '*progid*'의 LIBID를 가져올 수 없습니다.|
|컴파일러 오류 C3503|' 0x *value*' 문자는 원시 문자열 리터럴에 사용할 수 없습니다.|
|컴파일러 오류 C3504|'*string*' 문자열에서 GUID를 만들 수 없습니다.|
|[컴파일러 오류 C3505](compiler-error-c3505.md)|'*library*' 형식 라이브러리를 로드할 수 없습니다.|
|[컴파일러 오류 C3506](compiler-error-c3506.md)|LIBID '*library*'에 대해 등록 된 typelib가 없습니다.|
|[컴파일러 오류 C3507](compiler-error-c3507.md)|ProgID는 '*progid*'를 포함 하 여 39 자를 초과할 수 없습니다. '. ' 이외의 문장 부호는 포함 하지 않습니다. 숫자로 시작할 수도 없습니다.|
|[컴파일러 오류 C3508](compiler-error-c3508.md)|'*type*': 올바른 자동화 형식이 아닙니다.|
|[컴파일러 오류 C3509](compiler-error-c3509.md)|'*type*': 자동화 반환 형식이 잘못 되었습니다. 매개 변수가 ' t r u e '로 표시 된 경우 반환 형식은 ' void ', ' HRESULT ' 또는 ' i n t ' 이어야 합니다.|
|[컴파일러 오류 C3510](compiler-error-c3510.md)|종속 형식 라이브러리 *라이브러리* 를 찾을 수 없습니다.|
|컴파일러 오류 C3511|'*identifier*': 위임 생성자 호출은 유일한 멤버 이니셜라이저가 되어야 합니다.|
|컴파일러 오류 C3512|원시 문자열 리터럴에 대 한 구분 문자 시퀀스는 16 자이 하 여야 합니다.|
|컴파일러 오류 C3513|'*string*': 지원 되지 않는 원시 문자열 리터럴 구분 기호 문자|
|컴파일러 오류 C3514|'*character*' (*값*): 지원 되지 않는 원시 문자열 리터럴 구분 기호 문자|
|컴파일러 오류 C3515|클래스 템플릿 부분 특수화에 대 한 인수가 pack 확장 인 경우 마지막 인수 여야 합니다.|
|컴파일러 오류 C3516|원시 문자열 리터럴을 처리 하는 동안 예기치 않은 파일의 끝이 발견 되었습니다. '*string*' 구분 기호 시퀀스가 일치 하지 않습니다.|
|컴파일러 오류 C3517|'*identifier*' 별칭 선언에는 ' a u t o '를 포함 하는 형식을 사용할 수 없습니다.|
|컴파일러 오류 C3518|'*identifier*': 직접 목록 초기화 컨텍스트에서는 '*type*'의 형식을 단일 이니셜라이저 식 에서만 추론할 수 있습니다.|
|[컴파일러 오류 C3519](compiler-error-c3519.md)|'*parameter*': embedded_idl 특성에 대 한 매개 변수가 잘못 되었습니다.|
|컴파일러 오류 C3520|'*identifier*':이 컨텍스트에서 매개 변수 팩을 확장 해야 합니다.|
|컴파일러 오류 C3521|'*identifier*'는 매개 변수 팩이 아닙니다.|
|컴파일러 오류 C3522|'*type*':이 컨텍스트에서 매개 변수 팩을 확장할 수 없습니다.|
|컴파일러 오류 C3523|' sizeof ... ' 확장 되지 않은 매개 변수 팩을 인수로 사용 해야 합니다.|
|컴파일러 오류 C3524|'*identifier*': ' sizeof '는 매개 변수 팩에 적용할 수 없습니다. ' Sizeof ... '를 사용 하 시겠습니까?|
|컴파일러 오류 C3525|'*parameter*': 클래스 템플릿에 템플릿 매개 변수 팩이 있으면 템플릿 매개 변수 목록 끝에 나타나야 합니다.|
|컴파일러 오류 C3526|'...' ' t r u e '에 적용할 수 없습니다.|
|컴파일러 오류 C3527|'*identifier*'는 ' sizeof ... '의 올바른 피연산자가 아닙니다. ' Sizeof '를 사용 하 시겠습니까?|
|컴파일러 오류 C3528|'*identifier1*':이 팩 확장의 요소 수가 '*identifier2*'의 요소 수와 일치 하지 않습니다.|
|컴파일러 오류 C3529|'*parameter*': 템플릿 매개 변수 팩에는 기본 인수를 사용할 수 없습니다.|
|[컴파일러 오류 C3530](compiler-error-c3530.md)|'*type*'은 다른 형식 지정자와 함께 사용할 수 없습니다.|
|[컴파일러 오류 C3531](compiler-error-c3531.md)|'*identifier*': 형식에 ' t *y* p e '이 포함 된 기호에는 이니셜라이저가 있어야 합니다.|
|[컴파일러 오류 C3532](compiler-error-c3532.md)|배열의 요소 *형식은 ' t r u* e '를 포함 하는 형식일 수 없습니다.|
|[컴파일러 오류 C3533](compiler-error-c3533.md)|매개 변수에 *는 ' t r u* e '를 포함 하는 형식을 사용할 수 없습니다.|
|컴파일러 오류 C3534|사용되지 않습니다.|
|[컴파일러 오류 C3535](compiler-error-c3535.md)|' u *s e r*'에서 '*type2*'의 형식을 추론할 수 없습니다.|
|[컴파일러 오류 C3536](compiler-error-c3536.md)|'*identifier*': 초기화 되기 전에 사용할 수 없습니다.|
|[컴파일러 오류 C3537](compiler-error-c3537.md)|*' t r u* e '를 포함 하는 형식으로 캐스팅할 수 없습니다.|
|[컴파일러 오류 C3538](compiler-error-c3538.md)|선언 자 목록에서 '*type*'은 항상 동일한 형식으로 추론 되어야 합니다.|
|[컴파일러 오류 C3539](compiler-error-c3539.md)|템플릿 인수 *는 ' t r u* e '를 포함 하는 형식일 수 없습니다.|
|[컴파일러 오류 C3540](compiler-error-c3540.md)|*' t r u* e '가 포함 된 형식에는 sizeof를 적용할 수 없습니다.|
|[컴파일러 오류 C3541](compiler-error-c3541.md)|*' t y p* e '가 포함 된 형식에는 typeid를 적용할 수 없습니다.|
|컴파일러 오류 C3542|'*identifier*': 가상 멤버 함수에는 '*t r u e '를* 포함 하는 반환 형식이 없어야 합니다.|
|컴파일러 오류 C3543|'*type*': 매개 변수 팩을 포함 하지 않습니다.|
|컴파일러 오류 C3544|'*parameter*': 매개 변수 팩에 형식 템플릿 인수가 필요 합니다.|
|컴파일러 오류 C3545|'*parameter*': 매개 변수 팩에 비형식 템플릿 인수가 필요 합니다.|
|컴파일러 오류 C3546|' ... ': 확장할 수 있는 매개 변수 팩이 없습니다.|
|컴파일러 오류 C3547|'*parameter*' 템플릿 매개 변수는 템플릿 매개 변수 팩을 따르며 '*function*'의 함수 매개 변수에서 추론할 수 없으므로 사용할 수 없습니다.|
|컴파일러 오류 C3548|'*identifier*':이 컨텍스트에서 매개 변수 팩을 사용할 수 없습니다.|
|컴파일러 오류 C3549|'*value*': 함수 매개 변수 팩에는 기본 인수를 사용할 수 없습니다.|
|[컴파일러 오류 C3550](compiler-error-c3550.md)|이 컨텍스트에 일반 'decltype(auto)'만 사용할 수 있습니다.|
|[컴파일러 오류 C3551](compiler-error-c3551.md)|후행 반환 형식이 사용 되는 경우 선행 반환 형식은 단일 형식 지정자 ' auto ' ('*type*' 아님) 여야 합니다.|
|[컴파일러 오류 C3552](compiler-error-c3552.md)|' decltype (auto) '가 필요 합니다.|
|[컴파일러 오류 C3553](compiler-error-c3553.md)|decltype에 형식이 아니라 식이 필요합니다.|
|[컴파일러 오류 C3554](compiler-error-c3554.md)|'*type*'은 다른 형식 지정자와 함께 사용할 수 없습니다.|
|[컴파일러 오류 C3555](compiler-error-c3555.md)|'decltype'의 인수가 잘못되었습니다.|
|[컴파일러 오류 C3556](compiler-error-c3556.md)|'*expression*': ' decltype '의 인수가 잘못 되었습니다.|
|컴파일러 오류 C3557|사용되지 않습니다.|
|컴파일러 오류 C3558|사용되지 않습니다.|
|컴파일러 오류 C3559|'*function*'에 대 한 재귀 호출: '*function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 재귀가 발견 되었습니다.|
|컴파일러 오류 C3560|'*function*': '*function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 IL을 사용할 수 없습니다.|
|컴파일러 오류 C3561|'*function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 타일 균일 하지 않은 제어 흐름에서 타일 장벽 작업을 찾았습니다.|
|컴파일러 오류 C3562|내장 함수 '*function*'은 *number* 개 이상의 매개 변수를 포함 하지 않도록 제한 됩니다.|
|컴파일러 오류 C3563|'*Function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 무한 루프가 발견 되었습니다.|
|컴파일러 오류 C3564|'*function*'에서 동시성에 대 한 호출 그래프를 컴파일하는 동안 초기화 되지 않은 값을 읽고 있습니다.:p arallel_for_each|
|컴파일러 오류 C3565|Tile_static 메모리의 총 *크기 (바이트* )가 concurrency의 호출 그래프를 컴파일할 때의 총 바이트 *수* 를 초과 합니다.:p arallel_for_each|
|컴파일러 오류 C3566|'*function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 파생 작업이 있는 블록이 너무 많이 중첩 되었습니다.|
|컴파일러 오류 C3567|'*function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 0으로 나누기 또는 mod가 검색 되었습니다.|
|컴파일러 오류 C3568|레지스터의 합계가 concurrency::p arallel_for_each에 대 한 호출 그래프를 컴파일하는 동안 *개수* 한도를 초과 합니다. 프로그램을 간소화 하세요.|
|컴파일러 오류 C3569|'*function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 경합 상태가 발견 되었습니다.|
|컴파일러 오류 C3570|/clr을 사용 하 여 컴파일할 때 amp 제한 범위를 잘못 사용 합니다.|
|컴파일러 오류 C3571|'*type*': 계산 도메인 인수가 잘못 되었습니다. 클래스 형식이 아닙니다.|
|컴파일러 오류 C3572|'*type*': 계산 도메인 인수가 잘못 되었습니다. public 멤버가 없습니다. ' static const int rank ' 또는 rank 값은 양수가 아닙니다.|
|컴파일러 오류 C3573|Concurrency:: graphics:: 샘플러에 전달 된 concurrency:: graphics:: 샘플러의 인스턴스 수는:p arallel_for_each는 *숫자* 를 초과할 수 없습니다.|
|컴파일러 오류 C3574|'*type*': 타일 범위가 잘못 되었습니다. 양수 여야 하며 (1) Z <= *number*; 여야 합니다. (2) Z *Y* X <= *number*|
|컴파일러 오류 C3575|'*type*': 계산 도메인 인수가 잘못 되었습니다. public 멤버가 없습니다. ' concurrency:: index<*number*> _map_index (const concurrency:: index<*number*>&) restrict (amp) '|
|컴파일러 오류 C3576|'*type*': concurrency::d etails:: _Parallel_for_each 인수 #*number* 에 지원 되지 않는 형식이 있습니다.|
|컴파일러 오류 C3577|concurrency::p arallel_for_each 커널 인수가 잘못 되었습니다. ' void operator () (*type*) restrict (amp) ' 멤버에 대 한 호출을 확인할 수 없습니다.|
|컴파일러 오류 C3578|Concurrency에 전달 되는 함수 개체의 크기::p arallel_for_each는 *숫자* 바이트를 초과할 수 없습니다.|
|컴파일러 오류 C3579|Concurrency:: array 및 concurrency:: graphics:: 텍스처가 concurrency로 전달 되는 읽기 전용 인스턴스 수::p arallel_for_each는 *숫자* 를 초과할 수 없습니다.|
|컴파일러 오류 C3580|Concurrency:: array 및 concurrency:: graphics:: 텍스처가 concurrency에 전달 되는 쓰기 가능 인스턴스 수::p arallel_for_each는 *숫자* 를 초과할 수 없습니다.|
|컴파일러 오류 C3581|'*type*': amp 제한 코드에 지원 되지 않는 형식이 있습니다.|
|컴파일러 오류 C3582|사용되지 않습니다.|
|컴파일러 오류 C3583|'*identifier*': 변수 크기 (*number* 바이트)가 amp 제한 코드에서 지원 되는 최대 크기 *(바이트* ) 보다 큽니다.|
|컴파일러 오류 C3584|'*identifier*'에서 지원 되지 않는 tile_static 사용|
|컴파일러 오류 C3585|amp 제한 코드에 '*identifier*'의 저장소 클래스가 지원 되지 않습니다.|
|컴파일러 오류 C3586|'*identifier*': amp 제한 코드에서는 전역 또는 정적 변수를 사용할 수 없습니다.|
|컴파일러 오류 C3587|amp 제한 코드에서는 dynamic_cast 지원 되지 않습니다.|
|컴파일러 오류 C3588|amp 제한 코드에서는 '*type1*'에서 '*type2*' (으)로 캐스팅할 수 없습니다.|
|컴파일러 오류 C3589|'*string*': amp 제한 코드에서 지원 되지 않는 문자열 리터럴 사용법입니다.|
|컴파일러 오류 C3590|'*token*': 람다가 amp 제한 되는 경우 참조 방식 캡처 또는 ' this ' 캡처가 지원 되지 않습니다.|
|컴파일러 오류 C3591|amp 제한 코드에서는 typeid 연산자가 지원 되지 않습니다.|
|컴파일러 오류 C3592|Amp 제한 코드에서는 인라인 네이티브 어셈블리 (' __asm ')가 지원 되지 않습니다.|
|컴파일러 오류 C3593|amp 제한 코드에서는 ' goto '가 지원 되지 않습니다.|
|컴파일러 오류 C3594|amp 제한 코드에서는 예외 처리 (try, catch, throw 등)가 지원 되지 않습니다.|
|컴파일러 오류 C3595|amp 제한 코드에서 상수 값이 지원 되는 범위를 벗어났습니다.|
|컴파일러 오류 C3596|'*parameter*' ('*type*'): amp 제한 코드에서 람다로 캡처된 변수에 지원 되지 않는 형식이 있습니다.|
|컴파일러 오류 C3597|'*parameter*': 람다가 amp 제한 되는 경우 '*identifier*'를 값으로 캡처할 수 없습니다.|
|컴파일러 오류 C3598|amp 제한 코드에서는 레이블 문이 지원 되지 않습니다.|
|컴파일러 오류 C3599|'*operator*': amp 제한 코드에서는 bool에 대 한 포인터에서 포인터 산술 연산을 수행할 수 없습니다.|
|컴파일러 오류 C3600|'*function*': \_ 비 바둑판식 동시성에 대 한 호출 그래프를 컴파일할 때 타일 정적 메모리를 사용 했습니다.:p arallel \_ for_each at: '*function*'|
|컴파일러 오류 C3601|'*type*': amp 진단 함수 '*function*'의 인수 형식이 잘못 되었습니다.|
|컴파일러 오류 C3602|'*Function*'에서 동시성::p arallel_for_each에 대해 호출 그래프를 컴파일하는 동안 지원 되지 않는 제어 흐름이 검색 되었습니다.|
|[컴파일러 오류 C3603](compiler-error-c3603.md)|'*symbol*': '*type*' 형식은 아직 지원 되지 않습니다.|
|컴파일러 오류 C3604|'*identifier*': gc 힙에는 관리 되는 개체만 만들 수 있습니다.|
|컴파일러 오류 C3605|Concurrency의 호출 그래프를 컴파일할 때 총 샘플러 수 (캡처 *번호* *및 미리 정의 된 숫자)* 가 *number* 를 초과 합니다.:p arallel_for_each: '*function*'|
|컴파일러 오류 C3606|사용되지 않습니다.|
|컴파일러 오류 C3607|사용되지 않습니다.|
|컴파일러 오류 C3608|사용되지 않습니다.|
|[컴파일러 오류 C3609](compiler-error-c3609.md)|'*identifier*': ' sealed/final ' 함수는 virtual 이어야 합니다.|
|[컴파일러 오류 C3610](compiler-error-c3610.md)|'*identifier*': 값 형식은 '*method*' 메서드를 호출 하기 전에 ' boxed ' 여야 합니다.|
|[컴파일러 오류 C3611](compiler-error-c3611.md)|'*identifier*': 봉인 된 함수에는 순수 지정자를 사용할 수 없습니다.|
|[컴파일러 오류 C3612](compiler-error-c3612.md)|'*identifier*': sealed 클래스에는 순수 가상 메서드를 사용할 수 없습니다.|
|컴파일러 오류 C3613|'-> ' 후 반환 형식이 없습니다 (' i n t '로 가정).|
|컴파일러 오류 C3614|동일한 클래스 내에서 팩 크기에 대 한 값이 서로 다릅니다. previous는 '*value*'이 고, 새 값은 '*value*'입니다.|
|[컴파일러 오류 C3615](compiler-error-c3615.md)|constexpr 함수 '*function*'은 상수 식이 될 수 없습니다.|
|컴파일러 오류 C3616|사용되지 않습니다.|
|컴파일러 오류 C3617|사용되지 않습니다.|
|[컴파일러 오류 C3618](compiler-error-c3618.md)|'*선언*': DllImport로 표시 된 메서드를 정의할 수 없습니다.|
|[컴파일러 오류 C3619](compiler-error-c3619.md)|관리 되는/WinRT 형식 내에서 템플릿을 선언할 수 없습니다.|
|컴파일러 오류 C3620|'*type*': WinRT 형식에는 맞춤을 설정할 수 없습니다.|
|컴파일러 오류 C3621|'*type*': WinRT 형식에는 기본 압축 값 (*number*)만 사용할 수 있습니다.|
|[컴파일러 오류 C3622](compiler-error-c3622.md)|*type*': '*keyword*'로 선언 된 클래스를 인스턴스화할 수 없습니다.|
|[컴파일러 오류 C3623](compiler-error-c3623.md)|'*identifier*': 비트 필드는 관리 되는/WinRT 형식에서 지원 되지 않습니다.|
|[컴파일러 오류 C3624](compiler-error-c3624.md)|'*type*':이 형식을 사용 하려면 어셈블리/모듈 '*identifier*'에 대 한 참조가 필요 합니다.|
|[컴파일러 오류 C3625](compiler-error-c3625.md)|'*class*': 네이티브 형식은 관리 되는/WinRT 형식 '*type*'에서 파생 될 수 없습니다.|
|[컴파일러 오류 C3626](compiler-error-c3626.md)|'*identifier*': '*keyword*' 키워드는 대리자에 대 한 포인터인 COM 인터페이스, 멤버 함수 및 데이터 멤버에만 사용할 수 있습니다.|
|[컴파일러 오류 C3627](compiler-error-c3627.md)|값 형식만 boxed 형식이 될 수 있습니다.|
|[컴파일러 오류 C3628](compiler-error-c3628.md)|'*class*': 관리 되는/WinRT 클래스는 공용 상속만 지원 합니다.|
|컴파일러 오류 C3629|'*token*': 캡처 기본값은 람다 캡처 목록의 시작 부분에만 사용할 수 있습니다.|
|[컴파일러 오류 C3630](compiler-error-c3630.md)|'*token*' 토큰을 처리 하는 동안 오류가 발생 했습니다.|
|[컴파일러 오류 C3631](compiler-error-c3631.md)|'*event*': 관리 되는/WinRT 이벤트를 오버 로드할 수 없습니다.|
|[컴파일러 오류 C3632](compiler-error-c3632.md)|'*event*': *생성* 에 대 한 이벤트 스타일이 잘못 되었습니다.|
|[컴파일러 오류 C3633](compiler-error-c3633.md)|'*identifier*'를 관리 되는 '*class*'의 멤버로 정의할 수 없습니다.|
|[컴파일러 오류 C3634](compiler-error-c3634.md)|'*member*': 관리 되는/WinRT 클래스의 추상 메서드를 정의할 수 없습니다.|
|컴파일러 오류 C3635|'*identifier*': 관리 되는/WinRT 클래스에 적용할 수 없습니다. 대신 '*identifier*'를 사용 하십시오.|
|컴파일러 오류 C3636|'*identifier*':이 형식에 적용할 수 없습니다.|
|[컴파일러 오류 C3637](compiler-error-c3637.md)|'*function*': friend 함수 정의는 함수 템플릿/제네릭의 특수화 일 수 없습니다.|
|[컴파일러 오류 C3638](compiler-error-c3638.md)|'*operator*': 표준 boxing 및 unboxing 변환 연산자는 다시 정의할 수 없습니다.|
|컴파일러 오류 C3639|사용되지 않습니다.|
|[컴파일러 오류 C3640](compiler-error-c3640.md)|'*member*': 지역 클래스의 참조 또는 가상 멤버 함수를 정의 해야 합니다.|
|[컴파일러 오류 C3641](compiler-error-c3641.md)|'*function*':/clr: pure 또는/clr: safe를 사용 하 여 컴파일된 함수에 대해 '*규칙*' 호출 규칙이 잘못 되었습니다.|
|[컴파일러 오류 C3642](compiler-error-c3642.md)|'*function*': 네이티브 코드에서 __clrcall 호출 규칙을 사용 하 여 함수를 호출할 수 없습니다.|
|컴파일러 오류 C3643|사용되지 않습니다.|
|[컴파일러 오류 C3644](compiler-error-c3644.md)|'*function*': 함수를 컴파일하여 관리 코드를 생성할 수 없습니다.|
|[컴파일러 오류 C3645](compiler-error-c3645.md)|'*function*': 네이티브 코드로 컴파일된 함수에는 __clrcall를 사용할 수 없습니다.|
|[컴파일러 오류 C3646](compiler-error-c3646.md)|'*identifier*': 알 수 없는 재정의 지정자입니다.|
|컴파일러 오류 C3647|사용되지 않습니다.|
|[컴파일러 오류 C3648](compiler-error-c3648.md)|이 명시적 재정의 구문은 관리 되는 형식에 대해 지원 되지 않습니다.|
|컴파일러 오류 C3649|이 명시적 재정의 구문은/ZW에 사용할 수 없습니다.|
|[컴파일러 오류 C3650](compiler-error-c3650.md)|'*member*': 명시적 재정의로 사용할 수 없습니다. 기본 클래스의 가상 멤버 함수 여야 합니다.|
|[컴파일러 오류 C3651](compiler-error-c3651.md)|'*member*': 명시적 재정의로 사용할 수 없습니다. 기본 클래스의 멤버 여야 합니다.|
|[컴파일러 오류 C3652](compiler-error-c3652.md)|'*member*': 명시적으로 재정의 하는 함수는 virtual 이어야 합니다.|
|[컴파일러 오류 C3653](compiler-error-c3653.md)|'*identifier*': 명명 된 재정의로 사용할 수 없습니다. 재정의 되는 함수를 찾을 수 없습니다. :: 연산자를 사용 하 여 함수 이름을 명시적으로 지정할 수 있나요?|
|[컴파일러 오류 C3654](compiler-error-c3654.md)|'*token*': 명시적 재정의에 구문 오류가 있습니다.|
|[컴파일러 오류 C3655](compiler-error-c3655.md)|'*member*': 함수가 이미 명시적으로 재정의 되었습니다.|
|[컴파일러 오류 C3656](compiler-error-c3656.md)|'*keyword*': 재정의 지정자를 반복할 수 없습니다.|
|[컴파일러 오류 C3657](compiler-error-c3657.md)|소멸자/종료자는 명시적으로 재정의 하거나 명시적으로 재정의할 수 없습니다.|
|컴파일러 오류 C3658|사용되지 않습니다.|
|컴파일러 오류 C3659|'*member*': 재정의 지정자 '*keyword*'는 지원 되지 않습니다.|
|컴파일러 오류 C3660|'*member1*': 상속 된 '*member2*' 멤버를 숨깁니다.|
|[컴파일러 오류 C3661](compiler-error-c3661.md)|명시적 재정의 목록에서 재정의할 메서드를 찾지 못했습니다.|
|[컴파일러 오류 C3662](compiler-error-c3662.md)|'*member*': 재정의 지정자 '*keyword*'는 관리 되는/WinRT 클래스의 멤버 함수에만 사용할 수 있습니다.|
|컴파일러 오류 C3663|사용되지 않습니다.|
|컴파일러 오류 C3664|'*member*': 명시적 재정의로 사용할 수 없습니다. ' public ' 또는 ' protected ' 액세스 가능성이 있어야 합니다.|
|[컴파일러 오류 C3665](compiler-error-c3665.md)|'*member*': 재정의 지정자 '*keyword*'는 소멸자/종료자에서 사용할 수 없습니다.|
|[컴파일러 오류 C3666](compiler-error-c3666.md)|'*constructor*': 재정의 지정자 '*keyword*'는 생성자에서 사용할 수 없습니다.|
|컴파일러 오류 C3667|'*attribute*': 특성이 팩 확장을 지원 하지 않습니다.|
|[컴파일러 오류 C3668](compiler-error-c3668.md)|'*member*': 재정의 지정자 ' override '가 있는 메서드가 기본 클래스 메서드를 재정의 하지 않았습니다.|
|[컴파일러 오류 C3669](compiler-error-c3669.md)|'*member*': 재정의 지정자 ' override '는 정적 멤버 함수 또는 생성자에서 사용할 수 없습니다.|
|[컴파일러 오류 C3670](compiler-error-c3670.md)|'*member*': 액세스할 수 없는 기본 클래스 메서드 '*member*'를 재정의할 수 없습니다.|
|[컴파일러 오류 C3671](compiler-error-c3671.md)|'*member*': 함수가 '*member*'를 재정의 하지 않습니다.|
|[컴파일러 오류 C3672](compiler-error-c3672.md)|의사 (pseudo) 소멸자 식은 함수 호출의 일부로만 사용할 수 있습니다.|
|[컴파일러 오류 C3673](compiler-error-c3673.md)|'*class*': 클래스에 복사 생성자가 없습니다.|
|컴파일러 오류 C3674|'*module*' 표준 라이브러리 모듈을 찾을 수 없습니다.|
|[컴파일러 오류 C3675](compiler-error-c3675.md)|'*function*': '*property*'가 정의 되어 있으므로 예약 되어 있습니다.|
|컴파일러 오류 C3676|'*class*': ref 클래스 및 기본 클래스의 특성 ' [*attribute*] '이 (가) 호환 되지 않습니다.|
|컴파일러 오류 C3677|' operator ' 뒤의 문자열 리터럴은 인코딩 접두사를 가질 수 없습니다.|
|컴파일러 오류 C3678|' operator ' 뒤의 문자열 리터럴은 빈 문자열 ' "" "" ' 이어야 합니다.|
|컴파일러 오류 C3679|' operator "" "" ' 다음에 리터럴 접미사 식별자가 필요 합니다.|
|컴파일러 오류 C3680|일치 하지 않는 리터럴 접미사 식별자로 사용자 정의 문자열 리터럴을 연결할 수 없습니다.|
|컴파일러 오류 C3681|' fallthrough ': 특성은 바깥쪽 switch 문에만 나타날 수 있습니다.|
|컴파일러 오류 C3682|' operator *identifier*': 리터럴 연산자/리터럴 연산자 템플릿은 ' C 링크 '를 포함 하도록 선언할 수 없습니다.|
|컴파일러 오류 C3683|같은 리터럴 접미사 식별자로 원시 리터럴 연산자와 리터럴 연산자 템플릿을 모두 정의할 수 없습니다.|
|컴파일러 오류 C3684|' operator *identifier*': 리터럴 연산자 선언에 잘못 된 매개 변수 목록이 있습니다.|
|컴파일러 오류 C3685|' operator *identifier*': 리터럴 연산자 템플릿에 함수 매개 변수를 사용할 수 없습니다.|
|컴파일러 오류 C3686|' operator *identifier*': 리터럴 연산자 템플릿에 매개 변수 팩 인 템플릿 매개 변수를 정확히 하나만 포함 해야 합니다.|
|컴파일러 오류 C3687|' operator *identifier*': 리터럴 연산자 템플릿에 ' char ' 형식의 템플릿이 아닌 템플릿 매개 변수를 포함 해야 합니다.|
|컴파일러 오류 C3688|'*suffix*' 리터럴 접미사가 잘못 되었습니다. 리터럴 연산자 또는 리터럴 연산자 템플릿 ' operator *identifier*'를 찾을 수 없습니다.|
|컴파일러 오류 C3689|' operator *identifier*': 리터럴 연산자/리터럴 연산자 템플릿은 전역 또는 네임 스페이스 범위에 있어야 합니다.|
|컴파일러 오류 C3690|문자열 리터럴이 필요 하지만 대신 사용자 정의 문자열 리터럴을 찾았습니다.|
|컴파일러 오류 C3691|'*prefix*' 리터럴 접두사가 잘못 되었습니다.|
|컴파일러 오류 C3692|사용되지 않습니다.|
|컴파일러 오류 C3693|사용되지 않습니다.|
|컴파일러 오류 C3694|사용되지 않습니다.|
|컴파일러 오류 C3695|사용되지 않습니다.|
|컴파일러 오류 C3696|'*keyword*': '% '에서이 한정자를 사용할 수 없습니다.|
|[컴파일러 오류 C3697](compiler-error-c3697.md)|'*keyword*': ' ^ '에이 한정자를 사용할 수 없습니다.|
|[컴파일러 오류 C3698](compiler-error-c3698.md)|'*type*':이 형식을 '*operator*'의 인수로 사용할 수 없습니다.|
|[컴파일러 오류 C3699](compiler-error-c3699.md)|'*operator*': '*type*' 형식에 대해이 간접 참조를 사용할 수 없습니다.|
|컴파일러 오류 C3700|사용되지 않습니다.|
|[컴파일러 오류 C3701](compiler-error-c3701.md)|'*function*': 이벤트 소스에 이벤트가 없습니다.|
|[컴파일러 오류 C3702](compiler-error-c3702.md)|COM 이벤트에는 ATL이 필요 합니다.|
|[컴파일러 오류 C3703](compiler-error-c3703.md)|'*event_handler*': 이벤트 처리기 메서드의 저장소 클래스는 '*event*' 소스와 동일 해야 합니다.|
|[컴파일러 오류 C3704](compiler-error-c3704.md)|'*member*': vararg 메서드는 이벤트를 발생 시킬 수 없습니다.|
|[컴파일러 오류 C3705](compiler-error-c3705.md)|'*function*': 이벤트 인터페이스를 찾을 수 없습니다.|
|[컴파일러 오류 C3706](compiler-error-c3706.md)|'*function*': com 이벤트를 발생 시키려면 com 인터페이스 여야 합니다.|
|[컴파일러 오류 C3707](compiler-error-c3707.md)|'*member*':가는 메서드는 dispid가 있어야 합니다.|
|[컴파일러 오류 C3708](compiler-error-c3708.md)|'*function*': '*keyword*'를 잘못 사용 했습니다. 호환 되는 이벤트 소스의 멤버 여야 합니다.|
|[컴파일러 오류 C3709](compiler-error-c3709.md)|'*function*': __hook/__unhook에서 이벤트를 지정 하기 위한 구문이 잘못 되었습니다.|
|[컴파일러 오류 C3710](compiler-error-c3710.md)|'*function*': __hook/__unhook에서 이벤트 처리기를 지정 하기 위한 구문이 잘못 되었습니다.|
|[컴파일러 오류 C3711](compiler-error-c3711.md)|'*event*': 관리 되지 않는 이벤트 소스 메서드는 void 또는 정수 계열 형식을 반환 해야 합니다.|
|[컴파일러 오류 C3712](compiler-error-c3712.md)|'*event_handler*': 이벤트 처리기 메서드는 '*event*' 소스와 같은 형식을 반환 해야 합니다.|
|[컴파일러 오류 C3713](compiler-error-c3713.md)|'*event_handler*': 이벤트 처리기 메서드는 '*event*' 소스와 같은 함수 매개 변수를 포함 해야 합니다.|
|[컴파일러 오류 C3714](compiler-error-c3714.md)|'*event_handler*': 이벤트 처리기 메서드는 '*event*' 소스와 같은 호출 규칙을 포함 해야 합니다.|
|[컴파일러 오류 C3715](compiler-error-c3715.md)|'*pointer*': '*type*'에 대 한 포인터 여야 합니다.|
|컴파일러 오류 C3716|사용되지 않습니다.|
|[컴파일러 오류 C3717](compiler-error-c3717.md)|'*member*': 이벤트를 발생 시키는 메서드를 정의할 수 없습니다.|
|[컴파일러 오류 C3718](compiler-error-c3718.md)|수신 하는 클래스의 멤버 함수 컨텍스트에서만 ' __ *keyword*'를 호출할 수 있습니다.|
|[컴파일러 오류 C3719](compiler-error-c3719.md)|'*member*': 인터페이스 기반 이벤트 소스는 COM 이벤트에만 사용할 수 있습니다.|
|컴파일러 오류 C3720|'*type*': dual 또는을 (를) 통해서만 IDispatch를 구현할 수 있습니다.|
|[컴파일러 오류 C3721](compiler-error-c3721.md)|'*signature*': 이벤트의 서명이 호환 되지 않습니다.|
|[컴파일러 오류 C3722](compiler-error-c3722.md)|제네릭 이벤트를 사용할 수 없습니다.|
|[컴파일러 오류 C3723](compiler-error-c3723.md)|'*function*': 이벤트를 확인할 수 없습니다.|
|[컴파일러 오류 C3724](compiler-error-c3724.md)|이벤트에 \<windows.h> 다중 스레딩을 사용 하려면 #include 해야 함|
|컴파일러 오류 C3725|사용되지 않습니다.|
|컴파일러 오류 C3726|사용되지 않습니다.|
|[컴파일러 오류 C3727](compiler-error-c3727.md)|'*event*': 관리 되는 이벤트는 대리자에 대 한 포인터인 멤버 함수 또는 데이터 멤버 여야 합니다.|
|[컴파일러 오류 C3728](compiler-error-c3728.md)|'*event*': 이벤트에 raise 메서드가 없습니다.|
|컴파일러 오류 C3729|사용되지 않습니다.|
|컴파일러 오류 C3730|사용되지 않습니다.|
|[컴파일러 오류 C3731](compiler-error-c3731.md)|'*event*' 이벤트와 '*event_handler*' 처리기가 호환 되지 않습니다. 이벤트 원본 및 이벤트 처리기는 동일한 이벤트 유형 이어야 합니다.|
|[컴파일러 오류 C3732](compiler-error-c3732.md)|'*interface*': COM 이벤트를 발생 시키는 사용자 지정 인터페이스는 IDispatch에서 상속할 수 없습니다.|
|[컴파일러 오류 C3733](compiler-error-c3733.md)|'*event*': COM 이벤트를 지정 하기 위한 구문이 잘못 되었습니다. ' __interface '를 잊은 경우|
|[컴파일러 오류 C3734](compiler-error-c3734.md)|'*class*': 관리 되는/WinRT 클래스는 coclass 일 수 없습니다.|
|컴파일러 오류 C3735|사용되지 않습니다.|
|[컴파일러 오류 C3736](compiler-error-c3736.md)|'*member*': 메서드 이거나, 관리 되는 이벤트의 경우 선택적으로 데이터 멤버 여야 합니다.|
|[컴파일러 오류 C3737](compiler-error-c3737.md)|'*identifier*': 대리자는 명시적 호출 규칙을 사용할 수 없습니다.|
|[컴파일러 오류 C3738](compiler-error-c3738.md)|'*규칙*': 명시적 인스턴스화의 호출 규칙은 인스턴스화되는 템플릿의 호출 규칙과 일치 해야 합니다.|
|[컴파일러 오류 C3739](compiler-error-c3739.md)|'*class*': 구문은 \_ event_receiver의 ' layout dependent ' 매개 변수가 true 인 경우에만 지원 됩니다.|
|[컴파일러 오류 C3740](compiler-error-c3740.md)|'*template*': 템플릿에서 이벤트를 보내거나 받을 수 없습니다.|
|[컴파일러 오류 C3741](compiler-error-c3741.md)|'*class*': \_ event_receiver의 ' layout dependent ' 매개 변수가 true 인 경우 coclass 여야 합니다.|
|컴파일러 오류 C3742|'*token1*': '*attribute*'의 특성 인수에서 토큰 시퀀스가 불균형 하므로 '*token2*'가 필요 합니다.|
|[컴파일러 오류 C3743](compiler-error-c3743.md)|event_receiver의 ' layout_dependent ' 매개 변수가 true 인 경우에만 전체 인터페이스를 후크/언 후크 할 수 있습니다.|
|[컴파일러 오류 C3744](compiler-error-c3744.md)|__unhook는 관리 되는 이벤트에 대해 세 개 이상의 인수가 있어야 합니다.|
|[컴파일러 오류 C3745](compiler-error-c3745.md)|'*function*': 이벤트만 ' e n t ' 일 수 있습니다.|
|컴파일러 오류 C3746|표준 특성 '*identifier*'는 특성 목록에서 한 번만 나타날 수 있습니다.|
|[컴파일러 오류 C3747](compiler-error-c3747.md)|기본 템플릿/제네릭 매개 변수가 없습니다. 매개 변수 *번호*|
|[컴파일러 오류 C3748](compiler-error-c3748.md)|'*interface*': 관리 되지 않는 인터페이스는 이벤트를 발생 시킬 수 없습니다.|
|[컴파일러 오류 C3749](compiler-error-c3749.md)|'*attribute*': 사용자 지정 특성은 함수 내에서 사용할 수 없습니다.|
|컴파일러 오류 C3750|'*token*': 특성 목록에 예기치 않은 토큰이 있습니다.|
|컴파일러 오류 C3751|'*identifier*': 특성 목록에 예기치 않은 식별자가 있습니다.|
|[컴파일러 오류 C3752](compiler-error-c3752.md)|'*attribute*': 특성을 분류할 수 없습니다. '*keyword*'는이 컨텍스트에서 사용할 수 없습니다.|
|[컴파일러 오류 C3753](compiler-error-c3753.md)|제네릭 속성은 사용할 수 없습니다.|
|[컴파일러 오류 C3754](compiler-error-c3754.md)|대리 생성자: '*member*' 멤버 함수는 '*type*' 형식의 인스턴스에 대해 호출할 수 없습니다.|
|[컴파일러 오류 C3755](compiler-error-c3755.md)|'*identifier*': 대리자를 정의할 수 없습니다.|
|컴파일러 오류 C3756|사용되지 않습니다.|
|컴파일러 오류 C3757|'*type*': ' constexpr ' 함수에 형식이 허용 되지 않습니다.|
|컴파일러 오류 C3758|'*member*': 가상 함수를 ' constexpr '로 선언할 수 없습니다.|
|컴파일러 오류 C3759|'*member*': 리터럴 형식이 아닌 멤버 함수는 ' constexpr '로 선언할 수 없습니다.|
|컴파일러 오류 C3760|__property 키워드를 사용 하 여 관리 되는/WinRT '*클래스*'에서 속성을 선언 하세요.|
|[컴파일러 오류 C3761](compiler-error-c3761.md)|'*function*': ' retval '은 함수의 마지막 인수에만 사용할 수 있습니다.|
|[컴파일러 오류 C3762](compiler-error-c3762.md)|'*attribute*' 특성을 처리할 수 없습니다.|
|[컴파일러 오류 C3763](compiler-error-c3763.md)|'*type*': ' retval ' 및 ' o u t '는 데이터 포인터 형식에만 사용할 수 있습니다.|
|[컴파일러 오류 C3764](compiler-error-c3764.md)|'*member*': '*member*' 기본 클래스 메서드를 재정의할 수 없습니다.|
|[컴파일러 오류 C3765](compiler-error-c3765.md)|'*event*': event_receiver로 표시 된 '*type*' 클래스/구조체에서 이벤트를 정의할 수 없습니다.|
|[컴파일러 오류 C3766](compiler-error-c3766.md)|'*t r u e '는*'*function*' 인터페이스 메서드의 구현을 제공 해야 합니다.|
|[컴파일러 오류 C3767](compiler-error-c3767.md)|'*function*': 후보 함수에 액세스할 수 없습니다.|
|[컴파일러 오류 C3768](compiler-error-c3768.md)|순수 관리 코드에서는 가상 vararg 함수의 주소를 가져올 수 없습니다.|
|[컴파일러 오류 C3769](compiler-error-c3769.md)|'*identifier*': 중첩 된 클래스는 바로 바깥쪽 클래스와 같은 이름을 사용할 수 없습니다.|
|컴파일러 오류 C3770|'*type*': 올바른 기본 클래스가 아닙니다.|
|[컴파일러 오류 C3771](compiler-error-c3771.md)|'*identifier*': 가장 가까운 네임 스페이스 범위에서 friend 선언을 찾을 수 없습니다.|
|[컴파일러 오류 C3772](compiler-error-c3772.md)|'*identifier*': friend 템플릿 선언이 잘못 되었습니다.|
|컴파일러 오류 C3773|/await 컴파일러 스위치를 사용 하 여 코 루틴를 사용 하도록 설정 하세요.|
|컴파일러 오류 C3774|'*scope*::*identifier*'를 찾을 수 없습니다. *헤더* 헤더를 포함 하십시오.|
|컴파일러 오류 C3775|'*function*'의 반환 형식은 *' t r u e '* 일 수 없습니다.|
|컴파일러 오류 C3776|void가 아닌 최종 반환 형식이 있는 코 루틴에서 void 형식의 식를 반환할 수 없습니다.|
|컴파일러 오류 C3777|'*function*': 코 루틴는 가변 인수 목록을 사용할 수 없습니다.|
|컴파일러 오류 C3778|alloca: 코 루틴에서 사용할 수 없습니다.|
|컴파일러 오류 C3779|'*function*'*: ' t r u e '* 를 반환 하는 함수는 정의 되기 전에 사용할 수 없습니다.|
|컴파일러 오류 C3780|'*function*'*: ' t r u e '* 를 반환 하는 변환 함수는 정의 되기 전에 사용할 수 없습니다.|
|컴파일러 오류 C3781|'*keyword*': '*type*' 형식의 코 루틴에서 사용할 수 없습니다. *키워드* 또는 *키워드가* 연결 된 promise_type에 있어야 합니다.|
|컴파일러 오류 C3782|*유형*: 코 루틴의 약속은 *키워드* 와 *키워드* 를 모두 포함할 수 없습니다.|
|컴파일러 오류 C3783|'*identifier*': 코 루틴 일 수 없습니다.|
|컴파일러 오류 C3784|이 컨텍스트에는 *키워드* 식이 올 수 없습니다.|
|컴파일러 오류 C3785|' std:: integer_sequence '에 대 한 첫 번째 템플릿 인수는 정수 형식 이어야 합니다.|
|컴파일러 오류 C3786|' std:: make_integer_sequence '에 대 한 두 번째 템플릿 인수는 0 보다 크거나 같은 정수 상수 여야 합니다.|
|컴파일러 오류 C3787|이 코 루틴의 반환 형식을 추론할 수 없습니다.|
|컴파일러 오류 C3788|사용되지 않습니다.|
|컴파일러 오류 C3789|사용되지 않습니다.|
|컴파일러 오류 C3790|사용되지 않습니다.|
|컴파일러 오류 C3791|사용되지 않습니다.|
|컴파일러 오류 C3792|사용되지 않습니다.|
|컴파일러 오류 C3793|사용되지 않습니다.|
|컴파일러 오류 C3794|사용되지 않습니다.|
|컴파일러 오류 C3795|사용되지 않습니다.|
|컴파일러 오류 C3796|사용되지 않습니다.|
|[컴파일러 오류 C3797](compiler-error-c3797.md)|'*keyword*': 이벤트 선언에는 재정의 지정자를 사용할 수 없습니다. 대신 이벤트 추가/제거/발생 메서드에 배치 해야 합니다.|
|[컴파일러 오류 C3798](compiler-error-c3798.md)|'*keyword*': 속성 선언에는 재정의 지정자를 사용할 수 없습니다. 대신 속성 get/set 메서드에 배치 해야 합니다.|
|[컴파일러 오류 C3799](compiler-error-c3799.md)|인덱싱된 속성은 빈 매개 변수 목록을 포함할 수 없습니다.|
|[컴파일러 오류 C3800](compiler-error-c3800.md)|'*선언*': 속성과 이벤트를 혼합할 수 없습니다.|
|컴파일러 오류 C3801|'*attribute*': 특성에는 인수 절이 있을 수 없습니다.|
|컴파일러 오류 C3802|사용되지 않습니다.|
|[컴파일러 오류 C3803](compiler-error-c3803.md)|'*property*': 속성에 해당 접근자 '*accessor*' 중 하 나와 호환 되지 않는 형식이 있습니다.|
|[컴파일러 오류 C3804](compiler-error-c3804.md)|'*member*': 속성에 대 한 접근자 메서드는 모두 static 이거나 모두 static이 아니어야 합니다.|
|[컴파일러 오류 C3805](compiler-error-c3805.md)|'*token*': 예기치 않은 토큰입니다. '} ' 또는 ', '가 필요 합니다.|
|컴파일러 오류 C3806|'*token*': 예기치 않은 토큰입니다. ' {' 또는 멤버 이니셜라이저가 필요 합니다.|
|[컴파일러 오류 C3807](compiler-error-c3807.md)|'*type*': ComImport 특성이 있는 클래스 *는 ' t r u* e '에서 파생 될 수 없습니다. 인터페이스 구현만 허용 됩니다.|
|[컴파일러 오류 C3808](compiler-error-c3808.md)|'*type*': ComImport 특성이 있는 클래스는 '*member*' 멤버를 정의할 수 없습니다. abstract 또는 dllimport 함수만 사용할 수 있습니다.|
|[컴파일러 오류 C3809](compiler-error-c3809.md)|'*type*': 관리 되는/WinRT 형식에는 friend 함수/클래스/인터페이스를 사용할 수 없습니다.|
|컴파일러 오류 C3810|사용되지 않습니다.|
|컴파일러 오류 C3811|사용되지 않습니다.|
|[컴파일러 오류 C3812](compiler-error-c3812.md)|' __property '은 (는) 속성 선언에서 첫 번째 토큰 이어야 합니다.|
|[컴파일러 오류 C3813](compiler-error-c3813.md)|속성 선언은 관리 되는/WinRT 형식의 정의 내에만 나타날 수 있습니다.|
|컴파일러 오류 C3814|사용되지 않습니다.|
|[컴파일러 오류 C3815](compiler-error-c3815.md)|'*member*' 메서드의 반환 형식은 setter의 마지막 매개 변수 형식과 일치 해야 합니다.|
|[컴파일러 오류 C3816](compiler-error-c3816.md)|' 클래스/구조체 *멤버*'는 다른 관리 되는/WinRT 한정자를 사용 하 여 이전에 선언 되었거나 정의 되었습니다.|
|[컴파일러 오류 C3817](compiler-error-c3817.md)|'*선언*': 속성은 함수에만 적용할 수 있습니다.|
|[컴파일러 오류 C3818](compiler-error-c3818.md)|'*property*' 배열 속성 선언은 '*property*' 인덱스 속성을 오버 로드 하지 않아야 합니다.|
|컴파일러 오류 C3819|사용되지 않습니다.|
|[컴파일러 오류 C3820](compiler-error-c3820.md)|'*identifier*': 이니셜라이저는 관리 되어야 합니다.|
|[컴파일러 오류 C3821](compiler-error-c3821.md)|'*function*': 관리 되는 형식 또는 함수는 관리 되지 않는 함수에서 사용할 수 없습니다.|
|컴파일러 오류 C3822|사용되지 않습니다.|
|컴파일러 오류 C3823|사용되지 않습니다.|
|[컴파일러 오류 C3824](compiler-error-c3824.md)|'*type*':이 형식은이 컨텍스트 (함수 매개 변수, 반환 형식 또는 정적 멤버)에 사용할 수 없습니다.|
|[컴파일러 오류 C3825](compiler-error-c3825.md)|'*type*': 관리 되는/winrt 클래스는 관리 되는/winrt 이벤트만 지원할 수 있습니다.|
|컴파일러 오류 C3826|사용되지 않습니다.|
|컴파일러 오류 C3827|표준 특성 ' 사용 되지 않음 '은 인수를 사용 하거나 이유를 설명 하는 문자열 리터럴이 하나 있을 수 있습니다.|
|[컴파일러 오류 C3828](compiler-error-c3828.md)|'*type*' 형식의 '*keyword*' 식에 대해 배치 인수를 지정할 수 없습니다.|
|컴파일러 오류 C3829|표준 특성 ' noreturn '는 함수에만 적용할 수 있습니다.|
|[컴파일러 오류 C3830](compiler-error-c3830.md)|'*type1*': '*type2*'에서 상속할 수 없습니다. 값 형식은 인터페이스 클래스 에서만 상속할 수 있습니다.|
|[컴파일러 오류 C3831](compiler-error-c3831.md)|'*identifier*': '*type*'에 고정 된 데이터 멤버 또는 고정 포인터를 반환 하는 멤버 함수를 사용할 수 없습니다.|
|[컴파일러 오류 C3832](compiler-error-c3832.md)|'*typelib*': 형식 라이브러리는 32 비트 포인터에 대해 빌드된 것 처럼 보입니다. ' ptrsize ' 한정자를 변경 하세요.|
|[컴파일러 오류 C3833](compiler-error-c3833.md)|'*type*': *식별자* 에 대 한 대상 형식이 잘못 되었습니다.|
|[컴파일러 오류 C3834](compiler-error-c3834.md)|고정 포인터에 대 한 명시적 캐스트가 잘못 되었습니다. 대신 고정 된 지역 변수 사용|
|컴파일러 오류 C3835|사용되지 않습니다.|
|[컴파일러 오류 C3836](compiler-error-c3836.md)|정적 생성자에는 멤버 이니셜라이저 목록을 사용할 수 없습니다.|
|컴파일러 오류 C3837|이 컨텍스트에서는 특성을 사용할 수 없습니다.|
|[컴파일러 오류 C3838](compiler-error-c3838.md)|*' t r u* e '에서 상속할 수 없습니다.|
|[컴파일러 오류 C3839](compiler-error-c3839.md)|관리 되는/WinRT 형식의 맞춤은 변경할 수 없습니다.|
|컴파일러 오류 C3840|사용되지 않습니다.|
|컴파일러 오류 C3841|사용되지 않습니다.|
|[컴파일러 오류 C3842](compiler-error-c3842.md)|'*identifier*': 관리 되는/WinRT 형식의 멤버 함수에는 ' const ' 및 ' volatile ' 한정자를 사용할 수 없습니다.|
|컴파일러 오류 C3843|'*identifier*': 참조-관리 되는/WinRT 형식의 멤버 함수에 대 한 한정자는 지원 되지 않습니다.|
|컴파일러 오류 C3844|'*identifier*':*' t y p e*'이 현재 범위에 이미 있으므로 '*source*'에서 기호를 가져올 수 없습니다.|
|컴파일러 오류 C3845|사용되지 않습니다.|
|[컴파일러 오류 C3846](compiler-error-c3846.md)|'*identifier*'*: ' t* y p e '에서 '*identifier*'를 다른 '*assembly*' 어셈블리에서 가져온 기호를 가져올 수 없습니다.|
|컴파일러 오류 C3847|사용되지 않습니다.|
|[컴파일러 오류 C3848](compiler-error-c3848.md)|'*type*' 형식의 식에서 '*identifier*'를 호출 하기 위해 일부 const volatile 한정자가 손실 됩니다.|
|[컴파일러 오류 C3849](compiler-error-c3849.md)|'*type*' 형식의 식에 대 한 함수 스타일 *호출은 모든 사용* 가능한 연산자 오버 로드에 대해 const 및/또는 volatile 한정자가 손실 됩니다.|
|[컴파일러 오류 C3850](compiler-error-c3850.md)|'*token*': 유니버설 문자 이름에서 잘못 된 문자를 지정 합니다.|
|[컴파일러 오류 C3851](compiler-error-c3851.md)|'*token*': 유니버설 문자 이름에는 기본 문자 집합의 문자를 지정할 수 없습니다.|
|[컴파일러 오류 C3852](compiler-error-c3852.md)|'*member*' 형식 '*type*': 집합체 초기화에서이 멤버를 초기화할 수 없습니다.|
|[컴파일러 오류 C3853](compiler-error-c3853.md)|' = ': 함수 참조를 통해 참조 또는 할당을 다시 초기화할 수 없습니다.|
|[컴파일러 오류 C3854](compiler-error-c3854.md)|' = ' 왼쪽의 식이 함수로 계산 됩니다. 함수에 할당할 수 없습니다. 함수는 l-value가 아닙니다.|
|[컴파일러 오류 C3855](compiler-error-c3855.md)|'*function*': 템플릿/제네릭 매개 변수 '*identifier*'가 선언과 호환 되지 않습니다.|
|[컴파일러 오류 C3856](compiler-error-c3856.md)|'*class*': 클래스가 클래스 템플릿/제네릭 클래스가 아닙니다.|
|[컴파일러 오류 C3857](compiler-error-c3857.md)|'*template*': 여러 개의 템플릿/제네릭 매개 변수 목록을 사용할 수 없습니다.|
|[컴파일러 오류 C3858](compiler-error-c3858.md)|'*identifier*': 현재 범위에서 다시 선언할 수 없습니다.|
|[컴파일러 오류 C3859](compiler-error-c3859.md)|PCH의 가상 메모리 범위를 초과 했습니다. '-Zm *number*' 이상의 명령줄 옵션을 사용 하 여 다시 컴파일하십시오.|
|[컴파일러 오류 C3860](compiler-error-c3860.md)|클래스 템플릿/제네릭 이름 다음에 있는 템플릿/제네릭 인수 목록은 템플릿/제네릭 매개 변수 목록에 사용 된 순서로 매개 변수를 나열 해야 합니다.|
|[컴파일러 오류 C3861](compiler-error-c3861.md)|'*identifier*': 식별자를 찾을 수 없습니다.|
|[컴파일러 오류 C3862](compiler-error-c3862.md)|'*function*':/clr: pure 또는/clr: safe를 사용 하 여 관리 되지 않는 함수를 컴파일할 수 없습니다.|
|컴파일러 오류 C3863|'*type*' 배열 형식을 할당할 수 없습니다.|
|컴파일러 오류 C3864|사용되지 않습니다.|
|[컴파일러 오류 C3865](compiler-error-c3865.md)|'*keyword*': 네이티브 멤버 함수에만 사용할 수 있습니다.|
|[컴파일러 오류 C3866](compiler-error-c3866.md)|소멸자/종료자 호출에 인수 목록이 없습니다.|
|[컴파일러 오류 C3867](compiler-error-c3867.md)|'*function*': 표준이 아닌 구문입니다. ' & '를 사용 하 여 멤버에 대 한 포인터 만들기|
|[컴파일러 오류 C3868](compiler-error-c3868.md)|'*type*': 제네릭 매개 변수 '*parameter*'의 제약 조건이 선언에 대 한 제약 조건과 다릅니다.|
|[컴파일러 오류 C3869](compiler-error-c3869.md)|gcnew 제약 조건에 빈 매개 변수 목록 ' () '가 없습니다.|
|컴파일러 오류 C3870|'*parameter*': ' __declspec (*지정자*) '는 정수 형식의 매개 변수에만 적용할 수 있습니다.|
|컴파일러 오류 C3871|'*parameter*': ' __declspec (가드 (오버플로)) '는 함수의 처음 64 매개 변수에만 지원 됩니다.|
|[컴파일러 오류 C3872](compiler-error-c3872.md)|' 0x *value*': 식별자에는이 문자를 사용할 수 없습니다.|
|[컴파일러 오류 C3873](compiler-error-c3873.md)|' 0x *value*':이 문자는 식별자의 첫 문자로 사용할 수 없습니다.|
|[컴파일러 오류 C3874](compiler-error-c3874.md)|'*identifier*'의 반환 형식은 '*type2*' 대신 '*type1*' 이어야 합니다.|
|컴파일러 오류 C3875|비정적 멤버 함수 호출에 인수 목록이 없습니다.|
|컴파일러 오류 C3876|사용되지 않습니다.|
|컴파일러 오류 C3877|사용되지 않습니다.|
|컴파일러 오류 C3878|사용되지 않습니다.|
|컴파일러 오류 C3879|'*member*': initonly 데이터 멤버가 될 수 없습니다.|
|[컴파일러 오류 C3880](compiler-error-c3880.md)|'*member*': 리터럴 데이터 멤버일 수 없습니다.|
|컴파일러 오류 C3881|직접 기반 에서만 생성자를 상속할 수 있습니다.|
|컴파일러 오류 C3882|'*class*': 생성자가 이미 '*class*'에서 상속 되었습니다.|
|컴파일러 오류 C3883|'*member*': initonly 정적 데이터 멤버를 초기화 해야 합니다.|
|컴파일러 오류 C3884|'*type*': 크기를 알 수 없는 배열의 값은 초기화할 수 없습니다.|
|컴파일러 오류 C3885|'*type*': 크기를 알 수 없는 배열은 비어 있는 이니셜라이저 목록으로 초기화할 수 없습니다.|
|[컴파일러 오류 C3886](compiler-error-c3886.md)|'*member*': 리터럴 데이터 멤버를 초기화 해야 합니다.|
|[컴파일러 오류 C3887](compiler-error-c3887.md)|'*member*': 리터럴 데이터 멤버에 대 한 이니셜라이저는 상수 식 이어야 합니다.|
|[컴파일러 오류 C3888](compiler-error-c3888.md)|'*member*':이 리터럴 데이터 멤버와 연결 된 Const 식은 c + +/cli에서 지원 되지 않습니다.|
|컴파일러 오류 C3889|사용되지 않습니다.|
|[컴파일러 오류 C3890](compiler-error-c3890.md)|'*member*': 리터럴 데이터 멤버의 주소를 가져올 수 없습니다.|
|[컴파일러 오류 C3891](compiler-error-c3891.md)|'*member*': 리터럴 데이터 멤버를 l-value로 사용할 수 없습니다.|
|[컴파일러 오류 C3892](compiler-error-c3892.md)|'*variable*': const 인 변수에 할당할 수 없습니다.|
|[컴파일러 오류 C3893](compiler-error-c3893.md)|'*member*': '*class*' 클래스의 인스턴스 생성자 에서만 initonly 데이터 멤버를 l-value로 사용할 수 있습니다.|
|[컴파일러 오류 C3894](compiler-error-c3894.md)|'*member*': '*class*' 클래스의 클래스 생성자 에서만 initonly 정적 데이터 멤버를 l-value로 사용할 수 있습니다.|
|[컴파일러 오류 C3895](compiler-error-c3895.md)|'*member*': *형식* 데이터 멤버는 ' volatile ' 일 수 없습니다.|
|[컴파일러 오류 C3896](compiler-error-c3896.md)|'*member*': 잘못 된 이니셜라이저:이 리터럴 데이터 멤버는 ' nullptr '로만 초기화할 수 있습니다.|
|컴파일러 오류 C3897|사용되지 않습니다.|
|[컴파일러 오류 C3898](compiler-error-c3898.md)|'*member*': *형식* 데이터 멤버는 관리 되는 형식의 멤버일 수만 있습니다.|
|[컴파일러 오류 C3899](compiler-error-c3899.md)|'*member*': '*class*' 클래스의 병렬 영역 내부에서는 initonly 데이터 멤버의 l-value 사용을 직접 사용할 수 없습니다.|
|[컴파일러 오류 C3900](compiler-error-c3900.md)|'*member*': 현재 범위에서 사용할 수 없습니다.|
|[컴파일러 오류 C3901](compiler-error-c3901.md)|'*function*': '*type*' 반환 형식이 있어야 합니다.|
|[컴파일러 오류 C3902](compiler-error-c3902.md)|'*function*': 마지막 매개 변수의 *형식은 ' t r u* e ' 여야 합니다.|
|[컴파일러 오류 C3903](compiler-error-c3903.md)|'*property*': set 또는 get 메서드가 없습니다.|
|[컴파일러 오류 C3904](compiler-error-c3904.md)|'*property*': *숫자* 매개 변수를 지정 해야 합니다.|
|컴파일러 오류 C3905|'*type*' 내장 형식에는 정렬 되지 않은 액세스를 사용할 수 없습니다.|
|컴파일러 오류 C3906|내장 *형식 ' t r u e '* 는 vararg 또는 프로토타입화 되지 않은 함수에 대해 지원 되는 반환 또는 인수 형식이 아닙니다.|
|컴파일러 오류 C3907|사용되지 않습니다.|
|[컴파일러 오류 C3908](compiler-error-c3908.md)|액세스 수준이 '*identifier*' 보다 덜 제한적입니다.|
|[컴파일러 오류 C3909](compiler-error-c3909.md)|관리 되는/WinRT 이벤트 선언은 관리 되는/WinRT 형식에서 발생 해야 합니다.|
|[컴파일러 오류 C3910](compiler-error-c3910.md)|'*event*': '*member*' 멤버를 정의 해야 합니다.|
|[컴파일러 오류 C3911](compiler-error-c3911.md)|'*member*': 함수는 '*type*' 형식 이어야 합니다.|
|[컴파일러 오류 C3912](compiler-error-c3912.md)|'*event*': 이벤트 형식이 대리자 형식 이어야 합니다.|
|[컴파일러 오류 C3913](compiler-error-c3913.md)|기본 속성은 인덱싱되어 야 합니다.|
|[컴파일러 오류 C3914](compiler-error-c3914.md)|기본 속성은 정적일 수 없습니다.|
|[컴파일러 오류 C3915](compiler-error-c3915.md)|'*identifier*'에 인덱싱된 기본 속성 (클래스 인덱서)이 없습니다.|
|컴파일러 오류 C3916|사용되지 않습니다.|
|[컴파일러 오류 C3917](compiler-error-c3917.md)|'*token*': 사용 되지 않는 *구문* 선언 스타일입니다. 대신 ' [' '] '를 사용 해야 합니다.|
|[컴파일러 오류 C3918](compiler-error-c3918.md)|사용 하려면 '*identifier*'를 데이터 멤버로 사용 해야 합니다.|
|[컴파일러 오류 C3919](compiler-error-c3919.md)|'*function*': 함수는 '*return_type* (*형식*) ' 형식 이어야 합니다.|
|[컴파일러 오류 C3920](compiler-error-c3920.md)|'*operator*': 후 위 Clr/winrt 연산자를 호출 하는 후 위 증가/감소 Clr/winrt 연산자를 정의할 수 없습니다. 후 위 의미 체계를 사용 하 여 해당 접두사 CLR/winrt 연산자 (op_Increment/op_Decrement)를 호출 합니다.|
|컴파일러 오류 C3921|사용되지 않습니다.|
|컴파일러 오류 C3922|사용되지 않습니다.|
|[컴파일러 오류 C3923](compiler-error-c3923.md)|'*member*': 관리 되는/WinRT 클래스의 멤버 함수에는 지역 클래스, 구조체 또는 공용 구조체 정의를 사용할 수 없습니다.|
|컴파일러 오류 C3924|'*constructor*' 대리자 생성자 호출의 인수 #*number* 에 오류가 있습니다.|
|컴파일러 오류 C3925|'*지시어*' 지시문 다음에 루프 (for, while 또는 do)가 필요 합니다.|
|컴파일러 오류 C3926|' parallel ' 지시문에 잘못 된 상수가 있습니다.|
|컴파일러 오류 C3927|'-> ': 후행 반환 형식은 비 함수 선언 자 뒤에 사용할 수 없습니다.|
|컴파일러 오류 C3928|'-> ': 후행 반환 형식은 괄호로 묶인 선언 자 뒤에 올 수 없습니다.|
|컴파일러 오류 C3929|사용되지 않습니다.|
|컴파일러 오류 C3930|'*function*': 앰비언트 컨텍스트 '*context*'와 호환 되는 제한 지정 자가 있는 오버 로드 된 함수가 없습니다.|
|컴파일러 오류 C3931|'*type*': 앰비언트 컨텍스트와 호환 되지 않는 제한 지정 자가 있는 함수를 호출할 수 없습니다.|
|컴파일러 오류 C3932|사용되지 않습니다.|
|컴파일러 오류 C3933|'*class*': 소멸자의 제한 지정자는 모든 생성자에 대 한 제한의 합집합을 포함 해야 합니다.|
|컴파일러 오류 C3934|' main ' 형식의 함수에는 restrict (cpu) 이외의 제한 지정 자가 있을 수 없습니다.|
|컴파일러 오류 C3935|'*identifier*': 재정의 겹치는 제한 지정자|
|컴파일러 오류 C3936|'*identifier*': 제한 지정자를 인식할 수 없습니다.|
|컴파일러 오류 C3937|빈 제한 지정자는 허용 되지 않습니다.|
|컴파일러 오류 C3938|'*identifier*': extern \042C\042 함수에서는 여러 제한 지정 자가 지원 되지 않습니다.|
|컴파일러 오류 C3939|'*identifier*': 멤버 함수에 대 한 포인터, 함수 포인터, ' amp ' 제한 지정 자가 있는 함수에 대 한 참조는 사용할 수 없습니다.|
|컴파일러 오류 C3940|'*identifier*': 식별자를 찾을 수 없습니다. 컴파일러와 라이브러리 버전이 일치 하지 않을 수 있습니다. Vccorlib .h/.lib, vccorlib120.dll 및 c1xx.dll 일치 하는지 확인 하세요.|
|컴파일러 오류 C3941|'*condition*': '/clr ' 명령줄 옵션이 필요 합니다.|
|컴파일러 오류 C3942|사용되지 않습니다.|
|컴파일러 오류 C3943|사용되지 않습니다.|
|컴파일러 오류 C3944|사용되지 않습니다.|
|컴파일러 오류 C3945|'*type*': Platform:: Exception에서 파생 되지 않는 winrt 개체를 throw 또는 catch 할 수 없습니다.|
|컴파일러 오류 C3946|'*type*':이 형식에 typeid를 적용할 수 없습니다.|
|컴파일러 오류 C3947|'*typeid*': typeid를 팩 확장에 적용할 수 없습니다.|
|컴파일러 오류 C3948|'*keyword*':이 컨텍스트에서 팩 확장을 표시할 수 없습니다.|
|컴파일러 오류 C3949|팩 확장 ' ... '은 괄호로 묶은 추상 선언 자에 나타날 수 없습니다.|
|컴파일러 오류 C3950|사용되지 않습니다.|
|컴파일러 오류 C3951|'*Type*' 프로젝션 형식에서 멤버 포인터를 사용할 수 없습니다. 대신 대리자를 사용 하십시오.|
|컴파일러 오류 C3952|'*type*': WinRT는 ' in/out ' 배열을 지원 하지 않습니다. \<T>공용 api에서 ' in ' 및 ' WriteOnlyArray \<T> ' 또는 ' Array \<T> ^ * '에 ' const Array ^ '를 사용 합니다.|
|컴파일러 오류 C3953|WinRT 모듈에서 관리 되는 '*type*' 클래스를 사용할 수 없습니다.|
|컴파일러 오류 C3954|'*type*': WinRT 형식의 게시 된 메서드에서 반환 된 배열은 ' array ^ ' 형식을 사용 해야 합니다. \<T>|
|컴파일러 오류 C3955|'*type*': Public 생성자는 ' out ' 매개 변수 또는 ' WriteOnlyArray '를 포함할 수 없습니다. \<T>|
|컴파일러 오류 C3956|'*type*':*형식이 ' t r u e '* 에 단독으로 표시 되었으며 '*derived_type*'의 기본으로 사용할 수 없습니다.|
|컴파일러 오류 C3957|'*type*': WinRT 형식에 ' n e w '를 사용할 수 없습니다. 대신 ' ref n e w '를 사용 하십시오.|
|컴파일러 오류 C3958|'*type*': WinRT 형식에 ' gcnew '를 사용할 수 없습니다. 대신 ' ref n e w '를 사용 하십시오.|
|컴파일러 오류 C3959|' ref n e w '는 WinRT 형식의 개체를 만드는 데만 사용할 수 있습니다.|
|컴파일러 오류 C3960|사용되지 않습니다.|
|컴파일러 오류 C3961|정적 생성자는 지원 되지 않습니다.|
|컴파일러 오류 C3962|제네릭 클래스는 지원 되지 않습니다.|
|컴파일러 오류 C3963|다차원 배열은 지원 되지 않습니다.|
|컴파일러 오류 C3964|가변 배열은 지원 되지 않습니다.|
|컴파일러 오류 C3965|매개 변수 배열은 지원 되지 않습니다.|
|컴파일러 오류 C3966|'*function*': 제네릭 함수는 지원 되지 않습니다.|
|컴파일러 오류 C3967|'*module*' 모듈에서 '*identifier*'를 가져오는 동안 오류가 발생 했습니다.|
|컴파일러 오류 C3968|'*token*' 토큰은 모듈 이름 구분 기호로 사용할 수 없습니다. 대신 마침표 ('. ')를 사용 하세요.|
|컴파일러 오류 C3969|일관 되지 않은 모듈 이름: '*module1*' 및 '*module1*'|
|컴파일러 오류 C3970|'*identifier*': '*keyword*'는 전역 범위 또는 네임 스페이스 범위에서 ' ref class ' 또는 ' ref u r l '에만 적용할 수 있습니다.|
|컴파일러 오류 C3971|'*type*': 부분 정의는 전체 정의 다음에 나타날 수 없습니다.|
|컴파일러 오류 C3972|'*type*': ' partial '은 클래스 선언 또는 정의에만 적용할 수 있습니다.|
|컴파일러 오류 C3973|사용되지 않습니다.|
|컴파일러 오류 C3974|사용되지 않습니다.|
|컴파일러 오류 C3975|' 클래스/구조체 *식별자*'가 이전에 다른 한정자로 선언 또는 정의 되었습니다.|
|컴파일러 오류 C3976|'*identifier2*'를 사용 하려면 '*identifier1*'을 ' p a l s e '로 선언 해야 합니다.|
|컴파일러 오류 C3977|사용 하려면 '*identifier*'를 정의 하는 어셈블리에 대 한 참조가 필요 합니다.|
|컴파일러 오류 C3978|'*identifier*': 정적 속성은 WinRT 인터페이스 또는 값 형식의 멤버로 사용할 수 없습니다.|
|컴파일러 오류 C3979|'*type*': '*value*' 대신 '*attribute*' 특성을 사용 하십시오.|
|컴파일러 오류 C3980|'*type*'을 메타 데이터로 내보낼 수 없습니다.|
|컴파일러 오류 C3981|'*type*': 값 형식에는 '*identifier*' 정적 데이터 멤버를 사용할 수 없습니다.|
|컴파일러 오류 C3982|'*type*': 값 형식에는 public이 아닌 데이터 멤버 '*identifier*'가 있을 수 없습니다.|
|컴파일러 오류 C3983|'*type*': 값 형식에는 public 비 데이터 멤버 '*identifier*'를 사용할 수 없습니다.|
|컴파일러 오류 C3984|'*type*': 값이 아닌 형식에는 public 데이터 멤버 '*identifier*'를 사용할 수 없습니다.|
|컴파일러 오류 C3985|'*identifier*': public 멤버의 시그니처에 전용 형식 '*member*'가 포함 되어 있습니다.|
|컴파일러 오류 C 3986|'*identifier*': public 멤버의 시그니처에 네이티브 형식 '*member*'이 (가) 있습니다.|
|컴파일러 오류 C3987|'*identifier*': public 멤버의 시그니처에 네이티브 형식 '*type*'이 (가) 있습니다.|
|컴파일러 오류 C3988|'*type*': 네이티브 형식은 public 일 수 없습니다.|
|컴파일러 오류 C3989|'*type*': 중첩 형식은 public 일 수 없습니다.|
|컴파일러 오류 C3990|'*type*': '*attribute*' 특성은 전용 또는 중첩 일 수 없습니다.|
|컴파일러 오류 C3991|'*type*': public이 아니거나 중첩 된 '*interface*' 인터페이스를 구현할 수 없습니다.|
|컴파일러 오류 C3992|'*identifier*': public 멤버의 시그니처에 잘못 된 형식 '*type*'이 (가) 있습니다.|
|컴파일러 오류 C3993|'*type*': 값 형식에는 하나 이상의 public 필드가 포함 되어야 합니다.|
|컴파일러 오류 C3994|'*type*': 값 형식은 인터페이스를 구현 하거나 가상 함수를 포함할 수 없습니다.|
|컴파일러 오류 C3995|'*type*': 값 형식에는 이벤트 멤버 '*identifier*'를 사용할 수 없습니다.|
|컴파일러 오류 C3996|사용되지 않습니다.|
|컴파일러 오류 C3998|' c + +*version*': 지원 되지 않는 c + + 버전입니다. ' c + +*버전*'의 기본값|
|컴파일러 오류 C3999|알 수 없는 오류 자세한 내용을 보려면 [Visual C++ 도움말] 메뉴에서 [기술 지원] 명령을 선택 하거나 기술 지원 도움말 파일을 참조 하십시오.|

## <a name="see-also"></a>참고 항목

[C/c + + 컴파일러 및 빌드 도구 오류 및 경고](../compiler-errors-1/c-cpp-build-errors.md) \
[컴파일러 오류 C2000 ~ C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
