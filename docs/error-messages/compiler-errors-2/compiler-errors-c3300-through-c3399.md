---
description: '자세한 정보: 컴파일러 오류 C3300 ~ C3399'
title: 컴파일러 오류 C3300 ~ C3399
ms.date: 04/21/2019
f1_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
helpviewer_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
ms.assetid: 190b7d29-ffe6-4261-921d-140da1935d00
ms.openlocfilehash: 7c3a2f00edd5bee55ba623125c65590584751c39
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238650"
---
# <a name="compiler-errors-c3300-through-c3399"></a>컴파일러 오류 C3300 ~ C3399

설명서의이 섹션에 있는 문서는 컴파일러에 의해 생성 되는 오류 메시지의 하위 집합을 설명 합니다.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>오류 메시지

|Error|메시지|
|-----------|-------------|
|컴파일러 오류 C3300|'*symbol*': IDL '*value*'의 형식이 잘못 되었습니다.|
|컴파일러 오류 C3301|'*coclass*': coclass는 '*symbol*' 인터페이스 일 수 없습니다.|
|컴파일러 오류 C3302|'*identifier*': 식별자에 *숫자* 이외의 문자가 있습니다.|
|[컴파일러 오류 C3303](compiler-error-c3303.md)|'*attribute*': 특성은 '*type*' 에서만 사용할 수 있습니다.|
|컴파일러 오류 C3304|사용되지 않습니다.|
|컴파일러 오류 C3305|사용되지 않습니다.|
|컴파일러 오류 C3306|'*template*': 명명 되지 않은 클래스 템플릿/제네릭는 허용 되지 않습니다.|
|컴파일러 오류 C3307|'*module*': IDL 모듈을 만들 수 없습니다.|
|컴파일러 오류 C3308|' *function*': 가져온 클래스를 통한 직접 호출은 지원 되지 않습니다.|
|[컴파일러 오류 C3309](compiler-error-c3309.md)|'*macro* / *키워드*': 모듈 이름은 매크로 또는 키워드가 될 수 없습니다.|
|컴파일러 오류 C3310|'*identifier*': 모듈 이름이 충돌 합니다.|
|컴파일러 오류 C3311|모듈 특성은 전역 범위에서 정의 해야 합니다.|
|컴파일러 오류 C3312|'*type*' 형식에 대해 호출 가능한 '*identifier*' 함수를 찾을 수 없습니다.|
|컴파일러 오류 C3313|'*identifier*': 변수에는 '*type*' 형식을 사용할 수 없습니다.|
|컴파일러 오류 C3314|'*symbol*': 지원 되는 IDL 모듈 형식이 아닙니다.|
|컴파일러 오류 C3315|' *function*': 멤버 함수 여야 합니다.|
|컴파일러 오류 C3316|'*type*': 알 수 없는 크기의 배열을 범위 기반 for 문에 사용할 수 없습니다.|
|컴파일러 오류 C3317|'*identifier*': 오버 로드 함수는 범위 기반 for 문에서 식으로 사용할 수 없습니다.|
|컴파일러 오류 C3318|'*type*': 배열은 ' a u t o '를 포함 하는 요소 형식일 수 없습니다.|
|컴파일러 오류 C3319|사용되지 않습니다.|
|[컴파일러 오류 C3320](compiler-error-c3320.md)|'*type*': 형식은 모듈의 ' name ' 속성과 같은 이름을 사용할 수 없습니다.|
|컴파일러 오류 C3321|이 컨텍스트에 예기치 않은 이니셜라이저 목록이 있습니다.|
|[컴파일러 오류 C3322](compiler-error-c3322.md)|'*property*': '*attribute*' 특성에 대 한 올바른 속성이 아닙니다.|
|컴파일러 오류 C3323|' alignas ' 및 ' __declspec (align) '는 함수 선언에 사용할 수 없습니다.|
|컴파일러 오류 C3324|'*property*': '*attribute*' 특성에서 속성이 두 번 이상 발생 합니다.|
|컴파일러 오류 C3325|'*attribute*': 특성의 인수가 너무 많습니다.|
|컴파일러 오류 C3326|'*value*':은 (는) '*attribute*' 특성의 '*property*' 속성에 사용할 수 없는 값입니다.|
|컴파일러 오류 C3327|'*property*': '*attribute*' 특성의 속성 값을 지정 해야 합니다.|
|컴파일러 오류 C3328|'*attribute*': 특성에 충분 한 인수가 없습니다.|
|컴파일러 오류 C3329|구문 오류: '*token1*'는 '*token2*'가 필요 하지 않습니다.|
|컴파일러 오류 C3330|' *function*': 함수는 '*type*' 배열을 반환할 수 없습니다.|
|컴파일러 오류 C3331|'*identifier*': 매개 변수의 특성은 COM 인터페이스 및 coclass 에서만 사용할 수 있습니다.|
|컴파일러 오류 C3332|'*property*': 문법이 일치 하지 않습니다. '*property*' 속성이 모두 필수 이며 기본값을 포함 합니다.|
|[컴파일러 오류 C3333](compiler-error-c3333.md)|'*library*': 손상 된 형식 라이브러리를 #import 수 없습니다.|
|[컴파일러 오류 C3334](compiler-error-c3334.md)|손상된 형식 라이브러리를 #import 할 수 없습니다.|
|컴파일러 오류 C3335|'*identifier*': coclass '*class*'의 기본 인터페이스는 최대 하나만 사용할 수 있습니다.|
|컴파일러 오류 C3336|이 작업은 클래스 범위에서 수행 해야 합니다.|
|컴파일러 오류 C3337|'*identifier*': defaultvtable은 coclass '*class*'의 이벤트 원본 이어야 합니다.|
|컴파일러 오류 C3338|'*identifier*': coclass '*class*'의 이벤트 소스 이기도 한 기본 인터페이스는 최대 하나만 있을 수 있습니다.|
|컴파일러 오류 C3339|템플릿 템플릿 매개 변수는 매개 변수 목록 뒤에 ' class ' 또는 ' typename '이 필요 합니다.|
|[컴파일러 오류 C3340](compiler-error-c3340.md)|'*identifier*': 인터페이스는 ' 제한 됨 ' 및 ' 기본값 ' (coclass '*클래스*') 일 수 없습니다.|
|컴파일러 오류 C3341|'*interface*': defaultvtable 인터페이스는 ' dual ' 또는 ' custom ' 중 하나 여야 합니다.|
|[컴파일러 오류 C3342](compiler-error-c3342.md)|'*identifier*': 모호한 특성입니다.|
|컴파일러 오류 C3343|'*class*::*name*': 특성 식별자의 문자가 너무 많습니다.|
|컴파일러 오류 C3344|'*symbol*'의 명시적 특수화 나 부분 특수화를 정의할 수 없습니다.|
|[컴파일러 오류 C3345](compiler-error-c3345.md)|'*name*': 모듈 이름의 식별자가 잘못 되었습니다.|
|컴파일러 오류 C3346|비 네임 스페이스 범위에서 선언을 내보냈습니다.|
|[컴파일러 오류 C3347](compiler-error-c3347.md)|'*argument*': 특성 \ *공 물* 에 필수 인수를 지정 하지 않았습니다.|
|컴파일러 오류 C3348|내보낸 템플릿이 현재 c + + 표준에 속하지 않습니다.|
|컴파일러 오류 C3349|'*class*::*member*': 멀티 캐스트 특성이 이미 공급자 *공급자* 에 의해 구현 되었습니다.|
|[컴파일러 오류 C3350](compiler-error-c3350.md)|' *function*': 대리자 생성자에 *number* 개의 인수가 필요 합니다.|
|[컴파일러 오류 C3351](compiler-error-c3351.md)|' *function*': NULL 개체 인스턴스를 대리 생성자에 전달 하는 경우 정적 멤버 함수의 주소도 전달 해야 합니다.|
|[컴파일러 오류 C3352](compiler-error-c3352.md)|'*function*': 지정한 함수가 '*type*' 대리자 형식과 일치 하지 않습니다.|
|[컴파일러 오류 C3353](compiler-error-c3353.md)|'*identifier*': 대리자는 전역 함수 또는 관리 되는/WinRT 형식의 멤버 함수 에서만 만들 수 있습니다.|
|[컴파일러 오류 C3354](compiler-error-c3354.md)|'*identifier*': 대리자를 만드는 데 사용 되는 함수는 '*type*' 반환 형식을 사용할 수 없습니다.|
|컴파일러 오류 C3355|'*class*::*member*': 멀티 캐스트 특성이 '*provider1*' 공급자를 수신 하지만 '*provider2*' 공급자에 의해 구현 되었습니다.|
|[컴파일러 오류 C3356](compiler-error-c3356.md)|'*identifier*': 정규화 된 이름을 사용 하 여 멀티 캐스트 특성을 호출할 수 없습니다.|
|컴파일러 오류 C3357|'*attribute*': 특성이 모호 합니다. 정규화 된 이름을 사용 해야 합니다.|
|[컴파일러 오류 C3358](compiler-error-c3358.md)|'*symbol*': 기호를 찾을 수 없습니다.|
|컴파일러 오류 C3359|'*특수화*': 템플릿을 특수화할 수 없습니다.|
|[컴파일러 오류 C3360](compiler-error-c3360.md)|'*string*': *이름을* 만들 수 없습니다.|
|컴파일러 오류 C3361|*작업을 수행할* 컨텍스트가 없습니다.|
|컴파일러 오류 C3362|'*class*::*member*': 멀티 캐스트 특성이 구현 되지 않았습니다.|
|[컴파일러 오류 C3363](compiler-error-c3363.md)|'*identifier*': ' typeid '는 형식에만 적용할 수 있습니다.|
|[컴파일러 오류 C3364](compiler-error-c3364.md)|' *function*': 대리자 생성자에 대 한 인수가 잘못 되었습니다. 대리자 대상은 멤버 함수에 대 한 포인터 여야 합니다.|
|[컴파일러 오류 C3365](compiler-error-c3365.md)|연산자 '*operator*': '*type*' 및 '*type*' 형식의 피연산자가 서로 다릅니다.|
|[컴파일러 오류 C3366](compiler-error-c3366.md)|'*member*': 관리 되는/WinRT 형식의 정적 데이터 멤버는 클래스 정의 내에 정의 되어야 합니다.|
|[컴파일러 오류 C3367](compiler-error-c3367.md)|' *function*': 정적 함수를 사용 하 여 바인딩되지 않은 대리자를 만들 수 없습니다.|
|[컴파일러 오류 C3368](compiler-error-c3368.md)|'*선언 자*': IDL에 대 한 호출 규칙이 잘못 되었습니다.|
|[컴파일러 오류 C3369](compiler-error-c3369.md)|'*module*': idl_module 이미 정의 되어 있습니다.|
|[컴파일러 오류 C3370](compiler-error-c3370.md)|'*module*': idl_module 아직 정의 되지 않았습니다.|
|[컴파일러 오류 C3371](compiler-error-c3371.md)|'idl_module': 여기서는 'name' 속성만 사용할 수 있습니다.|
|[컴파일러 오류 C3372](compiler-error-c3372.md)|coclass의 '*attribute*' 특성에 대 한 인터페이스를 하나 이상 지정 해야 합니다.|
|[컴파일러 오류 C3373](compiler-error-c3373.md)|'*attribute*' 특성은 coclass를 제외 하 고 인수를 사용 하지 않습니다.|
|[컴파일러 오류 C3374](compiler-error-c3374.md)|대리자 인스턴스를 만들지 않는 한 ' *function*'의 주소를 가져올 수 없습니다.|
|[컴파일러 오류 C3375](compiler-error-c3375.md)|'*function*': 대리자 함수가 모호 합니다.|
|컴파일러 오류 C3376|'*template*': 정적 데이터 멤버 템플릿만 허용 됩니다.|
|컴파일러 오류 C3377|' decltype (auto) '는 new 식에서 사용할 수 없습니다.|
|컴파일러 오류 C3378|모듈 인터페이스 단위 에서만 선언을 내보낼 수 있습니다.|
|[컴파일러 오류 C3379](compiler-error-c3379.md)|'*class*': 중첩 된 클래스는 해당 선언의 일부로 어셈블리 액세스 지정자를 사용할 수 없습니다.|
|[컴파일러 오류 C3380](compiler-error-c3380.md)|'*지정자*': 어셈블리 액세스 지정 자가 잘못 되었습니다. ' public ' 또는 ' private '만 허용 됩니다.|
|[컴파일러 오류 C3381](compiler-error-c3381.md)|'*지정자*': 어셈블리 액세스 지정자는/clr 옵션으로 컴파일한 코드 에서만 사용할 수 있습니다.|
|[컴파일러 오류 C3382](compiler-error-c3382.md)|/clr:safe를 지정하면 'sizeof'를 사용할 수 없습니다.|
|[컴파일러 오류 C3383](compiler-error-c3383.md)|/clr:safe를 지정하면 'operator new'를 사용할 수 없습니다.|
|[컴파일러 오류 C3384](compiler-error-c3384.md)|'*type*': 값 제약 조건과 ref 제약 조건은 함께 사용할 수 없습니다.|
|[컴파일러 오류 C3385](compiler-error-c3385.md)|' *function*': DllImport 사용자 지정 특성을 가진 함수는 클래스의 인스턴스를 반환할 수 없습니다.|
|[컴파일러 오류 C3386](compiler-error-c3386.md)|'*type*': __declspec (dllexport)/__declspec (dllimport)을 (를) 관리 되는/WinRT 형식에 적용할 수 없습니다.|
|[컴파일러 오류 C3387](compiler-error-c3387.md)|'*member*': __declspec (dllexport)/__declspec (dllimport)을 (를) 관리 되는/WinRT 형식의 멤버에 적용할 수 없습니다.|
|[컴파일러 오류 C3388](compiler-error-c3388.md)|'*token*': 제약 조건으로 사용할 수 없습니다. 구문 분석을 계속 하려면 '*t r u e '로* 가정 합니다.|
|[컴파일러 오류 C3389](compiler-error-c3389.md)|__declspec (*지정자*)는/clr: pure 또는/clr: safe와 함께 사용할 수 없습니다.|
|[컴파일러 오류 C3390](compiler-error-c3390.md)|'*type*': 제네릭 '*generic_type*'의 제네릭 매개 변수 '*parameter*'에 대 한 형식 인수가 잘못 되었습니다. 참조 형식 이어야 합니다.|
|[컴파일러 오류 C3391](compiler-error-c3391.md)|'*type*': 제네릭 '*generic_type*'의 제네릭 매개 변수 '*parameter*'에 대 한 형식 인수가 잘못 되었습니다. null을 허용 하지 않는 값 형식 이어야 합니다.|
|[컴파일러 오류 C3392](compiler-error-c3392.md)|'*type*': 제네릭 '*generic_type*'의 제네릭 매개 변수 '*parameter*'에 대 한 형식 인수가 잘못 되었습니다. 매개 변수가 없는 public 생성자가 있어야 합니다.|
|[컴파일러 오류 C3393](compiler-error-c3393.md)|제약 조건 절의 구문 오류: '*identifier*'가 형식이 아닙니다.|
|[컴파일러 오류 C3394](compiler-error-c3394.md)|제약 조건 절의 구문 오류: 형식이 필요한 데 '*symbol*'이 있습니다.|
|[컴파일러 오류 C3395](compiler-error-c3395.md)|' *function*': __declspec (dllexport)을 (를) 호출 규칙을 __clrcall 사용 하는 함수에 적용할 수 없습니다.|
|[컴파일러 오류 C3396](compiler-error-c3396.md)|'*클래스* 입니다. *member*': 사용자 지정 특성을 '*namespace*'에서 찾을 수 없습니다.|
|[컴파일러 오류 C3397](compiler-error-c3397.md)|기본 인수에서는 집합체 초기화가 허용되지 않습니다.|
|[컴파일러 오류 C3398](compiler-error-c3398.md)|'*operator*': '*type*'에서 '*t r u e '로* 변환할 수 없습니다. 소스 식은 함수 기호여야 합니다.|
|[컴파일러 오류 C3399](compiler-error-c3399.md)|'*type*': 제네릭 매개 변수의 인스턴스를 만들 때는 인수를 제공할 수 없습니다.|

## <a name="see-also"></a>참고 항목

[C/c + + 컴파일러 및 빌드 도구 오류 및 경고](../compiler-errors-1/c-cpp-build-errors.md) \
[컴파일러 오류 C2000 ~ C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
