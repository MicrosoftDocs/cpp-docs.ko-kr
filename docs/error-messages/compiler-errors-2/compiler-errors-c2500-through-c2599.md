---
title: 컴파일러 오류 C2500 ~ C2599 | Microsoft Docs
ms.custom: ''
ms.date: 11/17/2017
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- C2501
- C2508
- C2515
- C2519
- C2520
- C2522
- C2525
- C2527
- C2536
- C2538
- C2539
- C2546
- C2547
- C2559
- C2560
- C2564
- C2565
- C2576
- C2578
- C2580
- C2590
- C2591
- C2595
- C2596
helpviewer_keywords:
- C2501
- C2508
- C2515
- C2519
- C2520
- C2522
- C2525
- C2527
- C2536
- C2538
- C2539
- C2546
- C2547
- C2559
- C2560
- C2564
- C2565
- C2576
- C2578
- C2580
- C2590
- C2591
- C2595
- C2596
dev_langs:
- C++
ms.assetid: a869aaed-e9f6-49e3-b273-00ea7f45bed7
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: c54a35c50516b541ee6e76aea3c0b4b3147e5a1b
ms.sourcegitcommit: 913c3bf23937b64b90ac05181fdff3df947d9f1c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/18/2018
ms.locfileid: "46017778"
---
# <a name="compiler-errors-c2500-through-c2599"></a>컴파일러 오류 C2500 ~ C2599

설명서의이 섹션의 문서는 컴파일러에서 생성 되는 오류 메시지의 하위 집합을 설명 합니다.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>오류 메시지

|Error|메시지|
|-----------|-------------|
|[컴파일러 오류 C2500](compiler-error-C2500.md)|'*identifier1*': '*identifier2*'는 이미 직접 기본 클래스|
|컴파일러 오류 C2501|'*식별자*': ' __declspec (*지정자*)' 구조체, 공용 구조체, 클래스 또는 부호 없는 비트 필드 멤버에만 적용할 수|
|[컴파일러 오류 C2502](compiler-error-C2502.md)|'*식별자*': 기본 클래스의 액세스 한정자가 너무 많습니다|
|[컴파일러 오류 C2503](compiler-error-C2503.md)|'*클래스*': 기본 클래스에는 크기가 0 인 배열을 포함할 수 없습니다|
|[컴파일러 오류 C2504](compiler-error-C2504.md)|'*클래스*': 기본 클래스 정의 되지 않음|
|[컴파일러 오류 C2505](compiler-error-C2505.md)|'*기호*': ' __declspec (*지정자*)' 전역 개체 또는 정적 데이터 멤버의 선언 또는 정의에 적용할 수|
|[컴파일러 오류 C2506](compiler-error-C2506.md)|'*멤버*': ' __declspec (*지정자*)'이 기호에 적용할 수 없습니다.|
|[컴파일러 오류 C2507](compiler-error-C2507.md)|'*식별자*': 기본 클래스에 가상 한정자가 너무 많습니다|
|컴파일러 오류 C2508|'*식별자*': ' __declspec (*specifier1*)'와 결합할 수 없습니다. ' __declspec (*specifier2*)'|
|[컴파일러 오류 C2509](compiler-error-C2509.md)|'*식별자*': 멤버 함수에서 선언 되지 '*클래스*'|
|[컴파일러 오류 C2510](compiler-error-C2510.md)|'*식별자*': 왼쪽은 ': '은 클래스/구조체/공용 이어야 합니다|
|[컴파일러 오류 C2511](compiler-error-C2511.md)|'*식별자*': 오버 로드 된 멤버 함수에서 찾을 수 없습니다 '*클래스*'|
|[컴파일러 오류 C2512](compiler-error-C2512.md)|'*식별자*': 해당 하는 기본 생성자를 사용할 수 없음|
|[컴파일러 오류 C2513](compiler-error-C2513.md)|' * 형식 ': '=' 앞에 없는 변수 선언|
|[컴파일러 오류 C2514](compiler-error-C2514.md)|'*클래스*': 클래스에 생성자가 없습니다|
|컴파일러 오류 C2515|'*식별자*': 'vtguard'는 클래스 선언 또는 정의에 적용 될 수 있습니다|
|[컴파일러 오류 C2516](compiler-error-C2516.md)|'*클래스*': 올바른 기본 클래스가 아닙니다.|
|[컴파일러 오류 C2517](compiler-error-C2517.md)|'*식별자*': 오른쪽 ': ' 정의 되지 않습니다|
|[컴파일러 오류 C2518](compiler-error-C2518.md)|키워드 '*키워드*' 기본 클래스 목록에 잘못 된; 무시|
|컴파일러 오류 C2519|'*식별자*': WinRT 특성은 public 필드만 포함할 수 있습니다|
|컴파일러 오류 C2520|'*클래스*': 암시적 변환에 사용할 수 있는 비 명시적 생성자가 없습니다|
|[컴파일러 오류 C2521](compiler-error-C2521.md)|소멸자/종료자 인수를 사용 하지 않습니다.|
|컴파일러 오류 C2522|'*식별자*': 오버 로드 식별자에 사용할 수 없습니다 '*identifier1*'에 이미 지정 되어' as*identifier2*'|
|[컴파일러 오류 C2523](compiler-error-C2523.md)|'*클래스*:: ~*식별자*': 소멸자/종료자 태그 일치 하지 않습니다.|
|[컴파일러 오류 C2524](compiler-error-C2524.md)|'*식별자*': 소멸자/종료자에는 'void' 매개 변수 목록이 있어야 합니다.|
|컴파일러 오류 C2525|'*식별자*': 매개 변수 '*identifier1*'이름은'*identifier2*' 자료에 대해 작동 하 고 게시 된 구현에서 일치 해야 합니다|
|[컴파일러 오류 C2526](compiler-error-C2526.md)|'*identifier1*': C 링크 함수는 c + + 클래스를 반환할 수 없습니다*identifier2*'|
|컴파일러 오류 C2527|'*식별자*': DefaultOverload 둘 다 지정할 수 없습니다 '*function1*'및'*function2*'. 하나의 사양을 제거 하거나 구현 중 함수 이름 바꾸기|
|[컴파일러 오류 C2528](compiler-error-C2528.md)|'*식별자*': 참조 한 포인터가 잘못 되었습니다|
|[컴파일러 오류 C2529](compiler-error-C2529.md)|'*식별자*': 참조에 대 한 참조가 잘못 되었습니다.|
|[컴파일러 오류 C2530](compiler-error-C2530.md)|'*식별자*': 참조를 초기화 해야 합니다|
|[컴파일러 오류 C2531](compiler-error-C2531.md)|'*식별자*': 비트 필드 잘못 된에 대 한 참조|
|[컴파일러 오류 C2532](compiler-error-C2532.md)|'*식별자*': 참조에 대 한 잘못 된 한정자|
|[컴파일러 오류 C2533](compiler-error-C2533.md)|'*식별자*': 생성자는 반환 형식을 사용할 수 없습니다|
|[컴파일러 오류 C2534](compiler-error-C2534.md)|'*식별자*': 생성자는 값을 반환할 수 없습니다.|
|[컴파일러 오류 C2535](compiler-error-C2535.md)|'*식별자*': 이미 정의 되거나 선언 된 멤버 함수|
|컴파일러 오류 C2536|사용되지 않습니다.|
|[컴파일러 오류 C2537](compiler-error-C2537.md)|'*지정자*': 링크 사양이 올바르지 않습니다|
|컴파일러 오류 C2538|사용되지 않습니다.|
|컴파일러 오류 C2539|사용되지 않습니다.|
|[컴파일러 오류 C2540](compiler-error-C2540.md)|배열 범위가 상수가 아닌 식|
|[컴파일러 오류 C2541](compiler-error-C2541.md)|'*식별자*': 포인터가 아닌 개체를 삭제할 수 없습니다|
|[컴파일러 오류 C2542](compiler-error-C2542.md)|'*식별자*': 클래스 개체의 초기화에 대 한 생성자가 없습니다|
|[컴파일러 오류 C2543](compiler-error-C2543.md)|예상 ']' 연산자에 ''에 대 한|
|[컴파일러 오류 C2544](compiler-error-C2544.md)|예상 ')' (')' 연산자에 대 한|
|[컴파일러 오류 C2545](compiler-error-C2545.md)|'*연산자*': 오버 로드 찾기 연산자 수 없습니다.|
|컴파일러 오류 C2546|'*식별자*': 형식이 PIA와 NO-PIA PIA를 먼저 참조 해야 정의 된 경우|
|컴파일러 오류 C2547|'*식별자*': 선언에 게시 된 메서드의 모든 매개 변수를 명시적으로 지정 해야 합니다|
|[컴파일러 오류 C2548](compiler-error-C2548.md)|'*함수*': 매개 변수에 대 한 기본 매개 변수 누락 *매개 변수*|
|[컴파일러 오류 C2549](compiler-error-C2549.md)|사용자 정의 변환이 반환 형식을 지정할 수 없습니다.|
|[컴파일러 오류 C2550](compiler-error-C2550.md)|'*식별자*': 생성자 이니셜라이저 목록은 생성자 정의에 허용 됩니다|
|[컴파일러 오류 C2551](compiler-error-C2551.md)|'void *' 형식의 경우 명시적 캐스트가 필요합니다.|
|[컴파일러 오류 C2552](compiler-error-C2552.md)|'*식별자*': 이니셜라이저 목록을 사용 하 여 비 집합체를 초기화할 수 없습니다.|
|[컴파일러 오류 C2553](compiler-error-C2553.md)|'*형식* *derived_class*::*함수*': 재정의 가상 함수 반환 형식에서 다른 '*형식* *base_ 클래스*::*함수*'|
|[컴파일러 오류 C2555](compiler-error-C2555.md)|'*derived_class*::*함수*': 재정의 가상 함수의 반환 형식에서 공변 (covariant) 되지 다르며 '*base_class*::*함수*'|
|[컴파일러 오류 C2556](compiler-error-C2556.md)|'*type1* *클래스*::*함수*': 오버 로드 된 함수에서 반환 형식을 다른 '*type2* *클래스*::*함수*'|
|[컴파일러 오류 C2557](compiler-error-C2557.md)|'*식별자*': 전용 및 보호 된 멤버는 생성자 없이 초기화할 수 없습니다|
|[컴파일러 오류 C2558](compiler-error-C2558.md)|클래스*클래스*': 복사 생성자를 사용할 수 없거나 복사 생성자가 '으로 선언|
|컴파일러 오류 C2559|'*식별자*': ref 한정자를 사용 하 여 멤버 함수를 사용 하 여 ref 한정자가 없는 멤버 함수를 오버 로드할 수 없습니다|
|컴파일러 오류 C2560|'*식별자*': ref 한정자가 없는 멤버 함수를 사용 하 여 ref 한정자를 사용 하 여 멤버 함수를 오버 로드할 수 없습니다.|
|[컴파일러 오류 C2561](compiler-error-C2561.md)|'*함수*': 함수가 값을 반환 해야 합니다|
|[컴파일러 오류 C2562](compiler-error-C2562.md)|'*함수*': 'void' 함수는 값을 반환|
|[컴파일러 오류 C2563](compiler-error-C2563.md)|정식 매개 변수 목록과에서 일치 하지 않습니다.|
|컴파일러 오류 C2564|사용되지 않습니다.|
|컴파일러 오류 C2565|'*식별자*': ref 한정자 생성자/소멸자에 대해 올바르지 않습니다.|
|[컴파일러 오류 C2566](compiler-error-C2566.md)|조건식에 오버 로드 된 함수|
|[컴파일러 오류 C2567](compiler-error-C2567.md)|메타 데이터를 열 수 없습니다. '*filename*', *possible_reason*|
|[컴파일러 오류 C2568](compiler-error-C2568.md)|'*식별자*': 함수 오버 로드를 확인할 수 없습니다.|
|[컴파일러 오류 C2569](compiler-error-C2569.md)|'*식별자*': 열거형/공용 구조체를 기본 클래스로 사용할 수 없습니다|
|[컴파일러 오류 C2570](compiler-error-C2570.md)|'*식별자*': 공용 구조체는 기본 클래스를 사용할 수 없습니다.|
|[컴파일러 오류 C2571](compiler-error-C2571.md)|'*식별자*': 공용 구조체의 가상 함수 일 수 없습니다 '*union*'|
|[컴파일러 오류 C2572](compiler-error-C2572.md)|'*함수*': 기본 인수 재정의: 매개 변수 *수*|
|[컴파일러 오류 C2573](compiler-error-C2573.md)|'*클래스*':이 형식의 개체에 대 한 포인터를 삭제할 수 없습니다.이 클래스에는 'operator delete'에 대 한 비배치 오버 로드가 없습니다. 사용:: '연산자 delete(void*)' 클래스에 추가 또는 삭제|
|[컴파일러 오류 C2574](compiler-error-C2574.md)|'*소멸자*': 정적으로 선언할 수 없습니다.|
|[컴파일러 오류 C2575](compiler-error-C2575.md)|'*식별자*': 멤버 함수와 기본 가상 일 수 있습니다|
|컴파일러 오류 C2576|'*식별자*': '공용'으로 새 가상 메서드로 정의할 수 없습니다. 메서드가 가상, 만드는 것이 좋습니다 또는 액세스 가능성을 'internal' 또는 'protected private' 변경|
|[컴파일러 오류 C2577](compiler-error-C2577.md)|'*식별자*': 소멸자/종료자는 반환 형식을 가질 수 없습니다.|
|컴파일러 오류 C2578|'*클래스*': 형식은 사용할 수 없습니다 'protected' 또는 'protected public' 생성자|
|[컴파일러 오류 C2579](compiler-error-C2579.md)|형식을 확인할 수 없습니다 *형식* (*오프셋*). 에 필요 *파일 이름*|
|컴파일러 오류 C2580|'*식별자*': 여러 버전의 기본값으로 설정 된 특수 멤버 함수는 허용 되지 않습니다|
|[컴파일러 오류 C2581](compiler-error-C2581.md)|'*형식*': 정적 ' operator =' 함수에 유효 하지 않은|
|[컴파일러 오류 C2582](compiler-error-C2582.md)|' 연산자 *연산자*'함수를 사용할 수 없습니다.'*형식*'|
|[컴파일러 오류 C2583](compiler-error-C2583.md)|'*식별자*': ' const/volatile ' 'this'이 포인터가 생성자/소멸자에 대해 잘못 되었습니다.|
|[컴파일러 오류 C2584](compiler-error-C2584.md)|'*클래스*': 직접 기본 '*base_class2*'; 액세스할 수 있는 자료를 이미 '*base_class1*'|
|[컴파일러 오류 C2585](compiler-error-C2585.md)|명시적 변환 '*형식*' 모호 합니다.|
|[컴파일러 오류 C2586](compiler-error-C2586.md)|잘못 된 사용자 정의 변환 구문이: 잘못 된 간접 참조|
|[컴파일러 오류 C2587](compiler-error-C2587.md)|'*식별자*': 기본 매개 변수로 잘못 된 지역 변수 사용|
|[컴파일러 오류 C2588](compiler-error-C2588.md)|':: ~*식별자*': 잘못 된 전역 소멸자/종료자|
|[컴파일러 오류 C2589](compiler-error-C2589.md)|'*식별자*': 오른쪽에 잘못 된 토큰 ': '|
|컴파일러 오류 C2590|'*식별자*': 생성자는 기본/멤버 이니셜라이저 목록을 사용할 수 있습니다만|
|컴파일러 오류 C2591|ExclusiveTo 사용할 수 없습니다 '*형식*' 인수로 합니다. 만 'ref class'는 유효한 인수|
|[컴파일러 오류 C2592](compiler-error-C2592.md)|'*클래스*': '*base_class2*'에서 상속 된'*base_class1*' 다시 지정할 수 없습니다.|
|[컴파일러 오류 C2593](compiler-error-C2593.md)|' 연산자 *식별자*' 모호 합니다.|
|[컴파일러 오류 C2594](compiler-error-C2594.md)|'*연산자*': 모호한 변환에서 '*type1*'to'*type2*'|
|컴파일러 오류 C2595|'*식별자*' A WinRT 특성 유형은 sealed 여야|
|컴파일러 오류 C2596|'*식별자*' A WinRT 특성 필드에는 'public enum class', 'int', 'unsigned int', 'bool', 'platform:: type', 'platform:: string' 또는 ' Windows:: Foundation:: HResult' 가능|
|[컴파일러 오류 C2597](compiler-error-C2597.md)|비정적 멤버에 대 한 잘못 된 참조 '*식별자*'|
|[컴파일러 오류 C2598](compiler-error-C2598.md)|링크 사양은 전역 범위에 있어야 합니다.|
|[컴파일러 오류 C2599](compiler-error-C2599.md)|'*식별자*': 관리 되는 WinRT 열거형의 정방향 선언은 허용 되지 않습니다|