---
title: CWinAppEx 클래스
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: c222567703d0e57480c00f6f2bf9e78f16979150
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78869940"
---
# <a name="cwinappex-class"></a>CWinAppEx 클래스

`CWinAppEx`는 응용 프로그램 상태를 처리 하 고, 레지스트리에 상태를 저장 하 고, 레지스트리에서 상태를 로드 하 고, 응용 프로그램 관리자를 초기화 하 고, 동일한 응용 프로그램 관리자에 대 한 링크를 제공 합니다.

   더 자세한 내용은 Visual Studio 설치의 **VC\\atlmfc\\src\\mfc** 폴더에 있는 소스 코드를 참조하세요.
## <a name="syntax"></a>구문

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>구성원

### <a name="public-constructors"></a>Public 생성자

|속성|Description|
|----------|-----------------|
|[CWinAppEx:: CWinAppEx](#cwinappex)|`CWinAppEx` 개체를 생성합니다.|

### <a name="public-methods"></a>Public 메서드

|속성|Description|
|----------|-----------------|
|[CWinAppEx:: CleanState](#cleanstate)|Windows 레지스트리에서 응용 프로그램에 대 한 정보를 제거 합니다.|
|[CWinAppEx:: EnableLoadWindowPlacement](#enableloadwindowplacement)|응용 프로그램에서 기본 프레임 창의 초기 크기와 위치를 레지스트리에서 로드할지 여부를 지정 합니다.|
|[CWinAppEx:: EnableTearOffMenus](#enabletearoffmenus)|응용 프로그램의 분리 메뉴를 사용 하도록 설정 합니다.|
|[CWinAppEx:: EnableUserTools](#enableusertools)|사용자가 응용 프로그램에서 사용자 지정 메뉴 명령을 만들 수 있도록 합니다.|
|[CWinAppEx:: ExitInstance](#exitinstance)|응용 프로그램의이 인스턴스를 종료 하기 위해 `Run` 멤버 함수 내에서 프레임 워크에 의해 호출 됩니다. ( [CWinApp:: ExitInstance](../../mfc/reference/cwinapp-class.md#exitinstance)를 재정의 합니다.)|
|[CWinAppEx:: GetBinary](#getbinary)|지정 된 레지스트리 값과 연결 된 이진 데이터를 읽습니다.|
|[CWinAppEx:: GetContextMenuManager](#getcontextmenumanager)|전역 [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) 개체에 대 한 포인터를 반환 합니다.|
|[CWinAppEx:: GetDataVersion](#getdataversion)||
|[CWinAppEx:: GetDataVersionMajor](#getdataversionmajor)|Windows 레지스트리에 저장 된 응용 프로그램의 주 버전을 반환 합니다.|
|[CWinAppEx:: GetDataVersionMinor](#getdataversionminor)|Windows 레지스트리에 저장 된 응용 프로그램의 부 버전을 반환 합니다.|
|[CWinAppEx:: GetInt](#getint)|레지스트리에서 지정 된 값과 연결 된 숫자 데이터를 읽습니다.|
|[CWinAppEx:: GetKeyboardManager](#getkeyboardmanager)|전역 [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) 개체에 대 한 포인터를 반환 합니다.|
|[CWinAppEx:: GetMouseManager](#getmousemanager)|전역 [CMouseManager](../../mfc/reference/cmousemanager-class.md) 개체에 대 한 포인터를 반환 합니다.|
|[CWinAppEx:: GetObject](#getobject)|레지스트리에서 지정 된 값과 연결 된 `CObject`파생 데이터를 읽습니다.|
|[CWinAppEx:: Getreg섹션 경로](#getregsectionpath)|레지스트리 키의 경로인 문자열을 반환 합니다. 이 경로는 제공 된 상대 경로를 응용 프로그램 경로와 연결 합니다.|
|[CWinAppEx:: GetRegistryBase](#getregistrybase)|응용 프로그램의 레지스트리 경로를 반환 합니다.|
|[CWinAppEx:: Get섹션 이진](#getsectionbinary)|레지스트리에서 지정 된 키와 값이 연결 된 이진 데이터를 읽습니다.|
|[CWinAppEx:: Get섹션 Int](#getsectionint)|지정 된 키 및 값과 연결 된 레지스트리에서 숫자 데이터를 읽습니다.|
|[CWinAppEx:: Get섹션 개체](#getsectionobject)|레지스트리의 지정 된 키와 값에 연결 된 `CObject` 데이터를 읽습니다.|
|[CWinAppEx:: Get섹션 문자열](#getsectionstring)|레지스트리의 지정 된 키와 값에 연결 된 문자열 데이터를 읽습니다.|
|[CWinAppEx:: GetShellManager](#getshellmanager)|전역 [Cshellmanager](../../mfc/reference/cshellmanager-class.md) 개체에 대 한 포인터를 반환 합니다.|
|[CWinAppEx:: GetString](#getstring)|레지스트리에서 지정 된 값과 연결 된 문자열 데이터를 읽습니다.|
|[CWinAppEx:: GetTooltipManager](#gettooltipmanager)|전역 [CTooltipManager](../../mfc/reference/ctooltipmanager-class.md) 개체에 대 한 포인터를 반환 합니다.|
|[CWinAppEx:: GetUserToolsManager](#getusertoolsmanager)|전역 [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md) 개체에 대 한 포인터를 반환 합니다.|
|[CWinAppEx:: InitContextMenuManager](#initcontextmenumanager)|`CContextMenuManager` 개체를 초기화합니다.|
|[CWinAppEx:: InitKeyboardManager](#initkeyboardmanager)|`CKeyboardManager` 개체를 초기화합니다.|
|[CWinAppEx:: InitMouseManager](#initmousemanager)|`CMouseManager` 개체를 초기화합니다.|
|[CWinAppEx:: InitShellManager](#initshellmanager)|`CShellManager` 클래스를 초기화 합니다.|
|[CWinAppEx:: InitTooltipManager](#inittooltipmanager)|`CTooltipManager` 클래스를 초기화합니다.|
|[CWinAppEx:: IsResourceSmartUpdate](#isresourcesmartupdate)||
|[CWinAppEx:: IsStateExists](#isstateexists)|지정 된 키가 레지스트리에 있는지 여부를 나타냅니다.|
|[CWinAppEx:: LoadState](#loadstate)|레지스트리에서 응용 프로그램 상태를 로드 합니다.|
|[CWinAppEx:: OnAppContextHelp](#onappcontexthelp)|사용자가 사용자 **지정** 대화 상자에 대 한 컨텍스트 도움말을 요청할 때 프레임 워크에서 호출 됩니다.|
|[CWinAppEx:: OnViewDoubleClick](#onviewdoubleclick)|사용자가 응용 프로그램의 아무 곳 이나 두 번 클릭할 때 사용자 정의 명령을 호출 합니다.|
|[CWinAppEx:: OnWorkspaceIdle](#onworkspaceidle)||
|[CWinAppEx:: SaveState](#savestate)|응용 프로그램 프레임 워크의 상태를 Windows 레지스트리에 씁니다.|
|[CWinAppEx:: SetRegistryBase](#setregistrybase)|기본 레지스트리 키의 경로를 설정 합니다. 이 키는 모든 후속 레지스트리 호출의 루트로 사용 됩니다.|
|[CWinAppEx:: ShowPopupMenu](#showpopupmenu)|팝업 메뉴를 표시 합니다.|
|[CWinAppEx:: WriteBinary](#writebinary)|지정 된 레지스트리 값에 이진 데이터를 씁니다.|
|[CWinAppEx:: WriteInt](#writeint)|지정 된 레지스트리 값에 숫자 데이터를 씁니다.|
|[CWinAppEx:: WriteObject](#writeobject)|[CObject 클래스](../../mfc/reference/cobject-class.md) 에서 파생 된 데이터를 지정 된 레지스트리 값에 씁니다.|
|[CWinAppEx:: WriteSectionBinary](#writesectionbinary)|지정 된 레지스트리 키의 값에 이진 데이터를 씁니다.|
|[CWinAppEx:: WriteSectionInt](#writesectionint)|지정 된 레지스트리 키의 값에 숫자 데이터를 씁니다.|
|[CWinAppEx:: WriteSectionObject](#writesectionobject)|`CObject` 클래스에서 파생 된 데이터를 지정 된 레지스트리 키 값으로 씁니다.|
|[CWinAppEx:: WriteSectionString](#writesectionstring)|지정 된 레지스트리 키의 값에 문자열 데이터를 씁니다.|
|[CWinAppEx:: WriteString](#writestring)|지정 된 레지스트리 값에 문자열 데이터를 씁니다.|

### <a name="protected-methods"></a>보호된 메서드

|속성|Description|
|----------|-----------------|
|[CWinAppEx:: LoadCustomState](#loadcustomstate)|응용 프로그램 상태가 로드 되었을 때 프레임 워크에서 호출 됩니다.|
|[CWinAppEx:: LoadWindowPlacement](#loadwindowplacement)|레지스트리에서 응용 프로그램의 크기와 위치를 로드할 때 프레임 워크에서 호출 됩니다. 로드 된 데이터에는 응용 프로그램이 마지막으로 닫힌 시점에 주 프레임의 크기와 위치가 포함 됩니다.|
|[CWinAppEx:: OnClosingMainFrame](#onclosingmainframe)|주 프레임 창이 WM_CLOSE를 처리할 때 프레임 워크에서 호출 됩니다.|
|[CWinAppEx::P reLoadState](#preloadstate)|응용 프로그램 상태가 로드 되기 직전에 프레임 워크에서 호출 됩니다.|
|[CWinAppEx::P reSaveState](#presavestate)|응용 프로그램 상태를 저장 하기 직전에 프레임 워크에서 호출 됩니다.|
|[CWinAppEx:: ReloadWindowPlacement](#reloadwindowplacement)|레지스트리에서 제공 된 창의 크기와 위치를 다시 로드 합니다.|
|[CWinAppEx:: SaveCustomState](#savecustomstate)|응용 프로그램 상태를 레지스트리에 쓴 후 프레임 워크에서 호출 됩니다.|
|[CWinAppEx:: Windowplacement](#storewindowplacement)|주 프레임의 크기와 위치를 레지스트리에 쓰도록 프레임 워크에서 호출 됩니다.|

### <a name="data-members"></a>데이터 멤버

|속성|Description|
|----------|-----------------|
|[CWinAppEx:: m_bForceImageReset](#m_bforceimagereset)|도구 모음이 포함 된 프레임 창이 로드 될 때 프레임 워크에서 모든 도구 모음 이미지를 다시 설정할지 여부를 지정 합니다.|

## <a name="remarks"></a>설명

MFC 프레임 워크에서 제공 하는 대부분의 기능은 `CWinAppEx` 클래스에 따라 다릅니다. 다음 두 가지 방법 중 하나로 `CWinAppEx` 클래스를 응용 프로그램에 통합할 수 있습니다.

- 주 스레드에서 `CWinAppEx` 클래스를 생성 합니다.

- `CWinAppEx`에서 주 응용 프로그램 클래스를 파생 시킵니다.

응용 프로그램에 `CWinAppEx`를 통합 한 후에는 응용 프로그램 관리자 중 하나를 초기화할 수 있습니다. 응용 프로그램 관리자를 사용 하기 전에 적절 한 initialize 메서드를 호출 하 여 초기화 해야 합니다. 특정 관리자에 대 한 포인터를 가져오려면 연결 된 get 메서드를 호출 합니다. `CWinAppEx` 클래스는 [CMouseManager 클래스](../../mfc/reference/cmousemanager-class.md), [CContextMenuManager 클래스](../../mfc/reference/ccontextmenumanager-class.md), [CKeyboardManager 클래스](../../mfc/reference/ckeyboardmanager-class.md), [CUserToolsManager 클래스](../../mfc/reference/cusertoolsmanager-class.md)및 [cmenutearoffmanager 클래스](../../mfc/reference/cmenutearoffmanager-class.md)와 같은 응용 프로그램 관리자를 관리 합니다.

## <a name="inheritance-hierarchy"></a>상속 계층

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[CWinApp](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>요구 사항

**헤더:** afxwinappex

##  <a name="cleanstate"></a>CWinAppEx:: CleanState

Windows 레지스트리에서 응용 프로그램에 대 한 모든 정보를 제거 합니다.

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>매개 변수

*lpszSectionName*<br/>
진행 레지스트리 키의 경로를 포함 하는 문자열입니다.

### <a name="return-value"></a>Return Value

메서드가 성공 하면 0이 아닌 값입니다. 그렇지 않으면 0입니다.

### <a name="remarks"></a>설명

이 메서드는 레지스트리의 특정 섹션에서 응용 프로그램 데이터를 지웁니다. *LpszSectionName*매개 변수를 사용 하 여 지울 섹션을 지정할 수 있습니다. *LpszSectionName* 가 NULL 인 경우이 메서드는 `CWinAppEx` 개체에 저장 된 기본 레지스트리 경로를 사용 합니다. 기본 레지스트리 경로를 가져오려면 [CWinAppEx:: GetRegistryBase](#getregistrybase)를 사용 합니다.

##  <a name="cwinappex"></a>CWinAppEx:: CWinAppEx

`CWinAppEx` 개체를 생성합니다.

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>매개 변수

*bResourceSmartUpdate*<br/>
진행 작업 영역 개체가 리소스 업데이트를 검색 하 고 처리할지 여부를 지정 하는 부울 매개 변수입니다.

### <a name="remarks"></a>설명

`CWinAppEx` 클래스는 초기화 메서드를 제공 하 고, 응용 프로그램 정보를 레지스트리에 저장 하 고 로드 하는 기능을 제공 하며, 전역 응용 프로그램 설정을 제어 합니다. 또한 [CKeyboardManager 클래스](../../mfc/reference/ckeyboardmanager-class.md) 및 [CUserToolsManager 클래스](../../mfc/reference/cusertoolsmanager-class.md)와 같은 전역 관리자를 사용할 수 있습니다. 각 응용 프로그램은 `CWinAppEx` 클래스의 인스턴스를 하나만 포함할 수 있습니다.

##  <a name="enableloadwindowplacement"></a>CWinAppEx:: EnableLoadWindowPlacement

응용 프로그램에서 기본 프레임 창의 초기 크기와 위치를 레지스트리에서 로드할지 여부를 지정 합니다.

```
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>매개 변수

*bEnable*<br/>
진행 응용 프로그램이 레지스트리에서 주 프레임 창의 초기 크기와 위치를 로드할지 여부를 지정 합니다.

### <a name="remarks"></a>설명

기본적으로 주 프레임의 크기 및 위치는 다른 응용 프로그램 설정과 함께 레지스트리에서 로드 됩니다. 이는 [CWinAppEx:: LoadState](#loadstate)중에 발생 합니다. 레지스트리에서 초기 창 배치를 로드 하지 않으려는 경우 *Benable* 을 FALSE로 설정 하 여이 메서드를 호출 합니다.

##  <a name="enabletearoffmenus"></a>CWinAppEx:: EnableTearOffMenus

[Cmenutearoffmanager](../../mfc/reference/cmenutearoffmanager-class.md) 개체를 만들고 초기화 합니다.

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>매개 변수

*lpszRegEntry*<br/>
진행 레지스트리 키의 경로를 포함 하는 문자열입니다. 응용 프로그램은이 레지스트리 키를 사용 하 여 분리 메뉴에 대 한 정보를 저장 합니다.

*uiCmdFirst*<br/>
진행 첫 번째 분리 메뉴 ID입니다.

*uiCmdLast*<br/>
진행 마지막으로 분리 된 메뉴 ID입니다.

### <a name="return-value"></a>Return Value

`CMenuTearOffManager` 성공적으로 만들어지고 초기화 되었으면 TRUE이 고, 오류가 발생 하면 FALSE이 고 `CMenuTearOffManager` 이미 있으면 FALSE입니다.

### <a name="remarks"></a>설명

이 함수를 사용 하 여 응용 프로그램에서 분리 메뉴를 사용 하도록 설정 합니다. `InitInstance`에서이 함수를 호출 해야 합니다.

##  <a name="enableusertools"></a>CWinAppEx:: EnableUserTools

사용자가 응용 프로그램에서 키 입력을 줄이는 사용자 지정 메뉴 명령을 만들 수 있습니다. 이 메서드는 [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md) 개체를 만듭니다.

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>매개 변수

*uiCmdToolsDummy*<br/>
진행 프레임 워크에서 사용자 도구 메뉴의 명령 ID에 대 한 자리 표시자로 사용 하는 부호 없는 정수입니다.

*uiCmdFirst*<br/>
진행 첫 번째 사용자 도구 명령의 명령 ID입니다.

*uiCmdLast*<br/>
진행 Last user tool 명령의 명령 ID입니다.

*pToolRTC*<br/>
진행 `CUserToolsManager` 개체가 새 사용자 도구를 만드는 데 사용 하는 클래스입니다.

*uArgMenuID*<br/>
진행 인수 메뉴 ID입니다.

*uInitDirMenuID*<br/>
진행 초기 도구 디렉터리의 메뉴 ID입니다.

### <a name="return-value"></a>Return Value

메서드가 `CUserToolsManager` 개체를 만들고 초기화 하면 TRUE입니다. 메서드가 실패 하거나 `CUserToolsManager` 개체가 이미 있는 경우 FALSE입니다.

### <a name="remarks"></a>설명

사용자 정의 도구를 사용 하는 경우 프레임 워크는 사용자 지정 중에 확장 될 수 있는 동적 메뉴를 자동으로 지원 합니다. 프레임 워크는 각 새 항목을 외부 명령과 연결 합니다. 사용자가 **도구** 메뉴에서 적절 한 항목을 선택 하면 프레임 워크에서 이러한 명령을 호출 합니다.

사용자가 새 항목을 추가할 때마다 프레임 워크에서 새 개체를 만듭니다. 새 개체에 대 한 클래스 형식은 *Ptoolrtc*에 의해 정의 됩니다. *Ptoolrtc* 클래스 형식은 [cusertool 클래스](../../mfc/reference/cusertool-class.md)에서 파생 되어야 합니다.

사용자 도구 및 응용 프로그램에 통합 하는 방법에 대 한 자세한 내용은 [사용자 정의 도구](../../mfc/user-defined-tools.md)를 참조 하세요.

##  <a name="exitinstance"></a>CWinAppEx:: ExitInstance

```
virtual int ExitInstance();
```

### <a name="return-value"></a>Return Value

### <a name="remarks"></a>설명

##  <a name="getbinary"></a>CWinAppEx:: GetBinary

지정 된 레지스트리 키에서 이진 데이터를 읽습니다.

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*ppData*<br/>
제한이 메서드가 이진 데이터로 채워지는 버퍼에 대 한 포인터입니다.

*pBytes*<br/>
제한이 메서드에서 읽은 바이트 수를 쓰는 데 사용 하는 부호 없는 정수에 대 한 포인터입니다.

### <a name="return-value"></a>Return Value

성공하면 TRUE이고, 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

이 메서드는 레지스트리에 기록 된 이진 데이터를 읽습니다. 레지스트리에 데이터를 쓰려면 [CWinAppEx:: WriteBinary](#writebinary) 및 [CWinAppEx:: WriteSectionBinary](#writesectionbinary)메서드를 사용 합니다.

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getcontextmenumanager"></a>CWinAppEx:: GetContextMenuManager

전역 [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) 개체에 대 한 포인터를 반환 합니다.

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>Return Value

전역 `CContextMenuManager` 개체에 대 한 포인터입니다.

### <a name="remarks"></a>설명

CContextMenuManager 개체가 초기화 되지 않은 경우이 함수는 포인터를 반환 하기 전에 [CWinAppEx:: InitContextMenuManager](#initcontextmenumanager) 를 호출 합니다.

##  <a name="getdataversion"></a>CWinAppEx:: GetDataVersion

```
int GetDataVersion() const;
```

### <a name="return-value"></a>Return Value

### <a name="remarks"></a>설명

##  <a name="getdataversionmajor"></a>CWinAppEx:: GetDataVersionMajor

[CWinAppEx:: SaveState](#savestate)를 호출할 때 Windows 레지스트리에 저장 된 응용 프로그램의 주 버전을 반환 합니다.

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>Return Value

주 버전 번호를 포함 하는 정수 값입니다.

##  <a name="getdataversionminor"></a>CWinAppEx:: GetDataVersionMinor

[CWinAppEx:: SaveState](#savestate)를 호출할 때 Windows 레지스트리에 저장 된 응용 프로그램의 부 버전을 반환 합니다.

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>Return Value

부 버전 번호를 포함 하는 정수 값입니다.

##  <a name="getint"></a>CWinAppEx:: GetInt

지정 된 레지스트리 키에서 정수 데이터를 읽습니다.

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 항목의 이름을 포함 하는 문자열입니다.

*nDefault*<br/>
진행 지정 된 레지스트리 항목이 존재 하지 않는 경우 메서드가 반환 하는 기본값입니다.

### <a name="return-value"></a>Return Value

메서드가 성공한 경우의 레지스트리 데이터입니다. 그렇지 않으면 *Ndefault*입니다.

### <a name="remarks"></a>설명

이 메서드는 레지스트리에서 정수 데이터를 읽습니다. *LpszEntry*로 표시 된 레지스트리 키와 연결 된 정수 데이터가 없으면이 메서드는 *ndefault*를 반환 합니다. 레지스트리에 데이터를 쓰려면 [CWinAppEx:: WriteSectionInt](#writesectionint) 및 [CWinAppEx:: writeint](#writeint)메서드를 사용 합니다.

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getkeyboardmanager"></a>CWinAppEx:: GetKeyboardManager

전역 [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) 개체에 대 한 포인터를 반환 합니다.

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>Return Value

전역 `CKeyboardManager` 개체에 대 한 포인터입니다.

### <a name="remarks"></a>설명

키보드 관리자가 초기화 되지 않은 경우이 함수는 포인터를 반환 하기 전에 [CWinAppEx:: InitKeyboardManager](#initkeyboardmanager) 를 호출 합니다.

##  <a name="getmousemanager"></a>CWinAppEx:: GetMouseManager

전역 [CMouseManager](../../mfc/reference/cmousemanager-class.md) 개체에 대 한 포인터를 반환 합니다.

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>Return Value

전역 `CMouseManager` 개체에 대 한 포인터입니다.

### <a name="remarks"></a>설명

마우스 관리자가 초기화 되지 않은 경우이 함수는 포인터를 반환 하기 전에 [CWinAppEx:: InitMouseManager](#initmousemanager) 를 호출 합니다.

##  <a name="getobject"></a>CWinAppEx:: GetObject

레지스트리에서 [CObject](../../mfc/reference/cobject-class.md)파생 데이터를 읽습니다.

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 항목의 상대 경로를 포함 하는 문자열입니다.

*obj*<br/>
제한이 `CObject`에 대 한 참조입니다. 메서드는이 참조를 사용 하 여 레지스트리 데이터를 저장 합니다.

### <a name="return-value"></a>Return Value

메서드가 성공 하면 0이 아닌 값입니다. 그렇지 않으면 0입니다.

### <a name="remarks"></a>설명

이 메서드는 `CObject`에서 파생 된 레지스트리에서 데이터를 읽습니다. 레지스트리에 `CObject` 데이터를 쓰려면 [CWinAppEx:: WriteObject](#writeobject) 또는 [CWinAppEx:: WriteSectionObject](#writesectionobject)중 하나를 사용 합니다.

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getregistrybase"></a>CWinAppEx:: GetRegistryBase

응용 프로그램의 기본 레지스트리 경로를 검색 합니다.

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>Return Value

기본 레지스트리 위치의 경로를 포함 하는 문자열입니다.

### <a name="remarks"></a>설명

레지스트리에 액세스 하는 [CWinAppEx 클래스](../../mfc/reference/cwinappex-class.md) 의 모든 메서드는 기본 위치에서 시작 됩니다. 기본 레지스트리 위치의 경로를 검색 하려면이 메서드를 사용 합니다. [CWinAppEx:: SetRegistryBase](#setregistrybase) 를 사용 하 여 기본 레지스트리 위치를 변경 합니다.

##  <a name="getregsectionpath"></a>CWinAppEx:: Getreg섹션 경로

레지스트리 키의 절대 경로를 만들어 반환 합니다.

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>매개 변수

*Sz섹션 추가*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

### <a name="return-value"></a>Return Value

레지스트리 키의 절대 경로를 포함 하는 `CString`입니다.

### <a name="remarks"></a>설명

이 메서드는 응용 프로그램의 기본 레지스트리 위치에 *Sz섹션 add* 의 상대 경로를 추가 하 여 레지스트리 키의 절대 경로를 정의 합니다. 기본 레지스트리 키를 가져오려면 [CWinAppEx:: GetRegistryBase](#getregistrybase)메서드를 사용 합니다.

##  <a name="getsectionbinary"></a>CWinAppEx:: Get섹션 이진

레지스트리에서 이진 데이터를 읽습니다.

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 읽을 값을 포함 하는 문자열입니다.

*ppData*<br/>
제한이 메서드가 데이터를 저장 하는 버퍼에 대 한 포인터입니다.

*pBytes*<br/>
제한이 부호 없는 정수에 대 한 포인터입니다. 메서드는이 매개 변수에 *Ppdata* 의 크기를 씁니다.

### <a name="return-value"></a>Return Value

성공하면 TRUE이고, 실패하면 FALSE입니다.

### <a name="remarks"></a>설명

이 메서드는 [CWinAppEx:: writebinary](#writebinary) 및 [CWinAppEx:: WriteSectionBinary](#writesectionbinary)메서드를 사용 하 여 레지스트리에 작성 된 이진 데이터를 읽습니다.

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getsectionint"></a>CWinAppEx:: Get섹션 Int

레지스트리에서 정수 데이터를 읽습니다.

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 읽을 값을 포함 하는 문자열입니다.

*nDefault*<br/>
진행 지정 된 값이 없는 경우 반환할 기본값입니다.

### <a name="return-value"></a>Return Value

지정 된 레지스트리 값에 저장 된 정수 데이터입니다. 데이터가 없으면 *Ndefault* 입니다.

### <a name="remarks"></a>설명

메서드 [CWinAppEx:: WriteInt](#writeint) 및 [CWinAppEx:: WriteSectionInt](#writesectionint) 를 사용 하 여 정수 데이터를 레지스트리에 씁니다.

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getsectionobject"></a>CWinAppEx:: Get섹션 개체

레지스트리에서 [CObject](../../mfc/reference/cobject-class.md) 레지스트리 데이터를 읽습니다.

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 읽을 값을 포함 하는 문자열입니다.

*obj*<br/>
제한이 `CObject`에 대 한 참조입니다. 메서드는이 `CObject` 사용 하 여 레지스트리 데이터를 저장 합니다.

### <a name="return-value"></a>Return Value

성공하면 0이 아니고, 그렇지 않으면 0입니다.

### <a name="remarks"></a>설명

이 메서드는 레지스트리에서 데이터를 읽습니다. 데이터 읽기는 `CObject` 데이터 또는 `CObject`에서 파생 된 클래스에 대 한 데이터입니다. 레지스트리에 `CObject` 데이터를 쓰려면 [CWinAppEx:: WriteObject](#writeobject) 또는 [CWinAppEx:: WriteSectionObject](#writesectionobject)중 하나를 사용 합니다.

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getsectionstring"></a>CWinAppEx:: Get섹션 문자열

레지스트리에서 문자열 데이터를 읽습니다.

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 읽을 값을 포함 하는 문자열입니다.

*lpszDefault*<br/>
진행 지정 된 값이 없는 경우 반환할 기본값입니다.

### <a name="return-value"></a>Return Value

데이터가 존재 하는 경우 지정 된 레지스트리 값에 저장 된 문자열 데이터입니다. 그렇지 않으면 *lpszDefault*입니다.

### <a name="remarks"></a>설명

이 메서드는 레지스트리에 기록 된 문자열 데이터를 읽습니다. [CWinAppEx:: writestring](#writestring) 및 [CWinAppEx:: WriteSectionString](#writesectionstring) 를 사용 하 여 문자열 데이터를 레지스트리에 씁니다.

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="getshellmanager"></a>CWinAppEx:: GetShellManager

전역 [Cshellmanager](../../mfc/reference/cshellmanager-class.md) 개체에 대 한 포인터를 반환 합니다.

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>Return Value

전역 `CShellManager` 개체에 대 한 포인터입니다.

### <a name="remarks"></a>설명

`CShellManager` 개체가 초기화 되지 않은 경우이 함수는 포인터를 반환 하기 전에 [CWinAppEx:: InitShellManager](#initshellmanager) 를 호출 합니다.

##  <a name="getstring"></a>CWinAppEx:: GetString

지정 된 레지스트리 키에서 문자열 데이터를 읽습니다.

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*lpzDefault*<br/>
진행 지정 된 레지스트리 항목이 존재 하지 않는 경우 메서드가 반환 하는 기본값입니다.

### <a name="return-value"></a>Return Value

성공 하는 경우 레지스트리에 저장 된 문자열 데이터입니다. 그렇지 않으면 *lpszDefault* 입니다.

### <a name="remarks"></a>설명

이 메서드는 레지스트리에 기록 된 문자열 데이터를 읽습니다. 레지스트리에 데이터를 쓰려면 [CWinAppEx:: WriteString](#writestring) 또는 [CWinAppEx:: WriteSectionString](#writesectionstring)메서드를 사용 합니다.

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="gettooltipmanager"></a>CWinAppEx:: GetTooltipManager

전역 [CTooltipManager](../../mfc/reference/ctooltipmanager-class.md) 개체에 대 한 포인터를 반환 합니다.

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>Return Value

전역 `CTooltipManager` 개체에 대 한 포인터입니다.

### <a name="remarks"></a>설명

`CTooltipManager` 개체가 초기화 되지 않은 경우이 함수는 포인터를 반환 하기 전에 [CWinAppEx:: InitTooltipManager](#inittooltipmanager) 를 호출 합니다.

##  <a name="getusertoolsmanager"></a>CWinAppEx:: GetUserToolsManager

전역 [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md) 개체에 대 한 포인터를 반환 합니다.

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>Return Value

전역 `CUserToolsManager` 개체에 대 한 포인터입니다. 응용 프로그램에 대해 사용자 도구 관리를 사용 하도록 설정 하지 않은 경우 NULL입니다.

### <a name="remarks"></a>설명

`CUserToolsManager` 개체에 대 한 포인터를 검색 하기 전에 [CWinAppEx:: EnableUserTools](#enableusertools)를 호출 하 여 관리자를 초기화 해야 합니다.

##  <a name="initcontextmenumanager"></a>CWinAppEx:: InitContextMenuManager

[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) 개체를 초기화 합니다.

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>Return Value

메서드가 CContextMenuManager 개체를 만드는 경우 0이 아닙니다. `CContextMenuManager` 개체가 이미 있으면 0입니다.

### <a name="remarks"></a>설명

[CWinAppEx:: GetContextMenuManager](#getcontextmenumanager)를 호출 하는 경우 해당 메서드의 기본 구현에서 `InitContextMenuManager`를 호출 합니다.

응용 프로그램에 상황에 맞는 메뉴 관리자가 이미 있고 `InitContextMenuManager`를 호출 하는 경우 응용 프로그램에 [ASSERT](diagnostic-services.md#assert) 오류가 발생 합니다. 따라서 `CContextMenuManager` 개체를 직접 만드는 경우 `InitContextMenuManager`를 호출 하면 안 됩니다. 사용자 지정 `CContextMenuManager`를 사용 하지 않는 경우 `GetContextMenuManager`를 사용 하 여 `CContextMenuManager` 개체를 만들어야 합니다.

##  <a name="initkeyboardmanager"></a>CWinAppEx:: InitKeyboardManager

[CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) 개체를 초기화 합니다.

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>Return Value

메서드가 `CKeyboardManager` 개체를 만드는 경우 0이 아닙니다. `CKeyboardManager` 개체가 이미 있으면 0입니다.

### <a name="remarks"></a>설명

[CWinAppEx:: GetKeyboardManager](#getkeyboardmanager)를 호출 하는 경우 해당 메서드의 기본 구현에서 `InitKeyboardManager`를 호출 합니다.

응용 프로그램에 이미 키보드 관리자가 있고 `InitKeyboardManager`를 호출 하는 경우 응용 프로그램에 [ASSERT](diagnostic-services.md#assert) 오류가 발생 합니다. 따라서 `CKeyboardManager` 개체를 직접 만드는 경우 `InitKeyboardManager`를 호출 하면 안 됩니다. 사용자 지정 `CKeyboardManager`를 사용 하지 않는 경우 `GetKeyboardManager`를 사용 하 여 `CKeyboardManager` 개체를 만들어야 합니다.

##  <a name="initmousemanager"></a>CWinAppEx:: InitMouseManager

[CMouseManager](../../mfc/reference/cmousemanager-class.md) 개체를 초기화 합니다.

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>Return Value

메서드가 `CMouseManager` 개체를 만드는 경우 0이 아닙니다. `CMouseManager` 개체가 이미 있으면 0입니다.

### <a name="remarks"></a>설명

[CWinAppEx:: GetMouseManager](#getmousemanager)를 호출 하는 경우 해당 메서드의 기본 구현에서 `InitMouseManager`를 호출 합니다.

응용 프로그램에 이미 마우스 관리자가 있고 `InitMouseManager`를 호출 하는 경우 응용 프로그램에 [ASSERT](diagnostic-services.md#assert) 오류가 발생 합니다. 따라서 `CMouseManager` 개체를 직접 만드는 경우 `InitMouseManager`를 호출 하면 안 됩니다. 사용자 지정 `CMouseManager`를 사용 하지 않는 경우 `GetMouseManager`를 사용 하 여 `CMouseManager` 개체를 만들어야 합니다.

##  <a name="initshellmanager"></a>CWinAppEx:: InitShellManager

[Cshellmanager](../../mfc/reference/cshellmanager-class.md) 개체를 초기화 합니다.

```
BOOL InitShellManager();
```

### <a name="return-value"></a>Return Value

메서드가 `CShellManager` 개체를 만드는 경우 0이 아닙니다. `CShellManager` 개체가 이미 있으면 0입니다.

### <a name="remarks"></a>설명

[CWinAppEx:: GetShellManager](#getshellmanager)를 호출 하는 경우 해당 메서드의 기본 구현에서 `InitShellManager`를 호출 합니다.

응용 프로그램에 셸 관리자가 이미 있고 `InitShellManager`를 호출 하는 경우 응용 프로그램에서 [어설션](diagnostic-services.md#assert) 오류가 발생 합니다. 따라서 `CShellManager` 개체를 직접 만드는 경우 `InitShellManager`를 호출 하지 마십시오. 사용자 지정 `CShellManager`를 사용 하지 않는 경우 `GetShellManager`를 사용 하 여 `CShellManager` 개체를 만듭니다.

##  <a name="inittooltipmanager"></a>CWinAppEx:: InitTooltipManager

[CTooltipManager](../../mfc/reference/ctooltipmanager-class.md) 개체를 초기화 합니다.

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>Return Value

메서드가 `CTooltipManager` 개체를 만드는 경우 0이 아닙니다. `CTooltipManager` 개체가 이미 있으면 0입니다.

### <a name="remarks"></a>설명

[CWinAppEx:: GetTooltipManager](#gettooltipmanager)를 호출 하는 경우 해당 메서드의 기본 구현에서 `InitTooltipManager`를 호출 합니다.

응용 프로그램에 도구 설명 관리자가 이미 있고 `InitTooltipManager`를 호출 하는 경우 응용 프로그램에 [ASSERT](diagnostic-services.md#assert) 오류가 발생 합니다. 따라서 `CTooltipManager` 개체를 직접 만드는 경우 `InitTooltipManager`를 호출 하면 안 됩니다. 사용자 지정 `CTooltipManager`를 사용 하지 않는 경우 `GetTooltipManager`를 사용 하 여 `CTooltipManager` 개체를 만들어야 합니다.

##  <a name="isresourcesmartupdate"></a>CWinAppEx:: IsResourceSmartUpdate

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>Return Value

### <a name="remarks"></a>설명

##  <a name="isstateexists"></a>CWinAppEx:: IsStateExists

지정 된 키가 레지스트리에 있는지 여부를 나타냅니다.

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>매개 변수

*lpszSectionName*<br/>
진행 레지스트리 키의 경로를 포함 하는 문자열입니다.

### <a name="return-value"></a>Return Value

레지스트리에 키가 있는 경우 0이 아닌 값입니다. 그렇지 않으면 0입니다.

##  <a name="loadcustomstate"></a>CWinAppEx:: LoadCustomState

프레임 워크는 레지스트리에서 응용 프로그램의 상태를 로드 한 후이 메서드를 호출 합니다.

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>설명

응용 프로그램이 레지스트리에서 상태를 로드 한 후에 처리를 수행 하려면이 메서드를 재정의 합니다. 기본적으로 이 메서드는 아무것도 수행하지 않습니다.

레지스트리에서 사용자 지정 상태 정보를 로드 하려면 먼저 [CWinAppEx:: SaveCustomState](#savecustomstate)를 사용 하 여 정보를 저장 해야 합니다.

##  <a name="loadstate"></a>CWinAppEx:: LoadState

Windows 레지스트리에서 응용 프로그램 상태를 읽습니다.

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>매개 변수

*pFrame*<br/>
진행 프레임 창 개체에 대 한 포인터입니다. 메서드는 레지스트리의 상태 정보를이 프레임 창에 적용 합니다.

*lpszSectionName*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*P프레임의 구현이*<br/>
진행 `CFrameImpl` 개체에 대 한 포인터입니다. 메서드는 레지스트리의 상태 정보를이 프레임 창에 적용 합니다.

### <a name="return-value"></a>Return Value

성공하는 경우 0이 아닌 값입니다. 그렇지 않은 경우 0입니다.

### <a name="remarks"></a>설명

이 메서드는 응용 프로그램의 상태와 프레임 창에 대 한 상태 정보를 로드 합니다. 프레임 창에 대해 로드 된 정보가 제공 된 프레임 창에 적용 됩니다. 프레임 창을 제공 하지 않으면 응용 프로그램 상태 정보만 로드 됩니다. 응용 프로그램 정보에는 [CMouseManager 클래스](../../mfc/reference/cmousemanager-class.md), [CContextMenuManager 클래스](../../mfc/reference/ccontextmenumanager-class.md), [CKeyboardManager 클래스](../../mfc/reference/ckeyboardmanager-class.md)및 [CUserToolsManager 클래스](../../mfc/reference/cusertoolsmanager-class.md)의 상태가 포함 됩니다.

`CFrameImpl::OnLoadFrame`의 기본 구현은 `LoadState`를 호출 합니다.

*LpszSectionName* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="loadwindowplacement"></a>CWinAppEx:: LoadWindowPlacement

레지스트리에서 주 프레임 창의 크기와 위치를 로드할 때 프레임 워크에서 호출 됩니다.

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>매개 변수

*rectNormalPosition*<br/>
제한이 주 프레임 창의 좌표가 복원 된 위치에 있는 경우이를 포함 하는 사각형입니다.

*nFlags*<br/>
제한이 최소화 된 창의 위치 및 운영 체제가 최소화 된 창과 복원 된 창 간에 전환 되는 방법을 제어 하는 플래그입니다.

*nShowCmd*<br/>
제한이 창의 표시 상태를 지정 하는 정수입니다. 가능한 값에 대 한 자세한 내용은 [CWnd:: ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)를 참조 하세요.

### <a name="return-value"></a>Return Value

성공하는 경우 0이 아닌 값입니다. 그렇지 않은 경우 0입니다.

### <a name="remarks"></a>설명

기본적으로 MFC는 응용 프로그램이 시작 될 때 주 프레임 창의 이전 위치와 상태를 자동으로 로드 합니다. 레지스트리에이 정보가 저장 되는 방법에 대 한 자세한 내용은 [CWinAppEx:: Windowplacement](#storewindowplacement)를 참조 하십시오.

주 프레임 창에 대 한 추가 정보를 로드 하려면이 메서드를 재정의 합니다.

##  <a name="m_bforceimagereset"></a>CWinAppEx:: m_bForceImageReset

도구 모음이 포함 된 프레임 창을 다시 로드할 때 프레임 워크에서 모든 도구 모음 이미지를 다시 설정할지 여부를 지정 합니다.

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>설명

`m_bForceImageReset` 데이터 멤버가 보호 된 변수입니다.

##  <a name="onappcontexthelp"></a>CWinAppEx:: OnAppContextHelp

사용자 **지정** 대화 상자에 대 한 컨텍스트 도움말을 요청 하는 경우 프레임 워크는이 메서드를 호출 합니다.

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>매개 변수

*pWndControl*<br/>
진행 사용자가 컨텍스트 도움말을 호출한 창 개체에 대 한 포인터입니다.

*dwHelpIDArray[]*<br/>
진행 예약 된 값입니다.

### <a name="remarks"></a>설명

이 메서드는 현재 나중에 사용할 수 있도록 예약 되어 있습니다. 기본 구현은 아무 작업도 수행 하지 않으며 현재 프레임 워크에서 호출 되지 않습니다.

##  <a name="onclosingmainframe"></a>CWinAppEx:: OnClosingMainFrame

프레임 워크가 WM_CLOSE를 처리 하는 경우 프레임 워크는이 메서드를 호출 합니다.

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>매개 변수

*P프레임의 구현이*<br/>
진행 `CFrameImpl` 개체에 대 한 포인터입니다.

### <a name="remarks"></a>설명

이 메서드의 기본 구현에서는 *P프레임 구현이*상태를 저장 합니다.

##  <a name="onviewdoubleclick"></a>CWinAppEx:: OnViewDoubleClick

사용자가 뷰 내에서 아무 곳 이나 두 번 클릭할 때 뷰와 연결 된 사용자 정의 명령을 호출 합니다.

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>매개 변수

*pWnd*<br/>
진행 [CView 클래스](../../mfc/reference/cview-class.md)에서 파생 된 개체에 대 한 포인터입니다.

*iViewId*<br/>
진행 뷰 ID입니다.

### <a name="return-value"></a>Return Value

프레임 워크가 명령을 찾은 경우 TRUE입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

사용자 지정 마우스 동작을 지원 하기 위해 WM_LBUTTONDBLCLK 메시지를 처리할 때이 함수를 호출 해야 합니다. 이 메서드는 *iViewId*에서 제공 하는 뷰 ID와 연결 된 명령을 실행 합니다. 사용자 지정 마우스 동작에 대 한 자세한 내용은 [키보드 및 마우스 사용자 지정](../../mfc/keyboard-and-mouse-customization.md)을 참조 하세요.

##  <a name="onworkspaceidle"></a>CWinAppEx:: OnWorkspaceIdle

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>매개 변수

진행 *CWnd&#38;*<br/>

### <a name="return-value"></a>Return Value

### <a name="remarks"></a>설명

##  <a name="preloadstate"></a>CWinAppEx::P reLoadState

프레임 워크는 레지스트리에서 응용 프로그램의 상태를 로드 하기 직전에이 메서드를 호출 합니다.

```
virtual void PreLoadState();
```

### <a name="remarks"></a>설명

프레임 워크가 응용 프로그램 상태를 로드 하기 직전에 처리를 수행 하려면이 메서드를 재정의 합니다.

##  <a name="presavestate"></a>CWinAppEx::P reSaveState

프레임 워크는 응용 프로그램 상태를 저장 하기 직전에이 메서드를 호출 합니다.

```
virtual void PreSaveState();
```

### <a name="remarks"></a>설명

프레임 워크가 응용 프로그램 상태를 저장 하기 직전에 처리를 수행 하려면이 메서드를 재정의 합니다.

##  <a name="reloadwindowplacement"></a>CWinAppEx:: ReloadWindowPlacement

레지스트리에서 창의 크기와 위치를 다시 로드 합니다.

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>매개 변수

*pFrame*<br/>
진행 프레임 창에 대 한 포인터입니다.

### <a name="return-value"></a>Return Value

메서드가 성공 하면 0이 아닌 값입니다. 로드에 실패 했거나 로드할 데이터가 없는 경우 0입니다.

### <a name="remarks"></a>설명

[CWinAppEx:: Windowplacement](#storewindowplacement) 함수를 사용 하 여 레지스트리에 창의 크기 및 위치를 씁니다.

##  <a name="savecustomstate"></a>CWinAppEx:: SaveCustomState

프레임 워크는 응용 프로그램의 상태를 레지스트리에 저장 한 후이 메서드를 호출 합니다.

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>설명

응용 프로그램이 레지스트리에 상태를 저장 한 후에 처리를 수행 하려면이 메서드를 재정의 합니다. 기본적으로 이 메서드는 아무것도 수행하지 않습니다.

##  <a name="savestate"></a>CWinAppEx:: SaveState

Windows 레지스트리에 응용 프로그램 상태를 기록 합니다.

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>매개 변수

*lpszSectionName*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*P프레임의 구현이*<br/>
진행 `CFrameImpl` 개체에 대 한 포인터입니다. 이 프레임은 Windows 레지스트리에 저장 됩니다.

*pFrame*<br/>
진행 프레임 창 개체에 대 한 포인터입니다. 이 프레임은 Windows 레지스트리에 저장 됩니다.

### <a name="return-value"></a>Return Value

성공하면 TRUE이고, 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

이 메서드는 응용 프로그램의 상태 및 제공 된 프레임 창에 대 한 상태 정보를 저장 합니다. 프레임 창을 제공 하지 않으면 메서드는 응용 프로그램 상태만 저장 합니다. 응용 프로그램 정보에는 [CMouseManager 클래스](../../mfc/reference/cmousemanager-class.md), [CContextMenuManager 클래스](../../mfc/reference/ccontextmenumanager-class.md), [CKeyboardManager 클래스](../../mfc/reference/ckeyboardmanager-class.md)및 [CUserToolsManager 클래스](../../mfc/reference/cusertoolsmanager-class.md)의 상태가 포함 됩니다.

*LpszSectionName* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

##  <a name="setregistrybase"></a>CWinAppEx:: SetRegistryBase

응용 프로그램의 기본 레지스트리 경로를 설정 합니다.

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>매개 변수

*lpszSectionName*<br/>
진행 레지스트리 키의 경로를 포함 하는 문자열입니다.

### <a name="return-value"></a>Return Value

기본 레지스트리 위치의 경로를 포함 하는 문자열입니다.

### <a name="remarks"></a>설명

레지스트리에 액세스 하는 [CWinAppEx 클래스](../../mfc/reference/cwinappex-class.md) 의 모든 메서드는 기본 위치에서 시작 됩니다. 기본 레지스트리 위치를 변경 하려면이 메서드를 사용 합니다. [CWinAppEx:: GetRegistryBase](#getregistrybase) 를 사용 하 여 기본 레지스트리 위치를 검색 합니다.

##  <a name="showpopupmenu"></a>CWinAppEx:: ShowPopupMenu

팝업 메뉴를 표시 합니다.

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>매개 변수

*uiMenuResId*<br/>
진행 메뉴 리소스 ID입니다.

*point*<br/>
진행 화면 좌표에서 메뉴의 위치를 지정 하는 [Cpoint](../../atl-mfc-shared/reference/cpoint-class.md) 입니다.

*pWnd*<br/>
진행 팝업 메뉴를 소유 하는 창에 대 한 포인터입니다.

### <a name="return-value"></a>Return Value

팝업 메뉴가 성공적으로 표시 되 면 0이 아닌 값입니다. 그렇지 않으면 0입니다.

### <a name="remarks"></a>설명

이 메서드는 *uiMenuResId*과 연결 된 메뉴를 표시 합니다.

팝업 메뉴를 지원 하려면 [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) 개체가 있어야 합니다. `CContextMenuManager` 개체를 초기화 하지 않은 경우에는 `ShowPopupMenu` 실패 합니다.

##  <a name="storewindowplacement"></a>CWinAppEx:: Windowplacement

주 프레임 창의 크기와 위치를 레지스트리에 쓰기 위해 프레임 워크에서 호출 됩니다.

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>매개 변수

*nFlags*<br/>
진행 최소화 된 창의 위치 및 운영 체제가 최소화 된 창과 복원 된 창 간에 전환 되는 방법을 제어 하는 플래그입니다.

*nShowCmd*<br/>
진행 창의 표시 상태를 지정 하는 정수입니다. 가능한 값에 대 한 자세한 내용은 [CWnd:: ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)를 참조 하세요.

*rectNormalPosition*<br/>
진행 주 프레임 창의 좌표가 복원 된 상태일 때이를 포함 하는 사각형입니다.

### <a name="return-value"></a>Return Value

성공하는 경우 0이 아닌 값입니다. 그렇지 않은 경우 0입니다.

### <a name="remarks"></a>설명

기본적으로 MFC는 응용 프로그램이 종료 되기 전에 주 프레임 창의 위치 및 상태를 자동으로 저장 합니다. 이 정보는 Windows 레지스트리에 응용 프로그램에 대 한 기본 레지스트리 위치의 WindowPlacement 키로 저장 됩니다. 응용 프로그램의 기본 레지스트리 위치에 대 한 자세한 내용은 [CWinAppEx:: GetRegistryBase](#getregistrybase)를 참조 하세요.

주 프레임 창에 대 한 추가 정보를 저장 하려면이 메서드를 재정의 합니다.

##  <a name="writebinary"></a>CWinAppEx:: WriteBinary

레지스트리에 이진 데이터를 씁니다.

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*pData*<br/>
진행 저장할 데이터입니다.

*nBytes*<br/>
진행 *.Pdata* 의 크기 (바이트)입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

*LpszEntry* 로 지정 된 키가 없는 경우이 메서드는 해당 키를 만듭니다.

##  <a name="writeint"></a>CWinAppEx:: WriteInt

레지스트리에 숫자 데이터를 씁니다.

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*N 값*<br/>
진행 저장할 데이터입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

*LpszEntry* 로 지정 된 키가 없는 경우이 메서드는 해당 키를 만듭니다.

##  <a name="writeobject"></a>CWinAppEx:: WriteObject

[CObject 클래스](../../mfc/reference/cobject-class.md) 에서 파생 된 데이터를 레지스트리에 씁니다.

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 설정할 값이 포함 된 문자열입니다.

*obj*<br/>
진행 메서드에서 저장할 `CObject` 데이터에 대 한 참조입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

이 메서드는 기본 레지스트리 키의 지정 된 값에 *obj* 데이터를 씁니다. [CWinAppEx:: GetRegistryBase](#getregistrybase) 를 사용 하 여 현재 레지스트리 키를 확인 합니다.

##  <a name="writesectionbinary"></a>CWinAppEx:: WriteSectionBinary

레지스트리의 값에 이진 데이터를 씁니다.

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 설정할 값이 포함 된 문자열입니다.

*pData*<br/>
진행 레지스트리에 쓸 데이터입니다.

*nBytes*<br/>
진행 *.Pdata* 의 크기 (바이트)입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

*LpszEntry* 로 지정 된 키가 없는 경우이 메서드는 해당 키를 만듭니다.

##  <a name="writesectionint"></a>CWinAppEx:: WriteSectionInt

레지스트리에 숫자 데이터를 씁니다.

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 상대 경로를 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 설정할 값이 포함 된 문자열입니다.

*N 값*<br/>
진행 레지스트리에 쓸 데이터입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램의 기본 레지스트리 키에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

*LpszEntry* 로 지정 된 키가 없는 경우이 메서드는 해당 키를 만듭니다.

##  <a name="writesectionobject"></a>CWinAppEx:: WriteSectionObject

[CObject 클래스](../../mfc/reference/cobject-class.md) 에서 파생 된 데이터를 특정 레지스트리 값에 씁니다.

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 설정할 값의 이름을 포함 하는 문자열입니다.

*obj*<br/>
진행 저장할 데이터입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase)메서드를 각각 사용 합니다.

*LpszEntry* 에 지정 된 값이 *lpszSubSection*로 지정 된 레지스트리 키 아래에 없으면이 메서드는 해당 값을 만듭니다.

##  <a name="writesectionstring"></a>CWinAppEx:: WriteSectionString

레지스트리의 값에 문자열 데이터를 씁니다.

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>매개 변수

*lpszSubSection*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*lpszEntry*<br/>
진행 설정할 값이 포함 된 문자열입니다.

*lpszValue*<br/>
진행 레지스트리에 쓸 문자열 데이터입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszSubSection* 매개 변수는 레지스트리 항목의 절대 경로가 아닙니다. 응용 프로그램에 대 한 기본 레지스트리 키의 끝에 추가 되는 상대 경로입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase)메서드를 각각 사용 합니다.

*LpszEntry* 에 지정 된 값이 *lpszSubSection*아래에 없으면이 메서드는 해당 값을 만듭니다.

##  <a name="writestring"></a>CWinAppEx:: WriteString

레지스트리에 문자열 데이터를 씁니다.

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>매개 변수

*lpszEntry*<br/>
진행 레지스트리 키의 이름을 포함 하는 문자열입니다.

*lpszValue*<br/>
진행 저장할 데이터입니다.

### <a name="return-value"></a>Return Value

이 메서드가 성공 하면 TRUE이 고, 그렇지 않으면입니다. 그렇지 않으면 FALSE입니다.

### <a name="remarks"></a>설명

*LpszEntry* 매개 변수는 응용 프로그램의 기본 레지스트리 키 아래에 있는 레지스트리 항목의 이름입니다. 기본 레지스트리 키를 가져오거나 설정 하려면 [CWinAppEx:: GetRegistryBase](#getregistrybase) 및 [CWinAppEx:: SetRegistryBase](#setregistrybase) 메서드를 각각 사용 합니다.

*Lspzentry* 에 지정 된 키가 없는 경우이 메서드는 해당 키를 만듭니다.

## <a name="see-also"></a>참고 항목

[계층 구조 차트](../../mfc/hierarchy-chart.md)<br/>
[클래스](../../mfc/reference/mfc-classes.md)<br/>
[CWinApp 클래스](../../mfc/reference/cwinapp-class.md)<br/>
[CMouseManager 클래스](../../mfc/reference/cmousemanager-class.md)<br/>
[CContextMenuManager 클래스](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[CKeyboardManager 클래스](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[CUserToolsManager 클래스](../../mfc/reference/cusertoolsmanager-class.md)
