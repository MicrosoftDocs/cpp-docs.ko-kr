---
title: 1.3 실행 모델 | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: c284563a47d21abc9a1dacf045238449d64205d5
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/19/2018
ms.locfileid: "46394012"
---
# <a name="13-execution-model"></a>1.3 실행 모델

OpenMP는 병렬 실행 분기-조인 모델을 사용합니다. 이 분기-조인 모델 하는 다양 한 문제를 해결 하는 데 유용 하지만 다소 맞게에 큰 배열 기반 응용 프로그램에 대 한 조정 됩니다. OpenMP 지원 프로그램을 실행 하는 올바르게 모두 병렬 프로그램 (다중 스레드 방식의 실행 및 전체 OpenMP 지원 라이브러리)으로 무시 하는 지시문과 간단한 OpenMP 스텁 라이브러리를 순차 프로그램으로 것입니다. 그러나 가능 하 고 순차적으로 실행 하는 경우 제대로 작동 하지 않습니다 하는 프로그램을 개발할 수 있습니다. 또한 다양 한 병렬 처리의 수치 연산 연결의 변경으로 인해 다른 숫자 결과 발생할 수 있습니다. 예를 들어, 직렬 추가 감소 추가 연결을 위한 병렬 영역 감소 보다 패턴이 있을 수 있습니다. 이러한 다양 한 연관성 부동 소수점 더하기의 결과 변경할 수 있습니다.

OpenMP C/c + + API를 사용 하 여 작성 된 프로그램 실행 이라는 단일 스레드로 실행을 시작 합니다 *스레드를 마스터*합니다. 마스터 스레드는 첫 번째 병렬 구문에 나올 때까지 직렬 지역에서 실행 합니다. OpenMP C/c + + API에는 **병렬** 지시문에는 병렬 구문 구성 합니다. 병렬 구문 발생 하면 마스터 스레드가 스레드 팀을 만든 하 고 마스터는 팀의 마스터 됩니다. 팀에서 각 스레드에 작업 공유 생성자를 제외 하 고 병렬 영역의 동적 범위에서 문을 실행 합니다. 작업 공유 구문 동일한 순서로 팀의 모든 스레드에서 발생 해야 합니다 및 스레드 중 하나 이상을에서 연결된 된 구조화 된 블록 내에서 문을 실행 합니다. 작업 공유 구문 없이 끝 묵시적 장벽은 `nowait` 절이 팀의 모든 스레드에 의해 실행 됩니다.

스레드는 공유 개체를 수정 하는 경우 실행 환경 뿐만 아니라 프로그램의 다른 스레드에 달라 집니다. 수정은 완료 되기를 다음 시퀀스 위치에서 다른 스레드, 중의 관점에서 (에 정의 된 기본 언어) 개체는 volatile 일에 선언 된 경우에 보장 됩니다. 수정 후 먼저 수정 스레드에서 완료 되도록 보장 됩니다이 고, 그렇지 및 다음 (또는 동시에) 다른 스레드에 발생을 **플러시** (암시적 또는 명시적) 개체를 지정 하는 지시문입니다. 경우는 **플러시** 다른 OpenMP 지시문에 의해 포함 되는 지시문은 부작용의 원하는 순서를 확인 하는 데 충분 하지 않습니다, 추가, 명시적 제공 해야 하는 프로그래머의  **플러시** 지시문입니다.

병렬 구문의 완료 되 면 팀의 스레드는 암시적 장벽에 동기화 하 고 마스터 스레드만 실행을 계속 합니다. 한 프로그램에서 임의 개수의 병렬 구문 지정할 수 있습니다. 결과적으로, 프로그램 분기 및 실행 하는 동안 여러 번 조인 수 있습니다.

OpenMP C/c + + API 프로그래머가 병렬 구문 내에서 호출 된 함수에서 지시문을 사용할 수 있습니다. 어휘 범위의 병렬 구문에 표시 되지 않지만 동적 범위 내에서 식별할 수 있습니다 하는 지시문 이라고 *분리 된* 지시문입니다. 분리 된 지시문 프로그래머가 프로그램의 주요 부분 순차적 프로그램에 최소한의 변경 내용으로 병렬로 실행 하는 기능을 제공 합니다. 이 기능을 사용 하 여 사용자가 프로그램 호출 트리의 상위 수준에서 병렬 코드 하 고 지시문을 사용 하 여 호출된 된 함수 중 하나에서 실행을 제어할 수 있습니다.

C 및 c + +에 대 한 동기화 되지 않은 호출 출력 동일한 파일에 쓰는 함수는 비결 정적 순서에 다른 스레드에 의해 기록 된 데이터 표시 되는 출력에서 발생할 수 있습니다. 마찬가지로, 동일한 파일에서 읽는 함수에는 입력에 대 한 동기화 되지 않은 호출 확정적이 지 않은 순서로 데이터를 읽을 수 있습니다. I/o 동기화 되지 않은 사용 하 여 다른 파일에 액세스 하는 각 스레드는 I/O 함수는 직렬 실행 동일한 결과 생성 합니다.