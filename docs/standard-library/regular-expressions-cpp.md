---
title: 정규식(C++) | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.reviewer: ''
ms.suite: ''
ms.technology:
- cpp-standard-libraries
ms.tgt_pltfrm: ''
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- Visual C++, regular expressions
- regular expressions, Visual C++
- regular expressions
ms.assetid: aafe202a-1d96-4b36-a270-d676dfd3c51c
caps.latest.revision: 12
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: cf33b5be2556108f3caa2182bfcc5b5035b3a51e
ms.sourcegitcommit: 770f6c4a57200aaa9e8ac6e08a3631a4b4bdca05
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/16/2018
---
# <a name="regular-expressions-c"></a>정규식(C++)
C + + 표준 라이브러리는 여러 정규식 문법 지원합니다. 이 항목에서는 정규식을 사용 하는 경우 문법 변형을 사용할 수 있는 설명입니다.  
  
##  <a name="regexgrammar"></a> 정규식 문법  
정규식 문법 사용 하 여 지정 중 하나를 사용 하 여는 `std::regex_constants::syntax_option_type` 열거형 값입니다. 이러한 정규식 문법 std::regex_constants에서 정의 됩니다.

-   `ECMAScript`:이 옵션은 JavaScript와.NET 언어에서 사용 하는 문법에 가장 가깝습니다.
-   `basic`: POSIX 기본 정규식 또는 BRE 합니다.
-   `extended`: POSIX 정규식 이나 ERE 확장입니다.
-   `awk`:이 `extended`, 하지만 인쇄 되지 않는 문자에 대 한 추가 이스케이프 합니다.
-   `grep`:이 `basic`를 사용 하면 수도 줄 바꿈 ('\n') 문자를 구분할 합니다.
-   `egrep`:이 `extended`, 없지만 줄 바꿈 문자를 구분할 수 있습니다.

기본적으로 없는 문법 지정 된 경우 `ECMAScript` 것으로 간주 됩니다. 문법 하나만 지정할 수 있습니다.  
  
문법, 외에도 여러 플래그를 적용할 수 있습니다.  
-   `icase`: 비교 시 대/소문자를 무시 합니다.  
-   `nosubs`:-표시 된 일치 항목 (즉, 괄호로 묶인 식);를 무시 하는 중 없음 대체 저장 됩니다.  
-   `optimize`:으로 큰 생성 시에 일치 하는 보다 빠르게 확인 합니다.  
-   `collate`: 로캘 구분 데이터 정렬 순서 (예: "[a-z]" 형식의 범위)를 사용 합니다.  
  
0 개 또는 그 이상의 플래그 정규식 엔진 동작을 지정 하는 문법을 연계할 수 있습니다. 플래그 지정 `ECMAScript` 문법 라고 가정 합니다.

### <a name="element"></a>요소  
 요소는 다음 중 하나가 될 수 있습니다.  
  
-   대상 시퀀스에서 동일한 문자와 일치하는 *일반 문자*.  
  
-   줄 바꿈을 제외하고 대상 시퀀스에서 문자와 일치하는 *와일드카드* '.'  
  
-   `expr` 식으로 정의된 집합에도 있는 대상 시퀀스의 문자 또는 데이터 정렬 요소와 일치하는 "[`expr`]" 형식 또는 `expr` 식으로 정의된 집합에 없는 대상 시퀀스의 문자 또는 데이터 정렬 요소와 일치하는 "[^`expr`]" 형식의 *대괄호 식*.  
  
     `expr` 식은 다음의 조합을 포함할 수 있습니다.  
  
    -   개별 문자. `expr`로 정의된 집합에 해당 문자를 추가합니다.  
  
    -   "`ch1`-`ch2`" 형식의 *문자 범위*. 닫힌 범위 [`ch1`, `ch2`]의 값으로 표현된 문자를 `expr`로 정의된 집합에 추가합니다.  
  
    -   "[:`name`:]" 형식의 *문자 클래스*. 명명된 클래스의 문자를 `expr`로 정의된 집합에 추가합니다.  
  
    -   "[=`elt`=]" 형식의 *동등 클래스*. `elt`와 동급의 데이터 정렬 요소를 `expr`로 정의된 집합에 추가합니다.  
  
    -   "[.`elt`.]" 형식의 *데이터 정렬 기호*. `elt`로 정의된 집합에 데이터 정렬 요소 `expr`를 추가합니다.  
  
-   *앵커*. '^' 앵커는 대상 시퀀스의 시작과 일치합니다. '$' 앵커는 대상 시퀀스의 끝과 일치합니다.  
  
 구분 기호 간 패턴이 일치하는 대상 시퀀스에서 문자 시퀀스와 일치하는 "(*하위 식*)" 형식 또는 `basic` 및 `grep`의 "\\(*하위 식*\\)"의 *캡처 그룹*.  
  
-   대상 시퀀스에서 `k` 문자와 일치하는 "\\`k`" 형식의 *ID 이스케이프*.  
  
 예를 들면 다음과 같습니다.  
  
-   "a"는 대상 시퀀스 "a"와 일치하지만 대상 시퀀스 "B", "b" 또는 "c"와 일치하지 않습니다.  
  
-   "."는 대상 시퀀스 "a", "B", "b", "c"와 모두 일치합니다.  
  
-   "[b-z]"는 대상 시퀀스 "b", "c"와 일치하지만 대상 시퀀스 "a" 또는 "B"와 일치하지 않습니다.  
  
-   "[:lower:]"는 대상 시퀀스 "a", "b", "c"와 일치하지만 대상 시퀀스 "B"와 일치하지 않습니다.  
  
-   "(a)"는 대상 시퀀스 "a"와 일치하고 캡처 그룹 1을 하위 시퀀스 "a"에 연결하지만, 대상 시퀀스 "B", "b", "c"와 일치하지 않습니다.  
  
 `ECMAScript`, `basic`, `grep`에서 요소는 "\\`dd`" 형식의 *역참조*도 될 수 있습니다. 여기서 `dd`는 N번째 *캡처 그룹*과 일치하는 문자 시퀀스와 동일한 대상 시퀀스 내 문자 시퀀스와 일치하는 십진수 값 N을 나타냅니다. 예를 들어, "(a)\1"는 대상 시퀀스 "aa"와 일치합니다. 그 이유는 첫 번째이자 유일한 캡처 그룹이 초기 시퀀스인 "a"와 일치하고 \1이 마지막 시퀀스인 "a"와 일치하기 때문입니다.  
  
 `ECMAScript`에서 요소는 다음 중 하나가 될 수도 있습니다.  
  
-   A *비캡처 그룹* 양식의 "(?: *subexpression* )"입니다. 대상 시퀀스에서 구분 기호 간 패턴과 일치하는 문자 시퀀스와 일치합니다.  
  
-   "\f", "\n", "\r", "\t" 또는 "\v" 형식의 제한된 *파일 형식 이스케이프*. 대상 시퀀스에서 각각 폼 피드, 줄 바꿈, 캐리지 리턴, 가로 탭, 수직 탭과 일치합니다.  
  
-   "(=*하위 식*)" 형식의 *긍정 어설션*. 구분 기호 간 패턴이 일치하는 대상 시퀀스 내 문자 시퀀스와 일치하지만 대상 시퀀스에서 일치 위치는 변경되지 않습니다.  
  
-   형식 "(!*하위 식* )"의 *부정 어설션* 구분 기호 간 패턴이 일치하지 않는 대상 시퀀스 내 모든 문자 시퀀스와 일치하며 대상 시퀀스에서 일치 위치를 변경하지 않습니다.  
  
-   "\x`hh`" 형식의 *16진수 이스케이프 시퀀스*. 대상 시퀀스에서 두 자릿수 16진수 `hh`로 표현된 문자와 일치합니다.  
  
-   "\u`hhhh`" 형식의 *유니코드 이스케이프 시퀀스*. 대상 시퀀스에서 네 자릿수 16진수 `hhhh`로 표현된 문자와 일치합니다.  
  
-   "\c`k`" 형식의 *컨트롤 이스케이프 시퀀스*. 문자 `k`라는 이름의 컨트롤 문자와 일치합니다.  
  
-   "\b" 형식의 *단어 경계 어설션*. 대상 시퀀스에서 현재 위치가 *단어 경계* 바로 다음일 경우 일치합니다.  
  
-   "\B" 형식의 *부정 단어 경계 어설션*. 대상 시퀀스에서 현재 위치가 *단어 경계* 바로 다음이 아닐 경우 일치합니다.  
  
-   "\d", "\D", "\s", "\S", "\w", "\W" 형식의 *dsw 문자 이스케이프*. 문자 클래스의 약식 이름을 제공합니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "(?:a)"는 대상 시퀀스 "a"와 일치하지만 캡처 그룹 1이 없으므로 "(?:a)\1"가 잘못되었습니다.  
  
-   "(=a)a"는 대상 시퀀스 "a"와 일치합니다. 긍정 어설션은 대상 시퀀스의 초기 시퀀스인 "a"와 일치하고 정규식의 마지막 "a"는 대상 시퀀스의 초기 시퀀스인 "a"와 일치합니다.  
  
-   "(!a)a"는 대상 시퀀스 "a"와 일치하지 않습니다.  
  
-   "a\b."는 대상 시퀀스 "a~"와 일치하지만 대상 시퀀스 "ab"와는 일치하지 않습니다.  
  
-   "a\B."는 대상 시퀀스 "ab"와 일치하지만 대상 시퀀스 "a~"와는 일치하지 않습니다.  
  
 `awk`에서 요소는 다음 중 하나가 될 수도 있습니다.  
  
-   "\\\\", "\a", "\b", "\f", "\n", "\r", "\t", or "\v" 형식의 제한된 *파일 형식 이스케이프*. 대상 시퀀스에서 각각 백슬래시, 경고, 백스페이스, 폼 피드, 줄 바꿈, 캐리지 리턴, 가로 탭, 수직 탭과 일치합니다.  
  
-   "\\`ooo`" 형식의 *8진수 이스케이프 시퀀스*. 대상 시퀀스에서 표현이 한 자리, 두 자리 또는 세 자리 8진수 `ooo`로 표현된 값인 문자와 일치합니다.  
  
### <a name="repetition"></a>반복  
 *긍정 어설션*, *부정 어설션* 또는 *앵커* 이외의 모든 요소 다음에 반복 횟수가 올 수 있습니다. 가장 일반적인 유형의 반복 횟수는 `basic` 및 `grep`의 "\\{`min`,`max`\\}" 또는 "{`min`,`max`}" 형태입니다. 이러한 형태의 반복 횟수 앞에 오는 요소는 해당 요소와 일치하는 시퀀스가 연속적으로 `min`개 이상, `max`개 이하일 경우 일치합니다. 예를 들어, "a{2,3}"은 대상 시퀀스 "aa" 및 대상 시퀀스 "aaa"와 일치하지만 대상 시퀀스 "a" 또는 대상 시퀀스 "aaaa"와는 일치하지 않습니다.  
  
 또한 반복 횟수는 다음 형식 중 하나를 사용할 수 있습니다.  
  
-   `basic` 및 `grep`의 "\\{`min`\\}" 또는 "{`min`}". "{`min`,`min`}"와 같습니다.  
  
-   `basic` 및 `grep`의 "\\{`min`,\\}" 또는 "{`min`,}". "{`min`,unbounded}"와 같습니다.  
  
-   "*". "{0,unbounded}"와 같습니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "a{2}"는 대상 시퀀스 "aa"와 일치하지만 대상 시퀀스 "a" 또는 대상 시퀀스 "aaa"와는 일치하지 않습니다.  
  
-   "a{2,}"는 대상 시퀀스 "aa", 대상 시퀀스 "aaa" 등과 일치하지만 대상 시퀀스 "a"와는 일치하지 않습니다.  
  
-   "a*"는 대상 시퀀스 "", 대상 시퀀스 "a", 대상 시퀀스 "aa" 등과 일치합니다.  
  
 `basic` 및 `grep`를 제외한 모든 문법의 경우 반복 횟수는 다음 중 하나의 형식이 될 수도 있습니다.  
  
-   "?". "{0,1}"과 같습니다.  
  
-   "+". "{1,unbounded}"와 같습니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "a?" 일치 하는 대상 시퀀스 "" 및 대상 시퀀스 "a" 하지만 대상 시퀀스 "aa" 하지 않습니다.  
  
-   "a+"는 대상 시퀀스 "a", 대상 시퀀스 "aa" 등과 일치하지만 대상 시퀀스 ""와는 일치하지 않습니다.  
  
 `ECMAScript`, 모든 형태의 반복 횟수 문자가 올 수 있습니다 '?'를 지정 하는 *non-greedy 반복*합니다.  
  
### <a name="concatenation"></a>연결 연산  
 정규식 요소는 *반복 횟수* 유무와 상관없이 연결하여 긴 정규식을 형성할 수 있습니다. 결과 식은 개별 요소와 일치하는 시퀀스 연결인 대상 시퀀스와 일치합니다. 예를 들어, "a{2,3}b"는 대상 시퀀스 "aab" 및 대상 시퀀스 "aaab"와 일치하지만 대상 시퀀스 "ab" 또는 대상 시퀀스 "aaaab"와는 일치하지 않습니다.  
  
### <a name="alternation"></a>교체  
 `basic` 및 `grep`를 제외한 모든 정규식 문법에서는 연결된 정규식 다음에 문자 '&#124;' 및 다른 연결된 정규식이 올 수 있습니다. 이러한 방식으로 연결된 정규식을 무한히 결합할 수 있습니다. 결과 식은 하나 이상의 연결된 정규식과 일치하는 대상 시퀀스와 일치합니다.  
  
 둘 이상의 연결된 정규식이 대상 시퀀스와 일치할 경우 `ECMAScript`는 일치 항목으로 시퀀스와 일치하는 연결된 정규식 중 첫 번째 정규식을 선택하고(*처음 일치*) 다른 정규식 문법은 *최대 길이 일치*를 달성하는 정규식을 선택합니다. 예를 들어, "ab&#124;cd"는 대상 시퀀스 "ab" 및 대상 시퀀스 "cd"와 일치하지만 대상 시퀀스 "abd" 또는 대상 시퀀스 "acd"와는 일치하지 않습니다.  
  
 `grep` 및 `egrep`에서 줄 바꿈 문자('\n')를 사용하여 교체를 구분할 수 있습니다.  
  
### <a name="subexpression"></a>하위 식  
 `basic` 및 `grep`에서 하위 식은 연결입니다. 다른 정규식 문법에서 하위 식은 교체입니다.  
  
##  <a name="grammarsummary"></a> 문법 요약  
 다음 표에 다양한 정규식 문법에서 사용할 수 있는 기능이 요약되어 있습니다.  
  
|요소|기본|확장|ECMAScript|grep|egrep|awk|  
|-------------|---------|---------|----------|----------|-----------|---------|  
|'&#124;'를 사용하는 교체||+|+||+|+|  
|'\n'을 사용하는 교체||||+|+||  
|앵커|+|+|+|+|+|+|  
|역참조|+||+|+|||  
|대괄호 식|+|+|+|+|+|+|  
|"()"를 사용한 캡처 그룹||+|+||+|+|  
|"\\(\\)"를 사용한 캡처 그룹|+|||+|||  
|컨트롤 이스케이프 시퀀스|||+||||  
|dsw 문자 이스케이프|||+||||  
|파일 형식 이스케이프|||+|||+|  
|16진수 이스케이프 시퀀스|||+||||  
|ID 이스케이프|+|+|+|+|+|+|  
|부정 어설션|||+||||  
|부정 단어 경계 어설션|||+||||  
|비캡처 그룹|||+||||  
|non-greedy 반복|||+||||  
|8진수 이스케이프 시퀀스||||||+|  
|일반 문자|+|+|+|+|+|+|  
|긍정 어설션|||+||||  
|"{}"를 사용한 반복||+|+||+|+|  
|"\\{\\}"를 사용한 반복|+|||+|||  
|"*"를 사용한 반복|+|+|+|+|+|+|  
|'?' 및 '+'를 사용한 반복||+|+||+|+|  
|유니코드 이스케이프 시퀀스(unicode escape sequence)|||+||||  
|와일드카드 문자|+|+|+|+|+|+|  
|단어 경계 어설션(word boundary assert)|||+||||  
  
##  <a name="semanticdetails"></a> 의미 정보  
  
### <a name="anchor"></a>앵커  
 앵커는 대상 문자열에서 문자가 아닌 위치와 일치합니다. '^'는 대상 문자열의 시작과 일치하며 '$' 앵커는 대상 문자열의 끝과 일치합니다.  
  
### <a name="back-reference"></a>역참조  
 역참조는 백슬래시 뒤에 10진수 값 N이 붙는 형식이며, N번째 *캡처 그룹*의 내용과 일치합니다. N 값은 역참조 앞의 캡처 그룹 수보다 많을 수 없습니다. `basic` 및 `grep`에서 N 값은 백슬래시 다음의 10진수에 의해 결정됩니다. `ECMAScript`에서 N 값은 백슬래시 바로 다음의 모든 10진수에 의해 결정됩니다. 따라서 `basic` 및 `grep`에서 정규식의 캡처 그룹이 9개를 초과하는 경우에도 N 값은 절대 9를 초과하지 않습니다. `ECMAScript`에서 N 값은 제한이 없습니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "((a+)(b+))(c+)\3"은 대상 시퀀스 "aabbbcbbb"와 일치합니다. 역참조 "\3"은 세 번째 캡처 그룹, 즉, "(b+)"와 일치합니다. 대상 시퀀스 "aabbbcbb"와 일치하지 않습니다.  
  
-   "(a)\2"는 올바르지 않습니다.  
  
-   "(b(((((((((a))))))))))\10"은 `basic`와 `ECMAScript`에서 의미가 다릅니다. `basic`에서 역참조는 "\1"입니다. 역참조는 첫 번째 캡처 그룹의 내용(즉, "(b"로 시작하고 마지막 ")"로 끝나며 역참조 앞에 오는 내용)과 일치하고, 마지막 '0'은 일반 문자 '0'과 일치합니다. `ECMAScript`에서 역참조는 "\10"입니다. 10번째 캡처 그룹, 즉 가장 안쪽의 캡처 그룹과 일치합니다.  
  
### <a name="bracket-expression"></a>대괄호 식  
 대괄호 식은 문자 집합 및 *데이터 정렬 요소*를 정의합니다. 대괄호 식이 '^' 문자로 시작할 경우 집합의 요소가 대상 시퀀스의 현재 문자와 전혀 일치하지 않으면 일치가 성공합니다. 그렇지 않을 경우, 집합의 요소 하나라도 대상 시퀀스의 현재 문자와 일치하면 일치가 성공합니다.  
  
 문자 집합은 *개별 요소*, *문자 범위*, *문자 클래스*, *동등 클래스* 및 *데이터 정렬 기호*를 임의로 결합하여 정의할 수 있습니다.  
  
### <a name="capture-group"></a>캡처 그룹  
 캡처 그룹은 정규식 문법에서 내용을 단일 단위로 표시하며 내용과 일치하는 대상 텍스트에 레이블을 지정합니다. 각 캡처 그룹과 연결된 레이블은 캡처 그룹을 표시하는 여는 괄호와 현재 캡처 그룹을 표시하는 여는 괄호까지 포함해 계산하여 결정되는 숫자입니다. 이 구현에서 캡처 그룹의 최대 수는 31입니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "ab+"는 대상 시퀀스 "abb"와 일치하지만 대상 시퀀스 "abab"와 일치하지 않습니다.  
  
-   "(ab)+"는 대상 시퀀스 "abb"와 일치하지 않지만 대상 시퀀스 "abab"와 일치합니다.  
  
-   "((a+)(b+))(c+)"는 대상 시퀀스 "aabbbc"와 일치하고, 캡처 그룹 1을 하위 시퀀스 "aabbb"와 연결하며, 캡처 그룹 2를 하위 시퀀스 "aa"와 연결하고, 캡처 그룹 3을 "bbb"와 연결하며, 캡처 그룹 4를 하위 시퀀스 "c"와 연결합니다.  
  
### <a name="character-class"></a>문자 클래스  
 대괄호 식의 문자 클래스는 명명된 클래스의 모든 문자를 대괄호 식으로 정의된 문자 집합에 추가합니다. 문자 클래스를 만들려면 "[:" 클래스 이름 ":]"를 사용합니다. 내부적으로 문자 클래스의 이름은 `id = traits.lookup_classname`을 호출하여 인식됩니다. `ch`에서 true를 반환할 경우 문자 `traits.isctype(ch, id)`는 해당 클래스에 속합니다. 기본 `regex_traits` 템플릿은 다음 표의 클래스 이름을 지원합니다.  
  
|클래스 이름|설명|  
|----------------|-----------------|  
|"alnum"|소문자, 대문자 및 숫자|  
|"alpha"|소문자 및 대문자|  
|"blank"|공백 또는 탭|  
|"cntrl"|*파일 서식 이스케이프* 문자|  
|"digit"|digits|  
|"graph"|소문자, 대문자, 숫자 및 문장 부호|  
|"lower"|소문자|  
|"print"|소문자, 대문자, 숫자, 문장 부호 및 공백|  
|"punct"|문장 부호|  
|"space"|space|  
|"upper|대문자|  
|"xdigit"|숫자, 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'|  
|"d"|digit과 동일|  
|"s"|space와 동일|  
|"w"|alnum과 동일|  
  
### <a name="character-range"></a>문자 범위  
 대괄호 식의 문자 범위는 범위의 모든 문자를 대괄호 식으로 정의된 문자 집합에 추가합니다. 문자 범위를 만들려면 범위의 첫 번째 및 마지막 문자 사이에 '-' 문자를 추가합니다. 그러면 첫 번째 문자의 숫자 값보다 크거나 같은 숫자 값을 가진 모든 문자와 마지막 문자의 숫자 값보다 작거나 같은 모든 문자가 집합에 추가됩니다. 이 추가된 문자 집합은 플랫폼별 문자 표현에 따라 달라집니다. '-' 문자가 대괄호 식의 시작 또는 끝에서 발생하거나 문자 범위의 첫 번째 또는 마지막 문자일 경우 그 자체를 나타냅니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "[0-7]"은 문자 집합 { '0', '1', '2', '3', '4', '5', '6', '7' }을 나타냅니다. 대상 시퀀스 "0", "1" 등과 일치하지만 "a"와는 일치하지 않습니다.  
  
-   ASCII 문자 인코딩을 사용하는 시스템에서 "[h-k]"는 문자 집합 { 'h', 'i', 'j', 'k' }를 나타냅니다. 대상 시퀀스 "h", "i" 등과 일치하지만 "\x8A" 또는 "0"과는 일치하지 않습니다.  
  
-   EBCDIC 문자 인코딩을 사용하는 시스템에서 "[h-k]"는 문자 집합 { 'h', 'i', '\x8A', '\x8B', '\x8C', '\x8D', '\x8E', '\x8F', '\x90', 'j', 'k' }를 나타냅니다('h'는 0x88로 인코딩되며 'k'는 0x92로 인코딩됨). 대상 시퀀스 "h", "i", "\x8A" 등과 일치하지만 "0"과는 일치하지 않습니다.  
  
-   "[-0-24]"는 문자 집합 { '-', '0', '1', '2', '4' }를 나타냅니다.  
  
-   "[0-2-]"는 문자 집합 { '0', '1', '2', '-' }를 나타냅니다.  
  
-   ASCII 문자 인코딩을 사용하는 시스템에서 "[+--]"는 문자 집합 { '+', ',', '-' }를 나타냅니다.  
  
 하지만 로캘에 민감한 범위를 사용할 경우 범위의 문자는 로캘에 대한 데이터 정렬 규칙으로 결정됩니다. 범위 정의의 첫 번째 문자 다음과 범위 정의의 마지막 문자 앞에서 정렬되는 문자가 집합에 있습니다. 두 개의 끝 문자도 집합에 있습니다.  
  
### <a name="collating-element"></a>데이터 정렬 요소  
 데이터 정렬 요소는 단일 문자로 취급되는 복수 문자 시퀀스입니다.  
  
### <a name="collating-symbol"></a>데이터 정렬 기호  
 대괄호 식의 데이터 정렬 기호는 대괄호 식으로 정의된 집합에 *데이터 정렬 요소*를 추가합니다. 데이터 정렬 기호를 만들려면 "[." 뒤에 데이터 정렬 요소와 ".]"를 차례로 붙입니다.  
  
### <a name="control-escape-sequence"></a>컨트롤 이스케이프 시퀀스  
 컨트롤 이스케이프 시퀀스는 백슬래시, 문자 'c', 'a' - 'z' 또는 'A' - 'Z' 문자 중 하나의 순서로 구성됩니다. 해당 문자로 이름이 지정되는 ASCII 컨트롤 문자와 일치합니다. 예를 들어 \<ctrl-i>에는 0x09 값이 있으므로 "\ci"는 대상 시퀀스 "\x09"와 일치합니다.  
  
### <a name="dsw-character-escape"></a>DSW 문자 이스케이프  
 dsw 문자 이스케이프는 다음 표와 같이 문자 클래스에 대한 짧은 이름입니다.  
  
|이스케이프 시퀀스|동일한 명명 클래스|기본 명명 클래스|  
|---------------------|----------------------------|-------------------------|  
|"\d"|"[[:d:]]"|"[[:digit:]]"|  
|"\D"|"[^[:d:]]"|"[^[:digit:]]"|  
|"\s"|"[[:s:]]"|"[[:space:]]"|  
|"\S"|"[^[:s:]]"|"[^[:space:]]"|  
|"\w"|"[[:w:]]"|"[a-zA-Z0-9_]"*|  
|"\W"|"[^[:w:]]"|"[^a-zA-Z0-9_]"*|  
  
 *ASCII 문자 집합  
  
### <a name="equivalence-class"></a>동급 클래스  
 대괄호 식의 동등 클래스는 동급 클래스 정의의 데이터 정렬 요소와 동일한 모든 문자와 *데이터 정렬 요소*를 대괄호 식으로 정의된 집합에 추가합니다. 동급 클래스를 만들려면 "[=" 데이터 정렬 요소 "=]"를 사용합니다. `elt1`일 경우, 내부적으로 두 개의 데이터 정렬 요소 `elt2` 및 `traits.transform_primary(elt1.begin(), elt1.end()) == traits.transform_primary(elt2.begin(), elt2.end())`는 동일합니다.  
  
### <a name="file-format-escape"></a>파일 형식 이스케이프  
 파일 형식 이스케이프는 일반 C 언어 문자 이스케이프 시퀀스인 "\\\\", "\a", "\b", "\f", "\n", "\r", "\t", "\v"로 구성되어 있습니다. 각각은 백슬래시, 경고, 백스페이스, 폼 피드, 줄 바꿈, 캐리지 리턴, 가로 탭, 세로 탭의 일반적인 의미가 있습니다. `ECMAScript`에서 "\a" 및 "\b"는 허용되지 않습니다. ("\\\\"는 허용되지만 ID 이스케이프이며, 파일 포맷 이스케이프가 아닙니다.)  
  
### <a name="hexadecimal-escape-sequence"></a>16진수 이스케이프 시퀀스  
 16진수 이스케이프 시퀀스는 백슬래시, 문자 'x', 두 개의 16진수 숫자(0-9a-fA-F)의 순서로 구성됩니다. 이는 2자리로 지정된 값을 갖는 대상 시퀀스의 문자와 일치합니다. 예를 들어, ASCII 문자 인코딩을 사용할 경우 "\x41"은 대상 시퀀스 "A"와 일치합니다.  
  
### <a name="identity-escape"></a>ID 이스케이프  
 ID 이스케이프는 백슬래시와 단일 문자의 순서로 구성되어 있습니다. 해당 문자와 일치합니다. 문자에 특별한 의미가 있을 경우 필요합니다. ID 이스케이프를 사용할 경우 특별한 의미는 제거됩니다. 예를 들어:  
  
-   "는\*"는 대상 시퀀스 "aaa"와 일치 하지만 대상 시퀀스와 일치 하지 않습니다 "는\*"입니다.  
  
-   "는\\\*"는 대상 시퀀스와 일치 하지만 대상 시퀀스 "aaa"와 일치 하지 않습니다 "는\*"입니다.  
  
 ID 이스케이프에 허용되는 문자 집합은 다음 표와 같이 정규식 문법에 따라 다릅니다.  
  
|문법|ID 이스케이프 문자에 허용됩니다.|  
|-------------|----------------------------------------|  
|`basic`, `grep`|{ '(', ')', '{', '}', '.', '[', '\\', '\*', '^', '$' }|  
|`extended`, `egrep`|{ '(', ')', '{', '.', '[', '\\', '\*', '^', '$', '+', '?', '&#124;' }|  
|`awk`|`extended` 더하기 { '"', '/' }|  
|`ECMAScript`|식별자에 포함될 수 있는 문자를 제외한 모든 문자. 일반적으로 여기에 문자, 숫자, '$', '\_', 유니코드 이스케이프 시퀀스입니다. 자세한 내용은 ECMAScript 언어 사양을 참조하십시오.|  
  
### <a name="individual-character"></a>개별 문자  
 대괄호 식의 개별 문자는 해당 문자를 대괄호 식으로 정의된 문자 집합에 추가합니다. 시작 부분을 제외하고 대괄호 식의 모든 위치에서 '^'는 그 자체를 나타냅니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "[abc]"는 대상 시퀀스 "a", "b" 및 "c"와 일치하지만 시퀀스 "d"와는 일치하지 않습니다.  
  
-   "[^abc]"는 대상 시퀀스 "d"와 일치하지만 대상 시퀀스 "a", "b" 또는 "c"와는 일치하지 않습니다.  
  
-   "[a^bc]"는 대상 시퀀스 "a", "b", "c" 및 "^"와 일치하지만 대상 시퀀스 "d"와는 일치하지 않습니다.  
  
 `ECMAScript`를 제외한 모든 정규식 문법에서 ']'가 여는 '[' 다음의 첫 번째 문자이거나 최초 '^' 다음의 첫 번째 문자일 경우 그 자체를 나타냅니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "[]a"는 대괄호 식을 닫는 ']'가 없기 때문에 올바르지 않습니다.  
  
-   "[]abc]"는 대상 시퀀스 "a", "b", "c" 및 "]"와 일치하지만 대상 시퀀스 "d"와는 일치하지 않습니다.  
  
-   "[^]abc]"는 대상 시퀀스 "d"와는 일치하지만 대상 시퀀스 "a", "b", "c" 또는 "]"와는 일치하지 않습니다.  
  
 `ECMAScript`에서는 대괄호 식에서 '\\]'를 사용하여 문자 ']'를 나타냅니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "[]a"는 대괄호 식이 비어 있으므로 대상 시퀀스 "a"와 일치합니다.  
  
-   "[\\]abc]"는 대상 시퀀스 "a", "b", "c" 및 "]"와 일치하지만 대상 시퀀스 "d"와는 일치하지 않습니다.  
  
### <a name="negative-assert"></a>부정 어설션  
 부정 어설션은 해당 내용 이외의 모든 항목과 일치합니다. 대상 시퀀스의 문자는 사용하지 않습니다. 예를 들어, "(!aa)(a*)"는 대상 시퀀스 "a"와 일치하고 캡처 그룹 1을 하위 시퀀스 "a"와 연결합니다. 대상 시퀀스 "aa" 또는 대상 시퀀스 "aaa"와는 일치하지 않습니다.  
  
### <a name="negative-word-boundary-assert"></a>부정 단어 경계 어설션  
 대상 문자열에서 현재 위치가 *단어 경계* 바로 다음에 없을 경우 일치하는 부정 단어 경계 어설션입니다.  
  
### <a name="non-capture-group"></a>비캡처 그룹  
 비캡처 그룹은 정규식 문법에서 내용을 단일 단위로 표시하지만 대상 텍스트에 레이블을 지정하지 않습니다. 예를 들어, "(a)(?:b)\*(c)" 대상 텍스트 "abbc"와 일치 하 고 캡처 그룹 1을 하위 시퀀스 연결 "는"고 캡처 그룹 2를 하위 시퀀스 "c"입니다.  
  
### <a name="non-greedy-repetition"></a>non-greedy 반복  
 non-greedy 반복은 패턴과 일치하는 대상 시퀀스의 가장 짧은 하위 시퀀스를 사용합니다. greedy 반복은 가장 긴 항목을 사용합니다. 예를 들어 "(a+) (한\*b)"는 대상 시퀀스 "aaab"와 일치 합니다. non-greedy 반복을 사용할 경우 캡처 그룹 1을 대상 시퀀스의 시작 부분에 있는 시퀀스 "a"와 연결하고 캡처 그룹 2를 대상 시퀀스의 끝에 있는 시퀀스 "aab"와 연결합니다. greedy 일치를 사용할 경우 캡처 그룹 1을 하위 시퀀스 "aaa"와 연결하고 캡처 그룹 2를 하위 시퀀스 "b"와 연결합니다.  
  
### <a name="octal-escape-sequence"></a>8진수 이스케이프 시퀀스  
 8진수 이스케이프 시퀀스는 백슬래시와 한 자리, 두 자리 또는 세 자리 8진수(0-7)로 구성됩니다. 이러한 자릿수로 지정된 값을 갖는 대상 시퀀스의 문자와 일치합니다. 모든 숫자가 '0'인 경우 시퀀스가 잘못된 것입니다. 예를 들어, ASCII 문자 인코딩을 사용할 경우 "\101"은 대상 시퀀스 "A"와 일치합니다.  
  
### <a name="ordinary-character"></a>일반 문자  
 일반 문자는 현재 문법에서 특별한 의미가 없지만 유효한 모든 문자입니다.  
  
 `ECMAScript`에서 다음 문자는 특별한 의미가 있습니다.  
  
-   ^  $  \  .  *  +  ?  (  )  [  ]  {  }  &#124;  
  
 `basic` 및 `grep`에서 다음 문자는 특별한 의미가 있습니다.  
  
-   이어야 합니다.   [   \  
  
 또한 `basic` 및 `grep`에서 다음 문자를 특정 컨텍스트에서 사용할 경우 특별한 의미가 있습니다.  
  
-   '\*' 모든 경우에는 정규식에서 첫 번째 문자 또는 초기 뒤에 오는 첫 번째 문자는 경우에만 특별 한 의미가 ' ^'는 정규식에서 또는 첫 번째 문자일 경우은 캡처의 그룹 또는 첫 번째 문자를 최초 ' ^'는 캡처 그룹에 있습니다.  
  
-   '^'는 정규식의 첫 번째 문자일 경우 특별한 의미가 있습니다.  
  
-   '$'는 정규식의 마지막 문자일 경우 특별한 의미가 있습니다.  
  
 `extended`, `egrep` 및 `awk`에서 다음 문자는 특별한 의미가 있습니다.  
  
-   이어야 합니다.   [   \   (   *   +   ?   {   &#124;  
  
 또한 `extended`, `egrep` 및 `awk`에서 다음 문자를 특정 컨텍스트에서 사용할 경우 특별한 의미가 있습니다.  
  
-   ')'는 앞의 '('와 일치할 경우 특별한 의미가 있습니다.  
  
-   '^'는 정규식의 첫 번째 문자일 경우 특별한 의미가 있습니다.  
  
-   '$'는 정규식의 마지막 문자일 경우 특별한 의미가 있습니다.  
  
 대상 시퀀스에서 동일한 문자와 일치하는 일반 문자. 기본적으로 두 문자가 동일한 값으로 표현될 경우 일치가 성공함을 의미합니다. 대/소문자를 구분하는 일치에서 `ch0`일 경우 두 문자 `ch1` 및 `traits.translate_nocase(ch0) == traits.translate_nocase(ch1)`이 일치합니다. 로캘을 구분하는 일치에서 `ch0`일 경우 두 문자 `ch1` 및 `traits.translate(ch0) == traits.translate(ch1)`이 일치합니다.  
  
### <a name="positive-assert"></a>긍정 어설션  
 긍정 어설션은 해당 내용과 일치하지만, 대상 시퀀스의 문자를 사용하지 않습니다.  
  
 예를 들면 다음과 같습니다.  
  
-   "(=aa) (한\*)"는 대상 시퀀스 "aaaa"와 일치 하 고 캡처 그룹 1을 하위 시퀀스 "aaaa"와 연결 합니다.  
  
-   "(aa) (한\*)"는 대상 시퀀스 "aaaa"와 일치 하 고 캡처 그룹 1을 하위 시퀀스 "aa" 시작 부분에서 대상 시퀀스와 캡처 그룹 2 하위 시퀀스 "aa"는 대상 시퀀스의 끝에 연결 합니다.  
  
-   "(=aa)(a)&#124;(a)"는 대상 시퀀스 "a"와 일치하고 캡처 그룹 1을 빈 시퀀스와 연결하며(긍정 어설션이 실패했으므로) 캡처 그룹 2를 하위 시퀀스 "a"와 연결합니다. 또한 대상 시퀀스 "aa"와 일치하고 캡처 그룹 1을 하위 시퀀스 "aa"와 연결하며 캡처 그룹 2를 빈 시퀀스와 연결합니다.  
  
### <a name="unicode-escape-sequence"></a>유니코드 이스케이프 시퀀스  
 유니코드 이스케이프 시퀀스는 백슬래시, 문자 'u', 네 자릿수 16진수 숫자(0-9a-fA-F)의 순서로 구성됩니다. 이는 4자리로 지정된 값을 갖는 대상 시퀀스의 문자와 일치합니다. 예를 들어, ASCII 문자 인코딩을 사용할 경우 "\u0041"은 대상 시퀀스 "A"와 일치합니다.  
  
### <a name="wildcard-character"></a>와일드카드 문자  
 와일드카드 문자는 줄 바꿈을 제외하고 대상 식에서 모든 문자와 일치합니다.  
  
### <a name="word-boundary"></a>단어 경계  
 단어 경계는 다음과 같은 경우에 발생합니다.  
  
-   현재 문자가 대상 시퀀스의 시작 부분에 있고 단어 문자 `A-Za-z0-9_.` 중 하나인 경우  
  
-   현재 문자 위치가 대상 시퀀스의 끝 다음에 있으며 대상 시퀀스의 마지막 문자가 단어 문자 중 하나인 경우.  
  
-   현재 문자가 단어 문자 중 하나이며 앞에 오는 문자는 단어 문자가 아닌 경우.  
  
-   현재 문자가 단어 문자 중 하나가 아니고 앞에 오는 문자는 단어 문자인 경우.  
  
### <a name="word-boundary-assert"></a>단어 경계 어설션  
 대상 문자열에서 현재 위치가 *단어 경계* 바로 다음에 있을 경우 일치하는 단어 경계 어설션입니다.  
  
##  <a name="matchingandsearching"></a> 일치 및 검색  
 대상 시퀀스와 일치하는 정규식의 경우 전체 정규식이 전체 대상 시퀀스와 일치해야 합니다. 예를 들어, 정규식 "bcd"는 대상 시퀀스 "bcd"와 일치하지만 대상 시퀀스 "abcd" 및 대상 시퀀스 "bcde"와는 일치하지 않습니다.  
  
 정규식 검색이 성공하려면 대상 시퀀스에 정규식과 일치하는 하위 시퀀스가 있어야 합니다. 검색은 일반적으로 가장 왼쪽에서 일치하는 하위 시퀀스를 찾습니다.  
  
 예를 들면 다음과 같습니다.  
  
-   대상 시퀀스 "bcd"에서 정규식 "bcd"에 대한 검색이 성공하고 전체 시퀀스와 일치합니다. 대상 시퀀스 "abcd"에서 동일한 검색도 성공하고 마지막 세 문자가 일치합니다. 대상 시퀀스 "bcde"에서 동일한 검색도 성공하고 첫 번째 세 문자가 일치합니다.  
  
-   대상 시퀀스 "bcdbcd"에서 정규식 "bcd"에 대한 검색이 성공하고 첫 번째 세 문자가 일치합니다.  
  
 대상 시퀀스의 동일한 위치에서 일치하는 하위 시퀀스가 둘 이상일 경우 일치하는 패턴을 선택하는 방법은 두 가지입니다. *처음 일치*는 정규식이 일치할 경우 첫 번째로 검색된 하위 시퀀스를 선택합니다. *최대 길이 일치*는 해당 위치에서 일치하는 하위 시퀀스에서 가장 긴 하위 시퀀스를 선택합니다. 최대 길이의 하위 시퀀스가 한 개 이상인 경우 가장 긴 일치는 첫 번째로 발견된 일치 항목을 선택합니다. 예를 들어, 첫 번째 일치를 사용하는 경우 대상 시퀀스 "abcd"에서 정규식 "b&#124;bc"를 검색할 경우 교체의 왼쪽 단어가 해당 하위 시퀀스와 일치하므로 하위 시퀀스 "b"와 일치합니다. 따라서 첫 번째 일치는 대체의 오른쪽 단어를 시도하지 않습니다. 가장 긴 일치를 사용하는 경우 "bc"는 "b"보다 길기 때문에 동일한 검색은 "bc"와 일치합니다.  
  
 일치가 실패하지 않고 대상 시퀀스 끝까지 도달할 경우 정규식 끝까지 도달하지 않더라도 부분 일치가 성공합니다. 따라서 부분 일치가 성공한 다음 대상 시퀀스에 문자를 추가하면 나중에 부분 일치가 실패할 수 있습니다. 하지만 부분 일치가 실패한 이후에 대상 시퀀스에 문자를 추가하면 그 이후의 부분 일치가 성공할 수 없습니다. 예를 들어, 부분 일치에서 "ab"는 대상 시퀀스 "a"와 일치하지만 "ac"와는 일치하지 않습니다.  
  
##  <a name="formatflags"></a> 형식 플래그  
  
|ECMAScript 형식 규칙|sed 형식 규칙|대체 텍스트|  
|-----------------------------|----------------------|----------------------|  
|"$&"|"&"|전체 정규식과 일치하는 문자 시퀀스(`[match[0].first, match[0].second)`)|  
|"$$"||"$"|  
||"\\&"|"&"|  
|"$\`" (달러 기호와 역따옴표)||시퀀스 앞의 정규식과 일치하는 문자 시퀀스(`[match.prefix().first, match.prefix().second)`)|  
|"$'"(달러 기호와 작은따옴표)||시퀀스 다음의 정규식과 일치하는 문자 시퀀스(`[match.suffix().first, match.suffix().second)`)|  
|"$n"|"\n"|위치에서 캡처 그룹과 일치 하는 문자 시퀀스 `n`여기서 `n` 는 0에서 9 사이의 숫자 (`[match[n].first, match[n].second)`)|  
||"\\\n"|"\n"|  
|"$nn"||위치에서 캡처 그룹과 일치 하는 문자 시퀀스 `nn`여기서 `nn` 은 10에서 99 사이의 숫자 (`[match[nn].first, match[nn].second)`)|  
  
## <a name="see-also"></a>참고 항목  
 [C++ 표준 라이브러리 개요](../standard-library/cpp-standard-library-overview.md)

