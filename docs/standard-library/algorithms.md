---
title: 알고리즘
ms.date: 10/18/2018
helpviewer_keywords:
- libraries [C++], C++ algorithm conventions
- algorithms [C++], C++
- C++ Standard Library, algorithms
- algorithm template function C++ library conventions
- conventions [C++], C++ algorithm
ms.assetid: dec9b373-7d5c-46cc-b7d2-21a938ecd0a6
ms.openlocfilehash: a0a1165d731e44568d530e3ed919d73e2a3e8e5e
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62411125"
---
# <a name="algorithms"></a>알고리즘

알고리즘은 C++ 표준 라이브러리의 기본적인 부분입니다. 알고리즘은 컨테이너 자체가 아니라 반복기에서 작동합니다. 따라서 모두는 아니지만 대부분의 C++ 표준 라이브러리 컨테이너에서 동일한 알고리즘을 사용할 수 있습니다. 이 섹션에서는 C++ 표준 라이브러리 알고리즘의 규칙 및 용어를 설명합니다.

## <a name="remarks"></a>설명

알고리즘 템플릿 함수에 대한 설명은 다음과 같은 여러 약어 구를 사용합니다.

- 구 "범위의 \[ *는*를 *B*)"부터 0 개 이상 불연속 값의 시퀀스를 의미 *는* 포함 하지 않고 최대 *B* . 범위가 올바른 경우에만 *B* 에서 연결할 수 *A;* 저장할 수 있습니다 *A* 개체에 *N* (*N*  =  *A*), 개체를 0 번 이상 증가 (+ +*N*)를 비교 하 여 개체 및 *B* 한정 된 수의 증가 한 후 (*N*   ==  *B*).

- 구 "각 *N* 범위의 \[ *A*, *B*)" 즉 *N* 값으로 시작 *를*0 번 이상 값과 같을 때까지 증가 하 고 *B*합니다. *N* == *B*의 경우는 범위에 포함되지 않습니다.

- 구 "가장 낮은 값 *N* 범위의 \[ *는*를 *B*) 되도록 *X*" 조건을 즉*X* 각각에 대 한 결정 됩니다 *N* 범위의 \[ *A*를 *B*) 조건까지 *X*충족 됩니다.

- 구 "상한을 *N* 범위의 \[ *는*, *B*) 되도록 *X* 즉 *X* 각각에 대 한 결정 됩니다 *N* 범위의 \[ *A*를 *B*). 함수에 저장 *K* 사본을 *N* 될 때마다 조건을 *X* 충족 됩니다. 이러한 저장이 발생 하는 경우 함수 최종 값을 바꿉니다 *N*, 같은 *B*의 값을 사용 하 여 *K*합니다. 그러나 양방향 또는 임의 액세스 반복기의 경우 *N*이 범위의 가장 높은 값부터 시작하고 *X* 조건이 충족될 때까지 범위에서 감소함을 의미할 수도 있습니다.

- *X* - *Y*와 같은 식입니다. 여기서 *X* 및 *Y*는 임의 액세스 반복기 이외의 반복기일 수 있으며 수학적 의미로 사용됩니다. 함수에서 연산자를 반드시 계산 되지 않습니다 **-** 이러한 값을 확인 해야 합니다. *X* + *N* 및 *X* - *N* 같은 식에 대해서도 마찬가지입니다. 여기서 *N*은 정수 형식입니다.

여러 알고리즘이 사용 하 여 같은 pairwise 비교를 수행 하는 조건자를 사용 `operator==`생성 하는 **bool** 결과입니다. 조건자 함수 `operator==` 또는 해당 대체 항목은 피연산자 중 하나를 변경하면 안 됩니다. 동일한 생성 해야 합니다 **bool** 발생 될 때마다 평가 되 고 피연산자를 피연산자 중 하나가의 복사본을 대체 하는 경우 동일한 결과 생성 해야 합니다.

여러 알고리즘이 시퀀스의 요소 쌍에 대해 엄격하고 약한 순서를 적용해야 하는 조건자를 사용합니다. 조건자 *pred*(*X*하십시오 *Y*):

- 즉 Strict *pred*(*X*에 *X*)은 false입니다.

- 즉 약한 *X* 하 고 *Y* 는 해당 주문 경우 \! *pred*(*X*를 *Y*) & & \! *pred*(*Y*하십시오 *X*) (*X* == *Y*정의 될 필요가 없습니다).

- 즉 순서 *pred*(*X*하십시오 *Y*) & & *pred*(*Y*, *Z*) 의미 *pred*(*X*하십시오 *Z*).

이러한 알고리즘 중 일부는 *X* \< *Y* 조건자를 암시적으로 사용합니다. 일반적으로 엄격 하 고 약한 순서 요구 사항을 충족 하는 다른 조건자 *X* > *Y*하십시오 `less`(*X*, *Y*), 및 `greater`(*X*하십시오 *Y*). 그러나 *X* \<= *Y* 및 *X* >= *Y*와 같은 조건자는 이 요구 사항을 충족하지 않습니다.

반복기 범위에 의해 지정 된 요소의 시퀀스로 \[ *첫 번째*합니다 *마지막*) 연산자에 의해 정렬 순서가 **<** 경우 각  *N* 범위의 \[0 *마지막* - *첫 번째*) 및 각 *M* 범위의 (*N*하십시오 *마지막* - *첫 번째*) 조건자 \!(\*(*첫 번째*  +  *M*) < \*(*첫 번째* + *N*))도 마찬가지입니다. 요소는 오름차순으로 정렬됩니다. 조건자 함수 `operator<` 또는 해당 대체 항목은 피연산자 중 하나를 변경하면 안 됩니다. 동일한 생성 해야 합니다 **bool** 발생 될 때마다 평가 되 고 피연산자를 피연산자 중 하나가의 복사본을 대체 하는 경우 동일한 결과 생성 해야 합니다. 또한 비교하는 피연산자에 엄격하고 약한 순서를 적용해야 합니다.

반복기 범위에 의해 지정 된 요소의 시퀀스로 \[ `First`, `Last`) 별로 정렬 되는 힙 `operator<` 경우 각각에 대해 *N* 범위의 \[1, *마지막*  -  *첫 번째*) 조건자 \!(\*_첫 번째_ < \*(*첫 번째*  +  *N*))도 마찬가지입니다. 첫 번째 요소가 가장 큽니다. 내부 구조는 템플릿 함수에만 알려져 [make_heap](../standard-library/algorithm-functions.md#make_heap)를 [pop_heap](../standard-library/algorithm-functions.md#pop_heap), 및 [push_heap](../standard-library/algorithm-functions.md#push_heap)합니다. 정렬 된 시퀀스에서 조건자 함수의와 마찬가지로 `operator<`, 하지만 해당 대체 항목 피연산자 중 하나를 변경 하지 말아야 및 비교 하는 피연산자에서 엄밀히 약한 정렬을 적용 해야 합니다. 동일한 생성 해야 합니다 **bool** 발생 될 때마다 평가 되 고 피연산자를 피연산자 중 하나가의 복사본을 대체 하는 경우 동일한 결과 생성 해야 합니다.

C++ 표준 라이브러리 알고리즘은 [\<algorithm>](../standard-library/algorithm.md) 및 [\<numeric>](../standard-library/numeric.md) 헤더 파일에 있습니다.

## <a name="see-also"></a>참고자료

[C++ 표준 라이브러리 참조](../standard-library/cpp-standard-library-reference.md)<br/>
[C++ 표준 라이브러리의 스레드 보안](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
