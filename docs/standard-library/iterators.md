---
title: 반복기
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: d72cd26f2642816efae2ec826df1bd9fa02e7531
ms.sourcegitcommit: 8bb2bea1384b290b7570b01608a86c7488ae7a02
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/26/2019
ms.locfileid: "67400419"
---
# <a name="iterators"></a>반복기

반복기는 C++ 표준 라이브러리 컨테이너에 있는 요소를 반복하고 개별 요소에 대한 액세스를 제공할 수 있는 개체입니다. C++ 표준 라이브러리 컨테이너는 모두 반복기를 제공하므로 요소가 저장되는 컨테이너 형식을 확인하지 않고도 알고리즘에서 표준 방식으로 해당 요소에 액세스할 수 있습니다.

명시적으로 같은 멤버 및 전역 함수를 사용 하는 반복기를 사용할 수 있습니다 `begin()` 하 고 `end()` 와 같은 연산자 **++** 하 고 **--** 앞으로 이동 하려면 또는 이전 버전과 합니다. 범위를 사용 하 여 반복기를 암시적으로 사용할 수도 있습니다-for 루프 또는 (일부 반복기 형식)에 대 한 첨자 연산자  **\[]** 합니다.

C++ 표준 라이브러리에서 시퀀스 또는 범위의 시작 부분이 첫 번째 요소입니다. 시퀀스 또는 범위의 끝 부분은 항상 마지막 요소 다음의 요소로 정의됩니다. 전역 함수 `begin` 고 `end` 지정된 된 컨테이너에 반복기를 반환 합니다. 컨테이너의 모든 요소에 한 일반적인 명시적 반복기 루프 모양은 다음과 같습니다.

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

range-for 루프를 사용하여 이 작업을 다 간단하게 수행할 수 있습니다.

```cpp
for (auto num : vec)
{
    // no deference operator
    cout << num << " ";
}
```

반복기에는 5가지 범주가 있습니다. 범주는 증가하는 거듭제곱 순으로 다음과 같습니다.

- **출력**. *출력 반복기* `X` 정방향으로 반복 시퀀스를 사용 하 여 합니다 **++** 연산자를 사용 하 여 요소를 한 번만 작성할 수는 __\*__ 연산자입니다.

- **입력**. *입력된 반복기* `X` 정방향으로 반복 시퀀스를 사용 하 여는 + + 연산자를 사용 하 여 요소를 여러 번 읽을 수 있습니다는 **&ast;** 연산자. 사용 하 여 입력된 반복기를 비교할 수는 **++** 하 고 **! =** 연산자입니다. 입력 반복기의 복사본을 증가시킨 후에는 다른 복사본을 안전하게 비교하거나 역참조하거나 증가시킬 수 없습니다.

- **정방향**. A *정방향 반복기* `X` 사용 하 여 시퀀스를 순방향으로 반복을 + + 연산자 및 모든 요소를 읽을 하 하거나 사용 하 여 원하는 횟수 만큼 비 const 요소를 작성할 수 있습니다 합니다 **&ast;** 연산자입니다. 사용 하 여 요소 멤버에 액세스할 수 있습니다 합니다 **->** 연산자 및 비교를 사용 하 여 반복기를 전달 합니다 **==** 및 **! =** 연산자입니다. 정방향 반복기 복사본을 여러 개 만들어 각각을 독립적으로 역참조하고 증가시킬 수 있습니다. 모든 컨테이너에 대 한 참조 라고 없이 초기화 되는 정방향 반복기를 *null 정방향 반복기*합니다. Null 정방향 반복기는 항상 동일한지 비교됩니다.

- **양방향**합니다. A *양방향 반복기* `X` 하는 정방향 반복기 대신 사용할 수 있습니다. 하지만 에서처럼 양방향 반복기를도 감소 수 `--X`, `X--`, 또는 `(V = *X--)`합니다. 요소 멤버에 액세스할 수 있고, 정방향 반복기와 동일한 방식으로 양방향 반복기를 비교할 수 있습니다.

- **임의 액세스**. A *임의 액세스 반복기* `X` 는 양방향 반복기 대신 사용할 수 있습니다. 첨자 연산자를 사용 하 여 임의 액세스 반복기를 사용 하 여  **\[]** 요소에 액세스 합니다. 사용할 수는 **+** , **-** 를 **+=** 하 고 **-=** 이동할 연산자 앞으로 또는 뒤로 지정된 된 수의 요소 및 반복기 사이의 거리를 계산 합니다. 사용 하 여 양방향 반복기를 비교할 수 있습니다 **==** , **! =** , **\<** 하십시오 **>** , **\< =** , 및 **>=** 합니다.

모든 반복기는 할당하거나 복사할 수 있습니다. 반복기는 간단한 개체로 간주되며 종종 참조가 아닌 값으로 전달되고 반환됩니다. 또한 앞에서 설명한 모든 연산은 유효한 반복기에서 수행될 경우 예외를 throw하지 않습니다.

반복기 범주의 계층 구조는 세 가지 시퀀스를 표시하여 요약할 수 있습니다. 시퀀스에 대한 쓰기 전용 액세스의 경우 다음을 사용할 수 있습니다.

> 출력 반복기<br/>
> 정방향 반복기-><br/>
> 양방향 반복기를-><br/>
> 임의 액세스 반복기->

오른쪽 화살표는 “대체할 수 있음"을 의미합니다. 예를 들어 출력 반복기에 대해 호출되는 모든 알고리즘은 정방향 반복기에서 원활하게 작동해야 하지만 반대의 경우는 작동하지 *않습니다*.

시퀀스에 대한 읽기 전용 액세스의 경우 다음을 사용할 수 있습니다.

> 입력된 반복기<br/>
> 정방향 반복기-><br/>
> 양방향 반복기를-><br/>
> 임의 액세스 반복기->

이 경우 입력 반복기는 모든 범주 중에서 가장 약합니다.

마지막으로 시퀀스에 대한 읽기/쓰기 권한의 경우 다음을 사용할 수 있습니다.

> 정방향 반복기<br/>
> 양방향 반복기를-><br/>
> 임의 액세스 반복기->

개체 포인터는 항상 임의 액세스 반복기로 사용할 수 있으므로 지정된 시퀀스에 대해 적절한 읽기/쓰기 권한을 지원하는 경우 모든 범주의 반복기로 사용할 수 있습니다.

개체 포인터가 아닌 반복기 `Iterator`는 특수화 `iterator_traits<Iterator>`에 필요한 멤버 형식도 정의해야 합니다. 이러한 요구 사항은 공용 기본 클래스 [iterator](../standard-library/iterator-struct.md)에서 `Iterator`를 파생시켜 충족할 수 있습니다.

C++ 표준 라이브러리의 컨테이너 및 알고리즘에서 반복기가 어떻게 사용되는지 확인하려면 각 반복기 범주의 약속 및 제한을 이해해야 합니다.

> [!NOTE]
> range-for 루프를 사용하여 반복기를 명시적으로 사용하지 않도록 할 수 있습니다. 자세한 내용은 [범위 기반 for 문](../cpp/range-based-for-statement-cpp.md)합니다.

Microsoft C++ 이제 제품에 컨테이너의 경계를 덮어쓰지 않도록 하는 반복기 및 디버그 반복기 확인 합니다. 자세한 내용은 [확인된 반복기](../standard-library/checked-iterators.md) 및 [디버그 반복기 지원](../standard-library/debug-iterator-support.md)을 참조하세요.

## <a name="see-also"></a>참고자료

[C++ 표준 라이브러리 참조](../standard-library/cpp-standard-library-reference.md)<br/>
[C++ 표준 라이브러리의 스레드 보안](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
