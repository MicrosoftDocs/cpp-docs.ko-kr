---
title: 우선 순위 및 식 평가 순서
ms.date: 07/11/2019
helpviewer_keywords:
- associativity of operators [C++]
- precedence [C++], operators
- data binding [C++], operator precedence
- operators [C++], precedence
ms.assetid: 201f7864-0c51-4c55-9d6f-39c5d013bcb0
ms.openlocfilehash: c1a5feb4552dd43b26263ebd3080e18adef6cb32
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/27/2020
ms.locfileid: "87211738"
---
# <a name="precedence-and-order-of-evaluation"></a>우선 순위 및 식 평가 순서

C 연산자의 우선 순위와 결합성은 식의 피연산자 그룹화 및 계산에 영향을 줍니다. 연산자의 우선 순위는 우선 순위가 더 높거나 낮은 다른 연산자가 있는 경우에만 의미가 있습니다. 우선 순위가 높은 연산자가 있는 식이 먼저 계산됩니다. 우선 순위는 단어 "바인딩"으로도 설명할 수 있습니다. 우선 순위가 높은 연산자는 더욱 엄격한 바인딩을 가져야 합니다.

다음 표는 C 연산자의 우선 순위(피연산자 계산 순서)와 결합성을 우선 순위가 높은 것부터 낮은 것 순서로 나열 및 요약한 것입니다. 여러 개의 연산자가 함께 표시된 경우, 해당 연산자는 우선 순위가 같으므로 각각의 연관성에 따라 계산됩니다. 표에 나온 연산자는 [후위 연산자](../c-language/postfix-operators.md)를 처음에 다루는 단원에 설명되어 있습니다. 이 단원의 나머지 부분에서는 우선 순위 및 결합성에 대한 일반적인 정보를 제공합니다.

## <a name="precedence-and-associativity-of-c-operators"></a>C 연산자의 우선 순위 및 결합성

| 기호 <sup>1</sup> | 연산 유형 | associativity |
|-------------|-----------------------|-------------------|
| `[` `]` `(` `)` `.` `->`<br/>`++` `--` (후위) | 식 | 왼쪽에서 오른쪽 |
| **`sizeof`** `&` `*` `+` `-` `~` `!`<br/>`++` `--` (전위) | 단항 | 오른쪽에서 왼쪽 |
| *형식 캐스팅* | 단항 | 오른쪽에서 왼쪽 |
| `*` `/` `%` | 곱하기 | 왼쪽에서 오른쪽 |
| `+` `-` | 더하기 | 왼쪽에서 오른쪽 |
| `<<` `>>` | 비트 시프트 | 왼쪽에서 오른쪽 |
| `<` `>` `<=` `>=` | 관계 | 왼쪽에서 오른쪽 |
| `==` `!=` | 같음 | 왼쪽에서 오른쪽 |
| `&` | 비트 AND | 왼쪽에서 오른쪽 |
| `^` | 비트 제외 OR | 왼쪽에서 오른쪽 |
| `|` | 비트 포함 OR | 왼쪽에서 오른쪽 |
| `&&` | 논리 AND | 왼쪽에서 오른쪽 |
| `||` | 논리 OR | 왼쪽에서 오른쪽 |
| `? :` | 조건식 | 오른쪽에서 왼쪽 |
| `=` `*=` `/=` `%=`<br/>`+=` `-=` `<<=` `>>=` `&=`<br/>`^=` `|=` | 단순 및 복합 할당 <sup>2</sup> | 오른쪽에서 왼쪽 |
| `,` | 순차적 계산 | 왼쪽에서 오른쪽 |

<sup>1</sup> 연산자는 내림차순 우선 순위로 나열됩니다. 여러 연산자가 같은 줄 또는 그룹에 표시된 경우, 해당 연산자는 우선 순위가 같습니다.

<sup>2</sup> 모든 단순 및 복합 할당 연산자의 우선 순위는 같습니다.

식에 우선 순위가 같은 여러 연산자가 포함될 수 있습니다. 여러 연산자가 하나의 식에 같은 수준으로 표시된 경우, 오른쪽에서 왼쪽 또는 왼쪽에서 오른쪽으로 연산자의 연관성에 따라 계산이 진행됩니다. 계산의 방향은 같은 수준에 있는 곱하기(`*`), 더하기(`+`) 또는 이진 비트(`&`, `|` 또는 `^`) 연산자가 둘 이상 포함된 식의 결과에 영향을 주지 않습니다. 연산 순서는 언어에 따라 정의되지 않습니다. 컴파일러는 일관된 결과를 보장할 수 있는 경우 어떠한 순서로든 이러한 식을 자유롭게 계산합니다.

순차적 계산(`,`), 논리적 AND(`&&`), 논리적 OR(`||`), 조건식(`? :`) 및 함수 호출 연산자만 시퀀스 포인트를 구성하므로 피연산자에 대한 특정 계산 순서를 보장합니다. 함수 호출 연산자는 함수 식별자 뒤에 오는 괄호의 집합입니다. 순차적 계산 연산자(`,`)는 피연산자를 왼쪽에서 오른쪽으로 계산합니다. (함수 호출의 쉼표 연산자는 순차적 계산 연산자와 동일하지 않으며 동일하다는 보장도 제공하지 않습니다.) 자세한 내용은 [시퀀스 포인트](c-sequence-points.md)를 참조하세요.

논리 연산자도 피연산자를 왼쪽에서 오른쪽으로 계산합니다. 하지만 식의 결과를 결정하는 데 필요한 최소 피연산자 수를 계산합니다. 이것을 "단락(short-circuit)" 계산이라고 합니다. 따라서 식의 일부 피연산자는 계산될 수 없습니다. 예를 들어, 식에서

`x && y++`

두 번째 피연산자, `y++`는 `x`가 true(0 이외의 값)인 경우에만 계산됩니다. 따라서 `y`는 `x`가 false(0)인 경우 증가하지 않습니다.

## <a name="examples"></a>예

다음 목록에서는 컴파일러가 자동으로 몇 가지 예제 식을 바인딩하는 방법을 보여 줍니다.

| 식 | 자동 바인딩 |
|----------------|-----------------------|
| `a & b || c` | `(a & b) || c` |
| `a = b || c` | `a = (b || c)` |
| `q && r || s--` | `(q && r) || s--` |

첫 번째 식에서 비트 AND 연산자(`&`)는 논리 OR 연산자(`||`)보다 우선 순위가 높기 때문에 `a & b`가 논리 OR 연산의 첫 번째 피연산자가 됩니다.

두 번째 식에서 논리 OR 연산자(`||`)는 단순 할당 연산자(`=`)보다 우선 순위가 높습니다. 따라서 `b || c`는 할당에서 오른쪽 피연산자 그룹이 됩니다. `a`에 할당되는 값은 0 또는 1입니다.

세 번째 식은 예기치 않은 결과가 발생할 수 있는 올바른 식을 보여 줍니다. 논리 AND 연산자(`&&`)는 논리 OR 연산자(`||`)보다 우선 순위가 높기 때문에 `q && r`은 단일 피연산자 그룹이 됩니다. 논리 연산자는 피연산자가 왼쪽에서 오른쪽으로 계산되도록 보장하므로 `q && r`은 `s--`보다 먼저 계산됩니다. 그러나 `q && r`이 0 이외의 값으로 계산되는 경우, `s--`는 계산되지 않고 `s`는 줄어들지 않습니다. `s`가 줄어들지 않아 프로그램에 문제가 발생할 경우 `s--`가 식의 첫째 피연산자로 표시되거나 `s`가 별도 연산에서 감소됩니다.

다음 식은 잘못되었으며 컴파일 시 진단 메시지를 생성합니다.

| 잘못된 식 | 기본 그룹화 |
|------------------------|----------------------|
| `p == 0 ? p += 1: p += 2` | `( p == 0 ? p += 1 : p ) += 2` |

이 식에서는 같음 연산자(`==`)의 우선 순위가 가장 높으므로 `p == 0`은 피연산자 그룹이 됩니다. 조건식 연산자(`? :`)의 우선 순위는 그 다음으로 높습니다. 첫 번째 피연산자는 `p == 0`이고, 두 번째 피연산자는 `p += 1`입니다. 그러나 `p`가 복합 할당 연산자보다 조건식 연산자에 더 가까이 바인딩되기 때문에 마지막 조건식 연산자의 피연산자는 `p += 2`가 아닌 `p`로 간주됩니다. `+= 2`에 왼쪽 피연산자가 없기 때문에 구문 오류가 발생합니다. 이러한 종류의 오류를 방지하고 보다 읽기 쉬운 코드를 생성하려면 괄호를 사용해야 합니다. 예를 들어, 아래와 같이 괄호를 사용하여 앞의 예제를 수정하고 명확하게 만들 수 있습니다.

`( p == 0 ) ? ( p += 1 ) : ( p += 2 )`

## <a name="see-also"></a>참조

[C 연산자](c-operators.md)
